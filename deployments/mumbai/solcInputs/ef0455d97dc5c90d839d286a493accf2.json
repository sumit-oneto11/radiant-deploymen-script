{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/solidity-examples/contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00), and(mload(mc), mask)))\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint _start) internal pure returns (uint) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/libraries/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint constant LOW_28_MASK = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                0, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf) internal pure {\n        require(_buf.length >= 4);\n        uint _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/LzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"../libraries/BytesLib.sol\";\n\n/*\n * a generic LzReceiver implementation\n */\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint public constant DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(\n            _srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote),\n            \"LzApp: invalid source sending contract\"\n        );\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n\n    function _lzSend(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint _nativeFee\n    ) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(\n        uint16 _dstChainId,\n        uint16 _type,\n        bytes memory _adapterParams,\n        uint _extraGas\n    ) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type];\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\n        require(providedGasLimit >= minGasLimit + _extraGas, \"LzApp: gas limit is too low\");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) {\n            // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, \"LzApp: payload size is too large\");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, \"LzApp: no trusted path record\");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(\n        uint16 _dstChainId,\n        uint16 _packetType,\n        uint _minGas\n    ) external onlyOwner {\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./LzApp.sol\";\nimport \"../libraries/ExcessivelySafeCall.sol\";\n\n/*\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\n */\nabstract contract NonblockingLzApp is LzApp {\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload)\n        );\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload,\n        bytes memory _reason\n    ) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n\n    function retryMessage(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/BaseOFTV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./OFTCoreV2.sol\";\nimport \"./interfaces/IOFTV2.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract BaseOFTV2 is OFTCoreV2, ERC165, IOFTV2 {\n    constructor(uint8 _sharedDecimals, address _lzEndpoint) OFTCoreV2(_sharedDecimals, _lzEndpoint) {}\n\n    /************************************************************************\n     * public functions\n     ************************************************************************/\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        LzCallParams calldata _callParams\n    ) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _callParams.refundAddress, _callParams.zroPaymentAddress, _callParams.adapterParams);\n    }\n\n    function sendAndCall(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes calldata _payload,\n        uint64 _dstGasForCall,\n        LzCallParams calldata _callParams\n    ) public payable virtual override {\n        _sendAndCall(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _payload,\n            _dstGasForCall,\n            _callParams.refundAddress,\n            _callParams.zroPaymentAddress,\n            _callParams.adapterParams\n        );\n    }\n\n    /************************************************************************\n     * public view functions\n     ************************************************************************/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTV2).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) public view virtual override returns (uint nativeFee, uint zroFee) {\n        return _estimateSendFee(_dstChainId, _toAddress, _amount, _useZro, _adapterParams);\n    }\n\n    function estimateSendAndCallFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes calldata _payload,\n        uint64 _dstGasForCall,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) public view virtual override returns (uint nativeFee, uint zroFee) {\n        return _estimateSendAndCallFee(_dstChainId, _toAddress, _amount, _payload, _dstGasForCall, _useZro, _adapterParams);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint);\n\n    function token() public view virtual override returns (address);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/interfaces/ICommonOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n */\ninterface ICommonOFT is IERC165 {\n\n    struct LzCallParams {\n        address payable refundAddress;\n        address zroPaymentAddress;\n        bytes adapterParams;\n    }\n\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _amount - amount of the tokens to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    function estimateSendAndCallFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev returns the circulating amount of tokens on current chain\n     */\n    function circulatingSupply() external view returns (uint);\n\n    /**\n     * @dev returns the address of the ERC20 token\n     */\n    function token() external view returns (address);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/interfaces/IOFTReceiverV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface IOFTReceiverV2 {\n    /**\n     * @dev Called by the OFT contract when tokens are received from source chain.\n     * @param _srcChainId The chain id of the source chain.\n     * @param _srcAddress The address of the OFT token contract on the source chain.\n     * @param _nonce The nonce of the transaction on the source chain.\n     * @param _from The address of the account who calls the sendAndCall() on the source chain.\n     * @param _amount The amount of tokens to transfer.\n     * @param _payload Additional data with no specified format.\n     */\n    function onOFTReceived(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes32 _from, uint _amount, bytes calldata _payload) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/interfaces/IOFTV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ICommonOFT.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n */\ninterface IOFTV2 is ICommonOFT {\n\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, LzCallParams calldata _callParams) external payable;\n\n    function sendAndCall(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, LzCallParams calldata _callParams) external payable;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTCoreV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../../lzApp/NonblockingLzApp.sol\";\nimport \"../../../libraries/ExcessivelySafeCall.sol\";\nimport \"./interfaces/ICommonOFT.sol\";\nimport \"./interfaces/IOFTReceiverV2.sol\";\n\nabstract contract OFTCoreV2 is NonblockingLzApp {\n    using BytesLib for bytes;\n    using ExcessivelySafeCall for address;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint8 public constant PT_SEND = 0;\n    uint8 public constant PT_SEND_AND_CALL = 1;\n\n    uint8 public immutable sharedDecimals;\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public creditedPackets;\n\n    /**\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes32 indexed _toAddress, uint _amount);\n\n    /**\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n     * `_nonce` is the inbound nonce.\n     */\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\n\n    event CallOFTReceivedSuccess(uint16 indexed _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _hash);\n\n    event NonContractAddress(address _address);\n\n    // _sharedDecimals should be the minimum decimals on all chains\n    constructor(uint8 _sharedDecimals, address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {\n        sharedDecimals = _sharedDecimals;\n    }\n\n    /************************************************************************\n     * public functions\n     ************************************************************************/\n    function callOnOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes32 _from,\n        address _to,\n        uint _amount,\n        bytes calldata _payload,\n        uint _gasForCall\n    ) public virtual {\n        require(_msgSender() == address(this), \"OFTCore: caller must be OFTCore\");\n\n        // send\n        _amount = _transferFrom(address(this), _to, _amount);\n        emit ReceiveFromChain(_srcChainId, _to, _amount);\n\n        // call\n        IOFTReceiverV2(_to).onOFTReceived{gas: _gasForCall}(_srcChainId, _srcAddress, _nonce, _from, _amount, _payload);\n    }\n\n    /************************************************************************\n     * internal functions\n     ************************************************************************/\n    function _estimateSendFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) internal view virtual returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = _encodeSendPayload(_toAddress, _ld2sd(_amount));\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function _estimateSendAndCallFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes memory _payload,\n        uint64 _dstGasForCall,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) internal view virtual returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendAndCall()\n        bytes memory payload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(_amount), _payload, _dstGasForCall);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        uint8 packetType = _payload.toUint8(0);\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else if (packetType == PT_SEND_AND_CALL) {\n            _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert(\"OFTCore: unknown packet type\");\n        }\n    }\n\n    function _send(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal virtual returns (uint amount) {\n        _checkGasLimit(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        (amount, ) = _removeDust(_amount);\n        amount = _debitFrom(_from, _dstChainId, _toAddress, amount); // amount returned should not have dust\n        require(amount > 0, \"OFTCore: amount too small\");\n\n        bytes memory lzPayload = _encodeSendPayload(_toAddress, _ld2sd(amount));\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(\n        uint16 _srcChainId,\n        bytes memory,\n        uint64,\n        bytes memory _payload\n    ) internal virtual {\n        (address to, uint64 amountSD) = _decodeSendPayload(_payload);\n        if (to == address(0)) {\n            to = address(0xdead);\n        }\n\n        uint amount = _sd2ld(amountSD);\n        amount = _creditTo(_srcChainId, to, amount);\n\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _sendAndCall(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes memory _payload,\n        uint64 _dstGasForCall,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal virtual returns (uint amount) {\n        _checkGasLimit(_dstChainId, PT_SEND_AND_CALL, _adapterParams, _dstGasForCall);\n\n        (amount, ) = _removeDust(_amount);\n        amount = _debitFrom(_from, _dstChainId, _toAddress, amount);\n        require(amount > 0, \"OFTCore: amount too small\");\n\n        // encode the msg.sender into the payload instead of _from\n        bytes memory lzPayload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(amount), _payload, _dstGasForCall);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAndCallAck(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual {\n        (bytes32 from, address to, uint64 amountSD, bytes memory payloadForCall, uint64 gasForCall) = _decodeSendAndCallPayload(_payload);\n\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        uint amount = _sd2ld(amountSD);\n\n        // credit to this contract first, and then transfer to receiver only if callOnOFTReceived() succeeds\n        if (!credited) {\n            amount = _creditTo(_srcChainId, address(this), amount);\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n\n        if (!_isContract(to)) {\n            emit NonContractAddress(to);\n            return;\n        }\n\n        // workaround for stack too deep\n        uint16 srcChainId = _srcChainId;\n        bytes memory srcAddress = _srcAddress;\n        uint64 nonce = _nonce;\n        bytes memory payload = _payload;\n        bytes32 from_ = from;\n        address to_ = to;\n        uint amount_ = amount;\n        bytes memory payloadForCall_ = payloadForCall;\n\n        // no gas limit for the call if retry\n        uint gas = credited ? gasleft() : gasForCall;\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.callOnOFTReceived.selector, srcChainId, srcAddress, nonce, from_, to_, amount_, payloadForCall_, gas)\n        );\n\n        if (success) {\n            bytes32 hash = keccak256(payload);\n            emit CallOFTReceivedSuccess(srcChainId, srcAddress, nonce, hash);\n        } else {\n            // store the failed message into the nonblockingLzApp\n            _storeFailedMessage(srcChainId, srcAddress, nonce, payload, reason);\n        }\n    }\n\n    function _isContract(address _account) internal view returns (bool) {\n        return _account.code.length > 0;\n    }\n\n    function _ld2sd(uint _amount) internal view virtual returns (uint64) {\n        uint amountSD = _amount / _ld2sdRate();\n        require(amountSD <= type(uint64).max, \"OFTCore: amountSD overflow\");\n        return uint64(amountSD);\n    }\n\n    function _sd2ld(uint64 _amountSD) internal view virtual returns (uint) {\n        return _amountSD * _ld2sdRate();\n    }\n\n    function _removeDust(uint _amount) internal view virtual returns (uint amountAfter, uint dust) {\n        dust = _amount % _ld2sdRate();\n        amountAfter = _amount - dust;\n    }\n\n    function _encodeSendPayload(bytes32 _toAddress, uint64 _amountSD) internal view virtual returns (bytes memory) {\n        return abi.encodePacked(PT_SEND, _toAddress, _amountSD);\n    }\n\n    function _decodeSendPayload(bytes memory _payload) internal view virtual returns (address to, uint64 amountSD) {\n        require(_payload.toUint8(0) == PT_SEND && _payload.length == 41, \"OFTCore: invalid payload\");\n\n        to = _payload.toAddress(13); // drop the first 12 bytes of bytes32\n        amountSD = _payload.toUint64(33);\n    }\n\n    function _encodeSendAndCallPayload(\n        address _from,\n        bytes32 _toAddress,\n        uint64 _amountSD,\n        bytes memory _payload,\n        uint64 _dstGasForCall\n    ) internal view virtual returns (bytes memory) {\n        return abi.encodePacked(PT_SEND_AND_CALL, _toAddress, _amountSD, _addressToBytes32(_from), _dstGasForCall, _payload);\n    }\n\n    function _decodeSendAndCallPayload(bytes memory _payload)\n        internal\n        view\n        virtual\n        returns (\n            bytes32 from,\n            address to,\n            uint64 amountSD,\n            bytes memory payload,\n            uint64 dstGasForCall\n        )\n    {\n        require(_payload.toUint8(0) == PT_SEND_AND_CALL, \"OFTCore: invalid payload\");\n\n        to = _payload.toAddress(13); // drop the first 12 bytes of bytes32\n        amountSD = _payload.toUint64(33);\n        from = _payload.toBytes32(41);\n        dstGasForCall = _payload.toUint64(73);\n        payload = _payload.slice(81, _payload.length - 81);\n    }\n\n    function _addressToBytes32(address _address) internal pure virtual returns (bytes32) {\n        return bytes32(uint(uint160(_address)));\n    }\n\n    function _debitFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount\n    ) internal virtual returns (uint);\n\n    function _creditTo(\n        uint16 _srcChainId,\n        address _toAddress,\n        uint _amount\n    ) internal virtual returns (uint);\n\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _amount\n    ) internal virtual returns (uint);\n\n    function _ld2sdRate() internal view virtual returns (uint);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./BaseOFTV2.sol\";\n\ncontract OFTV2 is BaseOFTV2, ERC20 {\n    uint internal immutable ld2sdRate;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _sharedDecimals,\n        address _lzEndpoint\n    ) ERC20(_name, _symbol) BaseOFTV2(_sharedDecimals, _lzEndpoint) {\n        uint8 decimals = decimals();\n        require(_sharedDecimals <= decimals, \"OFT: sharedDecimals must be <= decimals\");\n        ld2sdRate = 10**(decimals - _sharedDecimals);\n    }\n\n    /************************************************************************\n     * public functions\n     ************************************************************************/\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    /************************************************************************\n     * internal functions\n     ************************************************************************/\n    function _debitFrom(\n        address _from,\n        uint16,\n        bytes32,\n        uint _amount\n    ) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(\n        uint16,\n        address _toAddress,\n        uint _amount\n    ) internal virtual override returns (uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _amount\n    ) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        // if transfer from this contract, no need to check allowance\n        if (_from != address(this) && _from != spender) _spendAllowance(_from, spender, _amount);\n        _transfer(_from, _to, _amount);\n        return _amount;\n    }\n\n    function _ld2sdRate() internal view virtual override returns (uint) {\n        return ld2sdRate;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n\n    /**\n   * @dev Sets {decimals} to a value other than the default one of 18.\n   *\n   * WARNING: This function should only be called from the constructor. Most\n   * applications that interact with token contracts will not expect\n   * {decimals} to ever change, and may work incorrectly if it does.\n   */\n  function _setupDecimals(uint8 decimals_) internal {\n    _decimals = decimals_;\n  }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/dependencies/math/BConst.sol": {
      "content": "// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.12;\n\ncontract BConst {\n\tuint public constant BONE = 10 ** 18;\n\n\tuint public constant MIN_BOUND_TOKENS = 2;\n\tuint public constant MAX_BOUND_TOKENS = 8;\n\n\tuint public constant MIN_FEE = BONE / 10 ** 6;\n\tuint public constant MAX_FEE = BONE / 10;\n\tuint public constant EXIT_FEE = 0;\n\n\tuint public constant MIN_WEIGHT = BONE;\n\tuint public constant MAX_WEIGHT = BONE * 50;\n\tuint public constant MAX_TOTAL_WEIGHT = BONE * 50;\n\tuint public constant MIN_BALANCE = BONE / 10 ** 12;\n\n\tuint public constant INIT_POOL_SUPPLY = BONE * 100;\n\n\tuint public constant MIN_BPOW_BASE = 1 wei;\n\tuint public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n\tuint public constant BPOW_PRECISION = BONE / 10 ** 10;\n\n\tuint public constant MAX_IN_RATIO = BONE / 2;\n\tuint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/dependencies/math/BNum.sol": {
      "content": "// https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.12;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n\tfunction btoi(uint a) internal pure returns (uint) {\n\t\treturn a / BONE;\n\t}\n\n\tfunction bfloor(uint a) internal pure returns (uint) {\n\t\treturn btoi(a) * BONE;\n\t}\n\n\tfunction badd(uint a, uint b) internal pure returns (uint) {\n\t\tuint c = a + b;\n\t\trequire(c >= a, \"ERR_ADD_OVERFLOW\");\n\t\treturn c;\n\t}\n\n\tfunction bsub(uint a, uint b) internal pure returns (uint) {\n\t\t(uint c, bool flag) = bsubSign(a, b);\n\t\trequire(!flag, \"ERR_SUB_UNDERFLOW\");\n\t\treturn c;\n\t}\n\n\tfunction bsubSign(uint a, uint b) internal pure returns (uint, bool) {\n\t\tif (a >= b) {\n\t\t\treturn (a - b, false);\n\t\t} else {\n\t\t\treturn (b - a, true);\n\t\t}\n\t}\n\n\tfunction bmul(uint a, uint b) internal pure returns (uint) {\n\t\tuint c0 = a * b;\n\t\trequire(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n\t\tuint c1 = c0 + (BONE / 2);\n\t\trequire(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n\t\tuint c2 = c1 / BONE;\n\t\treturn c2;\n\t}\n\n\tfunction bdiv(uint a, uint b) internal pure returns (uint) {\n\t\trequire(b != 0, \"ERR_DIV_ZERO\");\n\t\tuint c0 = a * BONE;\n\t\trequire(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n\t\tuint c1 = c0 + (b / 2);\n\t\trequire(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n\t\tuint c2 = c1 / b;\n\t\treturn c2;\n\t}\n\n\t// DSMath.wpow\n\tfunction bpowi(uint a, uint n) internal pure returns (uint) {\n\t\tuint z = n % 2 != 0 ? a : BONE;\n\n\t\tfor (n /= 2; n != 0; n /= 2) {\n\t\t\ta = bmul(a, a);\n\n\t\t\tif (n % 2 != 0) {\n\t\t\t\tz = bmul(z, a);\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}\n\n\t// Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n\t// Use `bpowi` for `b^e` and `bpowK` for k iterations\n\t// of approximation of b^0.w\n\tfunction bpow(uint base, uint exp) internal pure returns (uint) {\n\t\trequire(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n\t\trequire(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n\t\tuint whole = bfloor(exp);\n\t\tuint remain = bsub(exp, whole);\n\n\t\tuint wholePow = bpowi(base, btoi(whole));\n\n\t\tif (remain == 0) {\n\t\t\treturn wholePow;\n\t\t}\n\n\t\tuint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n\t\treturn bmul(wholePow, partialResult);\n\t}\n\n\tfunction bpowApprox(uint base, uint exp, uint precision) internal pure returns (uint) {\n\t\t// term 0:\n\t\tuint a = exp;\n\t\t(uint x, bool xneg) = bsubSign(base, BONE);\n\t\tuint term = BONE;\n\t\tuint sum = term;\n\t\tbool negative = false;\n\n\t\t// term(k) = numer / denom\n\t\t//         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n\t\t// each iteration, multiply previous term by (a-(k-1)) * x / k\n\t\t// continue until term is less than precision\n\t\tfor (uint i = 1; term >= precision; i++) {\n\t\t\tuint bigK = i * BONE;\n\t\t\t(uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n\t\t\tterm = bmul(term, bmul(c, x));\n\t\t\tterm = bdiv(term, bigK);\n\t\t\tif (term == 0) break;\n\n\t\t\tif (xneg) negative = !negative;\n\t\t\tif (cneg) negative = !negative;\n\t\t\tif (negative) {\n\t\t\t\tsum = bsub(sum, term);\n\t\t\t} else {\n\t\t\t\tsum = badd(sum, term);\n\t\t\t}\n\t\t}\n\n\t\treturn sum;\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address payable) {\n\t\treturn payable(msg.sender);\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/contracts/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.8.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IERC20Detailed is IERC20 {\r\n  function name() external view returns (string memory);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint8);\r\n}"
    },
    "contracts/dependencies/openzeppelin/upgradeability/AdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for\n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n\t/**\n\t * Contract constructor.\n\t * @param _logic address of the initial implementation.\n\t * @param _admin Address of the proxy administrator.\n\t * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n\t */\n\tconstructor(address _logic, address _admin, bytes memory _data) payable UpgradeabilityProxy(_logic, _data) {\n\t\tassert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n\t\t_setAdmin(_admin);\n\t}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n\t\tBaseAdminUpgradeabilityProxy._willFallback();\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/BaseAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n\t/**\n\t * @dev Emitted when the administration has been transferred.\n\t * @param previousAdmin Address of the previous admin.\n\t * @param newAdmin Address of the new admin.\n\t */\n\tevent AdminChanged(address previousAdmin, address newAdmin);\n\n\t/**\n\t * @dev Storage slot with the admin of the contract.\n\t * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n\t * validated in the constructor.\n\t */\n\tbytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n\t/**\n\t * @dev Modifier to check whether the `msg.sender` is the admin.\n\t * If it is, it will run the function. Otherwise, it will delegate the call\n\t * to the implementation.\n\t */\n\tmodifier ifAdmin() {\n\t\tif (msg.sender == _admin()) {\n\t\t\t_;\n\t\t} else {\n\t\t\t_fallback();\n\t\t}\n\t}\n\n\t/**\n\t * @return _address The address of the proxy admin.\n\t */\n\tfunction admin() external ifAdmin returns (address _address) {\n\t\treturn _admin();\n\t}\n\n\t/**\n\t * @return _address The address of the implementation.\n\t */\n\tfunction implementation() external ifAdmin returns (address _address) {\n\t\treturn _implementation();\n\t}\n\n\t/**\n\t * @dev Changes the admin of the proxy.\n\t * Only the current admin can call this function.\n\t * @param newAdmin Address to transfer proxy administration to.\n\t */\n\tfunction changeAdmin(address newAdmin) external ifAdmin {\n\t\trequire(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n\t\temit AdminChanged(_admin(), newAdmin);\n\t\t_setAdmin(newAdmin);\n\t}\n\n\t/**\n\t * @dev Upgrade the backing implementation of the proxy.\n\t * Only the admin can call this function.\n\t * @param newImplementation Address of the new implementation.\n\t */\n\tfunction upgradeTo(address newImplementation) external ifAdmin {\n\t\t_upgradeTo(newImplementation);\n\t}\n\n\t/**\n\t * @dev Upgrade the backing implementation of the proxy and call a function\n\t * on the new implementation.\n\t * This is useful to initialize the proxied contract.\n\t * @param newImplementation Address of the new implementation.\n\t * @param data Data to send as msg.data in the low level call.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t */\n\tfunction upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n\t\t_upgradeTo(newImplementation);\n\t\t(bool success, ) = newImplementation.delegatecall(data);\n\t\trequire(success);\n\t}\n\n\t/**\n\t * @return adm The admin slot.\n\t */\n\tfunction _admin() internal view returns (address adm) {\n\t\tbytes32 slot = ADMIN_SLOT;\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tadm := sload(slot)\n\t\t}\n\t}\n\n\t/**\n\t * @dev Sets the address of the proxy admin.\n\t * @param newAdmin Address of the new proxy admin.\n\t */\n\tfunction _setAdmin(address newAdmin) internal {\n\t\tbytes32 slot = ADMIN_SLOT;\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tsstore(slot, newAdmin)\n\t\t}\n\t}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal virtual override {\n\t\trequire(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n\t\tsuper._willFallback();\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n\t/**\n\t * @dev Emitted when the implementation is upgraded.\n\t * @param implementation Address of the new implementation.\n\t */\n\tevent Upgraded(address indexed implementation);\n\n\t/**\n\t * @dev Storage slot with the address of the current implementation.\n\t * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n\t * validated in the constructor.\n\t */\n\tbytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n\t/**\n\t * @dev Returns the current implementation.\n\t * @return impl Address of the current implementation\n\t */\n\tfunction _implementation() internal view override returns (address impl) {\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\timpl := sload(slot)\n\t\t}\n\t}\n\n\t/**\n\t * @dev Upgrades the proxy to a new implementation.\n\t * @param newImplementation Address of the new implementation.\n\t */\n\tfunction _upgradeTo(address newImplementation) internal {\n\t\t_setImplementation(newImplementation);\n\t\temit Upgraded(newImplementation);\n\t}\n\n\t/**\n\t * @dev Sets the implementation address of the proxy.\n\t * @param newImplementation Address of the new implementation.\n\t */\n\tfunction _setImplementation(address newImplementation) internal {\n\t\trequire(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n\t\tbytes32 slot = IMPLEMENTATION_SLOT;\n\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tsstore(slot, newImplementation)\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./Initializable.sol\";\n\ncontract ContextUpgradeable is Initializable {\n\tfunction __Context_init() internal onlyInitializing {}\n\n\tfunction __Context_init_unchained() internal onlyInitializing {}\n\n\tfunction _msgSender() internal view virtual returns (address payable) {\n\t\treturn payable(msg.sender);\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes memory) {\n\t\tthis;\n\t\treturn msg.data;\n\t}\n\n\tuint256[50] private __gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/Initializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\t/**\n\t * @dev Indicates that the contract has been initialized.\n\t */\n\tbool private initialized;\n\n\t/**\n\t * @dev Indicates that the contract is in the process of being initialized.\n\t */\n\tbool private initializing;\n\n\t/**\n\t * @dev Modifier to use in the initializer function of a contract.\n\t */\n\tmodifier initializer() {\n\t\trequire(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n\t\tbool isTopLevelCall = !initializing;\n\t\tif (isTopLevelCall) {\n\t\t\tinitializing = true;\n\t\t\tinitialized = true;\n\t\t}\n\n\t\t_;\n\n\t\tif (isTopLevelCall) {\n\t\t\tinitializing = false;\n\t\t}\n\t}\n\n\t/// @dev Returns true if and only if the function is running in the constructor\n\tfunction isConstructor() private view returns (bool) {\n\t\t// extcodesize checks the size of the code stored in an address, and\n\t\t// address returns the current address. Since the code is still not\n\t\t// deployed when running a constructor, any checks on its code size will\n\t\t// yield zero, making it an effective way to detect if a contract is\n\t\t// under construction or not.\n\t\tuint256 cs;\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tcs := extcodesize(address())\n\t\t}\n\t\treturn cs == 0;\n\t}\n\n\tmodifier onlyInitializing() {\n\t\trequire(initializing, \"Initializable: contract is not initializing\");\n\t\t_;\n\t}\n\n\t// Reserved storage space to allow for layout changes in the future.\n\tuint256[50] private ______gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/InitializableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseAdminUpgradeabilityProxy.sol\";\nimport \"./InitializableUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for\n * initializing the implementation, admin, and init data.\n */\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\n\t/**\n\t * Contract initializer.\n\t * @param logic address of the initial implementation.\n\t * @param admin Address of the proxy administrator.\n\t * @param data Data to send as msg.data to the implementation to initialize the proxied contract.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n\t */\n\tfunction initialize(address logic, address admin, bytes memory data) public payable {\n\t\trequire(_implementation() == address(0));\n\t\tInitializableUpgradeabilityProxy.initialize(logic, data);\n\t\tassert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n\t\t_setAdmin(admin);\n\t}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {\n\t\tBaseAdminUpgradeabilityProxy._willFallback();\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableUpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n * implementation and init data.\n */\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n\t/**\n\t * @dev Contract initializer.\n\t * @param _logic Address of the initial implementation.\n\t * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n\t */\n\tfunction initialize(address _logic, bytes memory _data) public payable {\n\t\trequire(_implementation() == address(0));\n\t\tassert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n\t\t_setImplementation(_logic);\n\t\tif (_data.length > 0) {\n\t\t\t(bool success, ) = _logic.delegatecall(_data);\n\t\t\trequire(success);\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./Initializable.sol\";\nimport \"./ContextUpgradeable.sol\";\n\ncontract OwnableUpgradeable is Initializable, ContextUpgradeable {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\tfunction __Ownable_init() internal onlyInitializing {\n\t\t__Ownable_init_unchained();\n\t}\n\n\tfunction __Ownable_init_unchained() internal onlyInitializing {\n\t\t_transferOwnership(_msgSender());\n\t}\n\n\tfunction owner() public view virtual returns (address) {\n\t\treturn _owner;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\t_transferOwnership(address(0));\n\t}\n\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\t_transferOwnership(newOwner);\n\t}\n\n\tfunction _transferOwnership(address newOwner) internal virtual {\n\t\taddress oldOwner = _owner;\n\t\t_owner = newOwner;\n\t\temit OwnershipTransferred(oldOwner, newOwner);\n\t}\n\n\tuint256[49] private __gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./Initializable.sol\";\nimport \"./ContextUpgradeable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n\t/**\n\t * @dev Emitted when the pause is triggered by `account`.\n\t */\n\tevent Paused(address account);\n\n\t/**\n\t * @dev Emitted when the pause is lifted by `account`.\n\t */\n\tevent Unpaused(address account);\n\n\tbool private _paused;\n\n\t/**\n\t * @dev Initializes the contract in unpaused state.\n\t */\n\tfunction __Pausable_init() internal onlyInitializing {\n\t\t__Pausable_init_unchained();\n\t}\n\n\tfunction __Pausable_init_unchained() internal onlyInitializing {\n\t\t_paused = false;\n\t}\n\n\t/**\n\t * @dev Modifier to make a function callable only when the contract is not paused.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must not be paused.\n\t */\n\tmodifier whenNotPaused() {\n\t\t_requireNotPaused();\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier to make a function callable only when the contract is paused.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must be paused.\n\t */\n\tmodifier whenPaused() {\n\t\t_requirePaused();\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the contract is paused, and false otherwise.\n\t */\n\tfunction paused() public view virtual returns (bool) {\n\t\treturn _paused;\n\t}\n\n\t/**\n\t * @dev Throws if the contract is paused.\n\t */\n\tfunction _requireNotPaused() internal view virtual {\n\t\trequire(!paused(), \"Pausable: paused\");\n\t}\n\n\t/**\n\t * @dev Throws if the contract is not paused.\n\t */\n\tfunction _requirePaused() internal view virtual {\n\t\trequire(paused(), \"Pausable: not paused\");\n\t}\n\n\t/**\n\t * @dev Triggers stopped state.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must not be paused.\n\t */\n\tfunction _pause() internal virtual whenNotPaused {\n\t\t_paused = true;\n\t\temit Paused(_msgSender());\n\t}\n\n\t/**\n\t * @dev Returns to normal state.\n\t *\n\t * Requirements:\n\t *\n\t * - The contract must be paused.\n\t */\n\tfunction _unpause() internal virtual whenPaused {\n\t\t_paused = false;\n\t\temit Unpaused(_msgSender());\n\t}\n\n\t/**\n\t * @dev This empty reserved space is put in place to allow future versions to add new\n\t * variables without shifting down storage in the inheritance chain.\n\t * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/Proxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n\t/**\n\t * @dev Fallback function.\n\t * Implemented entirely in `_fallback`.\n\t */\n\tfallback() external payable {\n\t\t_fallback();\n\t}\n\n\t/**\n\t * @return The Address of the implementation.\n\t */\n\tfunction _implementation() internal view virtual returns (address);\n\n\t/**\n\t * @dev Delegates execution to an implementation contract.\n\t * This is a low level function that doesn't return to its internal call site.\n\t * It will return to the external caller whatever the implementation returns.\n\t * @param implementation Address to delegate.\n\t */\n\tfunction _delegate(address implementation) internal {\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\t// Copy msg.data. We take full control of memory in this inline assembly\n\t\t\t// block because it will not return to Solidity code. We overwrite the\n\t\t\t// Solidity scratch pad at memory position 0.\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\n\t\t\t// Call the implementation.\n\t\t\t// out and outsize are 0 because we don't know the size yet.\n\t\t\tlet result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n\t\t\t// Copy the returned data.\n\t\t\treturndatacopy(0, 0, returndatasize())\n\n\t\t\tswitch result\n\t\t\t// delegatecall returns 0 on error.\n\t\t\tcase 0 {\n\t\t\t\trevert(0, returndatasize())\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\treturn(0, returndatasize())\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Function that is run as the first thing in the fallback function.\n\t * Can be redefined in derived contracts to add functionality.\n\t * Redefinitions must call super._willFallback().\n\t */\n\tfunction _willFallback() internal virtual {}\n\n\t/**\n\t * @dev fallback implementation.\n\t * Extracted to enable manual triggering.\n\t */\n\tfunction _fallback() internal {\n\t\t_willFallback();\n\t\t_delegate(_implementation());\n\t}\n}\n"
    },
    "contracts/dependencies/openzeppelin/upgradeability/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n\t/**\n\t * @dev Contract constructor.\n\t * @param _logic Address of the initial implementation.\n\t * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n\t */\n\tconstructor(address _logic, bytes memory _data) payable {\n\t\tassert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n\t\t_setImplementation(_logic);\n\t\tif (_data.length > 0) {\n\t\t\t(bool success, ) = _logic.delegatecall(_data);\n\t\t\trequire(success);\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n\t// credit for this implementation goes to\n\t// https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n\tfunction sqrt(uint256 x) internal pure returns (uint256) {\n\t\tif (x == 0) return 0;\n\t\t// this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n\t\t// however that code costs significantly more gas\n\t\tuint256 xx = x;\n\t\tuint256 r = 1;\n\t\tif (xx >= 0x100000000000000000000000000000000) {\n\t\t\txx >>= 128;\n\t\t\tr <<= 64;\n\t\t}\n\t\tif (xx >= 0x10000000000000000) {\n\t\t\txx >>= 64;\n\t\t\tr <<= 32;\n\t\t}\n\t\tif (xx >= 0x100000000) {\n\t\t\txx >>= 32;\n\t\t\tr <<= 16;\n\t\t}\n\t\tif (xx >= 0x10000) {\n\t\t\txx >>= 16;\n\t\t\tr <<= 8;\n\t\t}\n\t\tif (xx >= 0x100) {\n\t\t\txx >>= 8;\n\t\t\tr <<= 4;\n\t\t}\n\t\tif (xx >= 0x10) {\n\t\t\txx >>= 4;\n\t\t\tr <<= 2;\n\t\t}\n\t\tif (xx >= 0x8) {\n\t\t\tr <<= 1;\n\t\t}\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1;\n\t\tr = (r + x / r) >> 1; // Seven iterations should be enough\n\t\tuint256 r1 = x / r;\n\t\treturn (r < r1 ? r : r1);\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nlibrary BitMath {\n\t// returns the 0 indexed position of the most significant bit of the input x\n\t// s.t. x >= 2**msb and x < 2**(msb+1)\n\tfunction mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n\t\trequire(x > 0, \"BitMath::mostSignificantBit: zero\");\n\n\t\tif (x >= 0x100000000000000000000000000000000) {\n\t\t\tx >>= 128;\n\t\t\tr += 128;\n\t\t}\n\t\tif (x >= 0x10000000000000000) {\n\t\t\tx >>= 64;\n\t\t\tr += 64;\n\t\t}\n\t\tif (x >= 0x100000000) {\n\t\t\tx >>= 32;\n\t\t\tr += 32;\n\t\t}\n\t\tif (x >= 0x10000) {\n\t\t\tx >>= 16;\n\t\t\tr += 16;\n\t\t}\n\t\tif (x >= 0x100) {\n\t\t\tx >>= 8;\n\t\t\tr += 8;\n\t\t}\n\t\tif (x >= 0x10) {\n\t\t\tx >>= 4;\n\t\t\tr += 4;\n\t\t}\n\t\tif (x >= 0x4) {\n\t\t\tx >>= 2;\n\t\t\tr += 2;\n\t\t}\n\t\tif (x >= 0x2) r += 1;\n\t}\n\n\t// returns the 0 indexed position of the least significant bit of the input x\n\t// s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n\t// i.e. the bit at the index is set and the mask of all lower bits is 0\n\tfunction leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n\t\trequire(x > 0, \"BitMath::leastSignificantBit: zero\");\n\n\t\tr = 255;\n\t\tif (x & type(uint128).max > 0) {\n\t\t\tr -= 128;\n\t\t} else {\n\t\t\tx >>= 128;\n\t\t}\n\t\tif (x & type(uint64).max > 0) {\n\t\t\tr -= 64;\n\t\t} else {\n\t\t\tx >>= 64;\n\t\t}\n\t\tif (x & type(uint32).max > 0) {\n\t\t\tr -= 32;\n\t\t} else {\n\t\t\tx >>= 32;\n\t\t}\n\t\tif (x & type(uint16).max > 0) {\n\t\t\tr -= 16;\n\t\t} else {\n\t\t\tx >>= 16;\n\t\t}\n\t\tif (x & type(uint8).max > 0) {\n\t\t\tr -= 8;\n\t\t} else {\n\t\t\tx >>= 8;\n\t\t}\n\t\tif (x & 0xf > 0) {\n\t\t\tr -= 4;\n\t\t} else {\n\t\t\tx >>= 4;\n\t\t}\n\t\tif (x & 0x3 > 0) {\n\t\t\tr -= 2;\n\t\t} else {\n\t\t\tx >>= 2;\n\t\t}\n\t\tif (x & 0x1 > 0) r -= 1;\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.12;\n\nimport \"./FullMath.sol\";\nimport \"./Babylonian.sol\";\nimport \"./BitMath.sol\";\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n\t// range: [0, 2**112 - 1]\n\t// resolution: 1 / 2**112\n\tstruct uq112x112 {\n\t\tuint224 _x;\n\t}\n\n\t// range: [0, 2**144 - 1]\n\t// resolution: 1 / 2**112\n\tstruct uq144x112 {\n\t\tuint256 _x;\n\t}\n\n\tuint8 public constant RESOLUTION = 112;\n\tuint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n\tuint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n\tuint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n\t// encode a uint112 as a UQ112x112\n\tfunction encode(uint112 x) internal pure returns (uq112x112 memory) {\n\t\treturn uq112x112(uint224(x) << RESOLUTION);\n\t}\n\n\t// encodes a uint144 as a UQ144x112\n\tfunction encode144(uint144 x) internal pure returns (uq144x112 memory) {\n\t\treturn uq144x112(uint256(x) << RESOLUTION);\n\t}\n\n\t// decode a UQ112x112 into a uint112 by truncating after the radix point\n\tfunction decode(uq112x112 memory self) internal pure returns (uint112) {\n\t\treturn uint112(self._x >> RESOLUTION);\n\t}\n\n\t// decode a UQ144x112 into a uint144 by truncating after the radix point\n\tfunction decode144(uq144x112 memory self) internal pure returns (uint144) {\n\t\treturn uint144(self._x >> RESOLUTION);\n\t}\n\n\t// multiply a UQ112x112 by a uint, returning a UQ144x112\n\t// reverts on overflow\n\tfunction mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n\t\tuint256 z = 0;\n\t\trequire(y == 0 || (z = self._x * y) / y == self._x, \"FixedPoint::mul: overflow\");\n\t\treturn uq144x112(z);\n\t}\n\n\t// multiply a UQ112x112 by an int and decode, returning an int\n\t// reverts on overflow\n\tfunction muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n\t\tuint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n\t\trequire(z < 2 ** 255, \"FixedPoint::muli: overflow\");\n\t\treturn y < 0 ? -int256(z) : int256(z);\n\t}\n\n\t// multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n\t// lossy\n\tfunction muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n\t\tif (self._x == 0 || other._x == 0) {\n\t\t\treturn uq112x112(0);\n\t\t}\n\t\tuint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n\t\tuint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n\t\tuint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n\t\tuint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n\t\t// partial products\n\t\tuint224 upper = uint224(upper_self) * upper_other; // * 2^0\n\t\tuint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n\t\tuint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n\t\tuint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n\t\t// so the bit shift does not overflow\n\t\trequire(upper <= type(uint112).max, \"FixedPoint::muluq: upper overflow\");\n\n\t\t// this cannot exceed 256 bits, all values are 224 bits\n\t\tuint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n\t\t// so the cast does not overflow\n\t\trequire(sum <= type(uint224).max, \"FixedPoint::muluq: sum overflow\");\n\n\t\treturn uq112x112(uint224(sum));\n\t}\n\n\t// divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n\tfunction divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n\t\trequire(other._x > 0, \"FixedPoint::divuq: division by zero\");\n\t\tif (self._x == other._x) {\n\t\t\treturn uq112x112(uint224(Q112));\n\t\t}\n\t\tif (self._x <= type(uint144).max) {\n\t\t\tuint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n\t\t\trequire(value <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n\t\t\treturn uq112x112(uint224(value));\n\t\t}\n\n\t\tuint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n\t\trequire(result <= type(uint224).max, \"FixedPoint::divuq: overflow\");\n\t\treturn uq112x112(uint224(result));\n\t}\n\n\t// returns a UQ112x112 which represents the ratio of the numerator to the denominator\n\t// can be lossy\n\tfunction fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n\t\trequire(denominator > 0, \"FixedPoint::fraction: division by zero\");\n\t\tif (numerator == 0) return FixedPoint.uq112x112(0);\n\n\t\tif (numerator <= type(uint144).max) {\n\t\t\tuint256 result = (numerator << RESOLUTION) / denominator;\n\t\t\trequire(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n\t\t\treturn uq112x112(uint224(result));\n\t\t} else {\n\t\t\tuint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n\t\t\trequire(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n\t\t\treturn uq112x112(uint224(result));\n\t\t}\n\t}\n\n\t// take the reciprocal of a UQ112x112\n\t// reverts on overflow\n\t// lossy\n\tfunction reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n\t\trequire(self._x != 0, \"FixedPoint::reciprocal: reciprocal of zero\");\n\t\trequire(self._x != 1, \"FixedPoint::reciprocal: overflow\");\n\t\treturn uq112x112(uint224(Q224 / self._x));\n\t}\n\n\t// square root of a UQ112x112\n\t// lossy between 0/1 and 40 bits\n\tfunction sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n\t\tif (self._x <= type(uint144).max) {\n\t\t\treturn uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n\t\t}\n\n\t\tuint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n\t\tsafeShiftBits -= safeShiftBits % 2;\n\t\treturn uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/FullMath.sol": {
      "content": "pragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n\t/// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\t/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n\tfunction mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\t// 512-bit multiply [prod1 prod0] = a * b\n\t\t// Compute the product mod 2**256 and mod 2**256 - 1\n\t\t// then use the Chinese Remainder Theorem to reconstruct\n\t\t// the 512 bit result. The result is stored in two 256\n\t\t// variables such that product = prod1 * 2**256 + prod0\n\t\tuint256 prod0; // Least significant 256 bits of the product\n\t\tuint256 prod1; // Most significant 256 bits of the product\n\t\tassembly {\n\t\t\tlet mm := mulmod(a, b, not(0))\n\t\t\tprod0 := mul(a, b)\n\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\n\t\t}\n\n\t\t// Handle non-overflow cases, 256 by 256 division\n\t\tif (prod1 == 0) {\n\t\t\trequire(denominator > 0);\n\t\t\tassembly {\n\t\t\t\tresult := div(prod0, denominator)\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t// Make sure the result is less than 2**256.\n\t\t// Also prevents denominator == 0\n\t\trequire(denominator > prod1);\n\n\t\t///////////////////////////////////////////////\n\t\t// 512 by 256 division.\n\t\t///////////////////////////////////////////////\n\n\t\t// Make division exact by subtracting the remainder from [prod1 prod0]\n\t\t// Compute remainder using mulmod\n\t\tuint256 remainder;\n\t\tassembly {\n\t\t\tremainder := mulmod(a, b, denominator)\n\t\t}\n\t\t// Subtract 256 bit number from 512 bit number\n\t\tassembly {\n\t\t\tprod1 := sub(prod1, gt(remainder, prod0))\n\t\t\tprod0 := sub(prod0, remainder)\n\t\t}\n\n\t\t// Factor powers of two out of denominator\n\t\t// Compute largest power of two divisor of denominator.\n\t\t// Always >= 1.\n\t\tuint256 twos = (type(uint256).max - denominator + 1) & denominator;\n\t\t// Divide denominator by power of two\n\t\tassembly {\n\t\t\tdenominator := div(denominator, twos)\n\t\t}\n\n\t\t// Divide [prod1 prod0] by the factors of two\n\t\tassembly {\n\t\t\tprod0 := div(prod0, twos)\n\t\t}\n\t\t// Shift in bits from prod1 into prod0. For this we need\n\t\t// to flip `twos` such that it is 2**256 / twos.\n\t\t// If twos is zero, then it becomes one\n\t\tassembly {\n\t\t\ttwos := add(div(sub(0, twos), twos), 1)\n\t\t}\n\t\tprod0 |= prod1 * twos;\n\n\t\t// Invert denominator mod 2**256\n\t\t// Now that denominator is an odd number, it has an inverse\n\t\t// modulo 2**256 such that denominator * inv = 1 mod 2**256.\n\t\t// Compute the inverse by starting with a seed that is correct\n\t\t// correct for four bits. That is, denominator * inv = 1 mod 2**4\n\t\tuint256 inv = (3 * denominator) ^ 2;\n\t\t// Now use Newton-Raphson iteration to improve the precision.\n\t\t// Thanks to Hensel's lifting lemma, this also works in modular\n\t\t// arithmetic, doubling the correct bits in each step.\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**8\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**16\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**32\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**64\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**128\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**256\n\n\t\t// Because the division is now exact we can divide by multiplying\n\t\t// with the modular inverse of denominator. This will give us the\n\t\t// correct result modulo 2**256. Since the precoditions guarantee\n\t\t// that the outcome is less than 2**256, this is the final result.\n\t\t// We don't need to compute the high bits of the result and prod1\n\t\t// is no longer required.\n\t\tresult = prod0 * inv;\n\t\treturn result;\n\t}\n\n\t/// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\tfunction mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tresult = mulDiv(a, b, denominator);\n\t\tif (mulmod(a, b, denominator) > 0) {\n\t\t\trequire(result < type(uint256).max);\n\t\t\tresult++;\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"./FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n\tusing FixedPoint for *;\n\n\t// helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n\tfunction currentBlockTimestamp() internal view returns (uint32) {\n\t\treturn uint32(block.timestamp % 2 ** 32);\n\t}\n\n\t// produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n\tfunction currentCumulativePrices(\n\t\taddress pair\n\t) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n\t\tblockTimestamp = currentBlockTimestamp();\n\t\tprice0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n\t\tprice1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n\t\t// if time has elapsed since the last update on the pair, mock the accumulated price values\n\t\t(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n\t\tif (blockTimestampLast != blockTimestamp) {\n\t\t\t// subtraction overflow is desired\n\t\t\tuint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\t\t\t// addition overflow is desired\n\t\t\t// counterfactual\n\t\t\tprice0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n\t\t\t// counterfactual\n\t\t\tprice1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/IUniswapV3Pool.sol": {
      "content": "pragma solidity >=0.6.11;\n\nimport \"./pool/IUniswapV3PoolImmutables.sol\";\nimport \"./pool/IUniswapV3PoolState.sol\";\nimport \"./pool/IUniswapV3PoolDerivedState.sol\";\nimport \"./pool/IUniswapV3PoolActions.sol\";\nimport \"./pool/IUniswapV3PoolOwnerActions.sol\";\nimport \"./pool/IUniswapV3PoolEvents.sol\";\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n\tIUniswapV3PoolImmutables,\n\tIUniswapV3PoolState,\n\tIUniswapV3PoolDerivedState,\n\tIUniswapV3PoolActions,\n\tIUniswapV3PoolOwnerActions,\n\tIUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/math/FullMath.sol": {
      "content": "pragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n\t/// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\t/// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n\tfunction mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\t// 512-bit multiply [prod1 prod0] = a * b\n\t\t// Compute the product mod 2**256 and mod 2**256 - 1\n\t\t// then use the Chinese Remainder Theorem to reconstruct\n\t\t// the 512 bit result. The result is stored in two 256\n\t\t// variables such that product = prod1 * 2**256 + prod0\n\t\tuint256 prod0; // Least significant 256 bits of the product\n\t\tuint256 prod1; // Most significant 256 bits of the product\n\t\tassembly {\n\t\t\tlet mm := mulmod(a, b, not(0))\n\t\t\tprod0 := mul(a, b)\n\t\t\tprod1 := sub(sub(mm, prod0), lt(mm, prod0))\n\t\t}\n\n\t\t// Handle non-overflow cases, 256 by 256 division\n\t\tif (prod1 == 0) {\n\t\t\trequire(denominator > 0);\n\t\t\tassembly {\n\t\t\t\tresult := div(prod0, denominator)\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t// Make sure the result is less than 2**256.\n\t\t// Also prevents denominator == 0\n\t\trequire(denominator > prod1);\n\n\t\t///////////////////////////////////////////////\n\t\t// 512 by 256 division.\n\t\t///////////////////////////////////////////////\n\n\t\t// Make division exact by subtracting the remainder from [prod1 prod0]\n\t\t// Compute remainder using mulmod\n\t\tuint256 remainder;\n\t\tassembly {\n\t\t\tremainder := mulmod(a, b, denominator)\n\t\t}\n\t\t// Subtract 256 bit number from 512 bit number\n\t\tassembly {\n\t\t\tprod1 := sub(prod1, gt(remainder, prod0))\n\t\t\tprod0 := sub(prod0, remainder)\n\t\t}\n\n\t\t// Factor powers of two out of denominator\n\t\t// Compute largest power of two divisor of denominator.\n\t\t// Always >= 1.\n\t\tuint256 twos = (type(uint256).max - denominator + 1) & denominator;\n\t\t// Divide denominator by power of two\n\t\tassembly {\n\t\t\tdenominator := div(denominator, twos)\n\t\t}\n\n\t\t// Divide [prod1 prod0] by the factors of two\n\t\tassembly {\n\t\t\tprod0 := div(prod0, twos)\n\t\t}\n\t\t// Shift in bits from prod1 into prod0. For this we need\n\t\t// to flip `twos` such that it is 2**256 / twos.\n\t\t// If twos is zero, then it becomes one\n\t\tassembly {\n\t\t\ttwos := add(div(sub(0, twos), twos), 1)\n\t\t}\n\t\tprod0 |= prod1 * twos;\n\n\t\t// Invert denominator mod 2**256\n\t\t// Now that denominator is an odd number, it has an inverse\n\t\t// modulo 2**256 such that denominator * inv = 1 mod 2**256.\n\t\t// Compute the inverse by starting with a seed that is correct\n\t\t// correct for four bits. That is, denominator * inv = 1 mod 2**4\n\t\tuint256 inv = (3 * denominator) ^ 2;\n\t\t// Now use Newton-Raphson iteration to improve the precision.\n\t\t// Thanks to Hensel's lifting lemma, this also works in modular\n\t\t// arithmetic, doubling the correct bits in each step.\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**8\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**16\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**32\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**64\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**128\n\t\tinv *= 2 - denominator * inv; // inverse mod 2**256\n\n\t\t// Because the division is now exact we can divide by multiplying\n\t\t// with the modular inverse of denominator. This will give us the\n\t\t// correct result modulo 2**256. Since the precoditions guarantee\n\t\t// that the outcome is less than 2**256, this is the final result.\n\t\t// We don't need to compute the high bits of the result and prod1\n\t\t// is no longer required.\n\t\tresult = prod0 * inv;\n\t\treturn result;\n\t}\n\n\t/// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n\t/// @param a The multiplicand\n\t/// @param b The multiplier\n\t/// @param denominator The divisor\n\t/// @return result The 256-bit result\n\tfunction mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n\t\tresult = mulDiv(a, b, denominator);\n\t\tif (mulmod(a, b, denominator) > 0) {\n\t\t\trequire(result < type(uint256).max);\n\t\t\tresult++;\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/math/SafeMath.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t * - Subtraction cannot overflow.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t * - The divisor cannot be zero.\n\t *\n\t * _Available since v2.4.0._\n\t */\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/math/TickMath.sol": {
      "content": "pragma solidity >=0.5.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n\t/// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n\tint24 internal constant MIN_TICK = -887272;\n\t/// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n\tint24 internal constant MAX_TICK = -MIN_TICK;\n\n\t/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n\tuint160 internal constant MIN_SQRT_RATIO = 4295128739;\n\t/// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n\tuint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n\t/// @notice Calculates sqrt(1.0001^tick) * 2^96\n\t/// @dev Throws if |tick| > max tick\n\t/// @param tick The input tick for the above formula\n\t/// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n\t/// at the given tick\n\tfunction getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n\t\tuint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n\t\trequire(int256(absTick) <= int256(MAX_TICK), \"T\");\n\n\t\tuint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n\t\tif (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n\t\tif (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n\t\tif (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n\t\tif (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n\t\tif (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n\t\tif (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n\t\tif (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n\t\tif (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n\t\tif (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n\t\tif (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n\t\tif (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n\t\tif (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n\t\tif (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n\t\tif (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n\t\tif (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n\t\tif (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n\t\tif (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n\t\tif (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n\t\tif (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n\t\tif (tick > 0) ratio = type(uint256).max / ratio;\n\n\t\t// this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n\t\t// we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n\t\t// we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n\t\tsqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n\t}\n\n\t/// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n\t/// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n\t/// ever return.\n\t/// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n\t/// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n\tfunction getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n\t\t// second inequality must be < because the price can never reach the price at the max tick\n\t\trequire(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \"R\");\n\t\tuint256 ratio = uint256(sqrtPriceX96) << 32;\n\n\t\tuint256 r = ratio;\n\t\tuint256 msb = 0;\n\n\t\tassembly {\n\t\t\tlet f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n\t\t\tmsb := or(msb, f)\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tlet f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n\t\t\tmsb := or(msb, f)\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tlet f := shl(5, gt(r, 0xFFFFFFFF))\n\t\t\tmsb := or(msb, f)\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tlet f := shl(4, gt(r, 0xFFFF))\n\t\t\tmsb := or(msb, f)\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tlet f := shl(3, gt(r, 0xFF))\n\t\t\tmsb := or(msb, f)\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tlet f := shl(2, gt(r, 0xF))\n\t\t\tmsb := or(msb, f)\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tlet f := shl(1, gt(r, 0x3))\n\t\t\tmsb := or(msb, f)\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tlet f := gt(r, 0x1)\n\t\t\tmsb := or(msb, f)\n\t\t}\n\n\t\tif (msb >= 128) r = ratio >> (msb - 127);\n\t\telse r = ratio << (127 - msb);\n\n\t\tint256 log_2 = (int256(msb) - 128) << 64;\n\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(63, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(62, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(61, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(60, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(59, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(58, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(57, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(56, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(55, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(54, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(53, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(52, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(51, f))\n\t\t\tr := shr(f, r)\n\t\t}\n\t\tassembly {\n\t\t\tr := shr(127, mul(r, r))\n\t\t\tlet f := shr(128, r)\n\t\t\tlog_2 := or(log_2, shl(50, f))\n\t\t}\n\n\t\tint256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n\t\tint24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n\t\tint24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n\t\ttick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/OracleLibrary.sol": {
      "content": "pragma solidity >=0.6.12;\n\nimport \"./math/FullMath.sol\";\nimport \"./math/TickMath.sol\";\nimport \"./IUniswapV3Pool.sol\";\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n\t/// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n\t/// @param pool Address of the pool that we want to observe\n\t/// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n\t/// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n\t/// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n\tfunction consult(\n\t\taddress pool,\n\t\tuint32 secondsAgo\n\t) internal view returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity) {\n\t\trequire(secondsAgo != 0, \"BP\");\n\n\t\tuint32[] memory secondsAgos = new uint32[](2);\n\t\tsecondsAgos[0] = secondsAgo;\n\t\tsecondsAgos[1] = 0;\n\n\t\t(int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = IUniswapV3Pool(pool)\n\t\t\t.observe(secondsAgos);\n\n\t\tint56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n\t\tuint160 secondsPerLiquidityCumulativesDelta = secondsPerLiquidityCumulativeX128s[1] -\n\t\t\tsecondsPerLiquidityCumulativeX128s[0];\n\n\t\tarithmeticMeanTick = int24(tickCumulativesDelta / int32(secondsAgo));\n\t\t// Always round to negative infinity\n\t\tif (tickCumulativesDelta < 0 && (tickCumulativesDelta % int32(secondsAgo) != 0)) arithmeticMeanTick--;\n\n\t\t// We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n\t\tuint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n\t\tharmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n\t}\n\n\t/// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n\t/// @param tick Tick value used to calculate the quote\n\t/// @param baseAmount Amount of token to be converted\n\t/// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n\t/// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n\t/// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n\tfunction getQuoteAtTick(\n\t\tint24 tick,\n\t\tuint128 baseAmount,\n\t\taddress baseToken,\n\t\taddress quoteToken\n\t) internal pure returns (uint256 quoteAmount) {\n\t\tuint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n\t\t// Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n\t\tif (sqrtRatioX96 <= type(uint128).max) {\n\t\t\tuint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n\t\t\tquoteAmount = baseToken < quoteToken\n\t\t\t\t? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n\t\t\t\t: FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n\t\t} else {\n\t\t\tuint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n\t\t\tquoteAmount = baseToken < quoteToken\n\t\t\t\t? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n\t\t\t\t: FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n\t\t}\n\t}\n\n\t/// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n\t/// @param pool Address of Uniswap V3 pool that we want to observe\n\t/// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n\tfunction getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n\t\t(, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\t\trequire(observationCardinality > 0, \"NI\");\n\n\t\t(uint32 observationTimestamp, , , bool initialized) = IUniswapV3Pool(pool).observations(\n\t\t\t(observationIndex + 1) % observationCardinality\n\t\t);\n\n\t\t// The next index might not be initialized if the cardinality is in the process of increasing\n\t\t// In this case the oldest observation is always in index 0\n\t\tif (!initialized) {\n\t\t\t(observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n\t\t}\n\n\t\tsecondsAgo = uint32(block.timestamp) - observationTimestamp;\n\t}\n\n\t/// @notice Given a pool, it returns the tick value as of the start of the current block\n\t/// @param pool Address of Uniswap V3 pool\n\t/// @return The tick that the pool was in at the start of the current block\n\tfunction getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n\t\t(, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n\t\t// 2 observations are needed to reliably calculate the block starting tick\n\t\trequire(observationCardinality > 1, \"NEO\");\n\n\t\t// If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n\t\t// therefore the tick in `slot0` is the same as at the beginning of the current block.\n\t\t// We don't need to check if this observation is initialized - it is guaranteed to be.\n\t\t(\n\t\t\tuint32 observationTimestamp,\n\t\t\tint56 tickCumulative,\n\t\t\tuint160 secondsPerLiquidityCumulativeX128,\n\n\t\t) = IUniswapV3Pool(pool).observations(observationIndex);\n\t\tif (observationTimestamp != uint32(block.timestamp)) {\n\t\t\treturn (tick, IUniswapV3Pool(pool).liquidity());\n\t\t}\n\n\t\tuint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n\t\t(\n\t\t\tuint32 prevObservationTimestamp,\n\t\t\tint56 prevTickCumulative,\n\t\t\tuint160 prevSecondsPerLiquidityCumulativeX128,\n\t\t\tbool prevInitialized\n\t\t) = IUniswapV3Pool(pool).observations(prevIndex);\n\n\t\trequire(prevInitialized, \"ONI\");\n\n\t\tuint32 delta = observationTimestamp - prevObservationTimestamp;\n\t\ttick = int24((tickCumulative - prevTickCumulative) / int56(int32(delta)));\n\t\tuint128 liquidity = uint128(\n\t\t\t(uint192(delta) * type(uint160).max) /\n\t\t\t\t(uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n\t\t);\n\t\treturn (tick, liquidity);\n\t}\n\n\t/// @notice Information for calculating a weighted arithmetic mean tick\n\tstruct WeightedTickData {\n\t\tint24 tick;\n\t\tuint128 weight;\n\t}\n\n\t/// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n\t/// @param weightedTickData An array of ticks and weights\n\t/// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n\t/// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n\t/// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n\t/// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n\tfunction getWeightedArithmeticMeanTick(\n\t\tWeightedTickData[] memory weightedTickData\n\t) internal pure returns (int24 weightedArithmeticMeanTick) {\n\t\t// Accumulates the sum of products between each tick and its weight\n\t\tint256 numerator;\n\n\t\t// Accumulates the sum of the weights\n\t\tuint256 denominator;\n\n\t\t// Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n\t\tfor (uint256 i; i < weightedTickData.length; i++) {\n\t\t\tnumerator += weightedTickData[i].tick * int256(int128(weightedTickData[i].weight));\n\t\t\tdenominator += weightedTickData[i].weight;\n\t\t}\n\n\t\tweightedArithmeticMeanTick = int24(numerator / int256(denominator));\n\t\t// Always round to negative infinity\n\t\tif (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n\t}\n\n\t/// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n\t/// @dev Useful for calculating relative prices along routes.\n\t/// @dev There must be one tick for each pairwise set of tokens.\n\t/// @param tokens The token contract addresses\n\t/// @param ticks The ticks, representing the price of each token pair in `tokens`\n\t/// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n\tfunction getChainedPrice(\n\t\taddress[] memory tokens,\n\t\tint24[] memory ticks\n\t) internal pure returns (int256 syntheticTick) {\n\t\trequire(tokens.length - 1 == ticks.length, \"DL\");\n\t\tfor (uint256 i = 1; i <= ticks.length; i++) {\n\t\t\t// check the tokens for address sort order, then accumulate the\n\t\t\t// ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n\t\t\ttokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n\t\t}\n\t}\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/AggregatorV3Interface.sol": {
      "content": "pragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\tfunction decimals() external view returns (uint8);\n\n\tfunction description() external view returns (string memory);\n\n\tfunction version() external view returns (uint256);\n\n\t// getRoundData and latestRoundData should both raise \"No data present\"\n\t// if they do not have data to report, instead of returning unset values\n\t// which could be misinterpreted as actual reported values.\n\tfunction getRoundData(\n\t\tuint80 _roundId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n\tfunction latestRoundData()\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolActions.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n\t/// @notice Sets the initial price for the pool\n\t/// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n\t/// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n\tfunction initialize(uint160 sqrtPriceX96) external;\n\n\t/// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n\t/// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n\t/// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n\t/// on tickLower, tickUpper, the amount of liquidity, and the current price.\n\t/// @param recipient The address for which the liquidity will be created\n\t/// @param tickLower The lower tick of the position in which to add liquidity\n\t/// @param tickUpper The upper tick of the position in which to add liquidity\n\t/// @param amount The amount of liquidity to mint\n\t/// @param data Any data that should be passed through to the callback\n\t/// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n\t/// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n\tfunction mint(\n\t\taddress recipient,\n\t\tint24 tickLower,\n\t\tint24 tickUpper,\n\t\tuint128 amount,\n\t\tbytes calldata data\n\t) external returns (uint256 amount0, uint256 amount1);\n\n\t/// @notice Collects tokens owed to a position\n\t/// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n\t/// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n\t/// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n\t/// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n\t/// @param recipient The address which should receive the fees collected\n\t/// @param tickLower The lower tick of the position for which to collect fees\n\t/// @param tickUpper The upper tick of the position for which to collect fees\n\t/// @param amount0Requested How much token0 should be withdrawn from the fees owed\n\t/// @param amount1Requested How much token1 should be withdrawn from the fees owed\n\t/// @return amount0 The amount of fees collected in token0\n\t/// @return amount1 The amount of fees collected in token1\n\tfunction collect(\n\t\taddress recipient,\n\t\tint24 tickLower,\n\t\tint24 tickUpper,\n\t\tuint128 amount0Requested,\n\t\tuint128 amount1Requested\n\t) external returns (uint128 amount0, uint128 amount1);\n\n\t/// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n\t/// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n\t/// @dev Fees must be collected separately via a call to #collect\n\t/// @param tickLower The lower tick of the position for which to burn liquidity\n\t/// @param tickUpper The upper tick of the position for which to burn liquidity\n\t/// @param amount How much liquidity to burn\n\t/// @return amount0 The amount of token0 sent to the recipient\n\t/// @return amount1 The amount of token1 sent to the recipient\n\tfunction burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256 amount0, uint256 amount1);\n\n\t/// @notice Swap token0 for token1, or token1 for token0\n\t/// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n\t/// @param recipient The address to receive the output of the swap\n\t/// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n\t/// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n\t/// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n\t/// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n\t/// @param data Any data to be passed through to the callback\n\t/// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n\t/// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n\tfunction swap(\n\t\taddress recipient,\n\t\tbool zeroForOne,\n\t\tint256 amountSpecified,\n\t\tuint160 sqrtPriceLimitX96,\n\t\tbytes calldata data\n\t) external returns (int256 amount0, int256 amount1);\n\n\t/// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n\t/// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n\t/// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n\t/// with 0 amount{0,1} and sending the donation amount(s) from the callback\n\t/// @param recipient The address which will receive the token0 and token1 amounts\n\t/// @param amount0 The amount of token0 to send\n\t/// @param amount1 The amount of token1 to send\n\t/// @param data Any data to be passed through to the callback\n\tfunction flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external;\n\n\t/// @notice Increase the maximum number of price and liquidity observations that this pool will store\n\t/// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n\t/// the input observationCardinalityNext.\n\t/// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n\tfunction increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n\t/// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n\t/// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n\t/// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n\t/// you must call it with secondsAgos = [3600, 0].\n\t/// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n\t/// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n\t/// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n\t/// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n\t/// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n\t/// timestamp\n\tfunction observe(\n\t\tuint32[] calldata secondsAgos\n\t) external view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n\t/// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n\t/// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n\t/// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n\t/// snapshot is taken and the second snapshot is taken.\n\t/// @param tickLower The lower tick of the range\n\t/// @param tickUpper The upper tick of the range\n\t/// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n\t/// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n\t/// @return secondsInside The snapshot of seconds per liquidity for the range\n\tfunction snapshotCumulativesInside(\n\t\tint24 tickLower,\n\t\tint24 tickUpper\n\t) external view returns (int56 tickCumulativeInside, uint160 secondsPerLiquidityInsideX128, uint32 secondsInside);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolEvents.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n\t/// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n\t/// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n\t/// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n\t/// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n\tevent Initialize(uint160 sqrtPriceX96, int24 tick);\n\n\t/// @notice Emitted when liquidity is minted for a given position\n\t/// @param sender The address that minted the liquidity\n\t/// @param owner The owner of the position and recipient of any minted liquidity\n\t/// @param tickLower The lower tick of the position\n\t/// @param tickUpper The upper tick of the position\n\t/// @param amount The amount of liquidity minted to the position range\n\t/// @param amount0 How much token0 was required for the minted liquidity\n\t/// @param amount1 How much token1 was required for the minted liquidity\n\tevent Mint(\n\t\taddress sender,\n\t\taddress indexed owner,\n\t\tint24 indexed tickLower,\n\t\tint24 indexed tickUpper,\n\t\tuint128 amount,\n\t\tuint256 amount0,\n\t\tuint256 amount1\n\t);\n\n\t/// @notice Emitted when fees are collected by the owner of a position\n\t/// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n\t/// @param owner The owner of the position for which fees are collected\n\t/// @param tickLower The lower tick of the position\n\t/// @param tickUpper The upper tick of the position\n\t/// @param amount0 The amount of token0 fees collected\n\t/// @param amount1 The amount of token1 fees collected\n\tevent Collect(\n\t\taddress indexed owner,\n\t\taddress recipient,\n\t\tint24 indexed tickLower,\n\t\tint24 indexed tickUpper,\n\t\tuint128 amount0,\n\t\tuint128 amount1\n\t);\n\n\t/// @notice Emitted when a position's liquidity is removed\n\t/// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n\t/// @param owner The owner of the position for which liquidity is removed\n\t/// @param tickLower The lower tick of the position\n\t/// @param tickUpper The upper tick of the position\n\t/// @param amount The amount of liquidity to remove\n\t/// @param amount0 The amount of token0 withdrawn\n\t/// @param amount1 The amount of token1 withdrawn\n\tevent Burn(\n\t\taddress indexed owner,\n\t\tint24 indexed tickLower,\n\t\tint24 indexed tickUpper,\n\t\tuint128 amount,\n\t\tuint256 amount0,\n\t\tuint256 amount1\n\t);\n\n\t/// @notice Emitted by the pool for any swaps between token0 and token1\n\t/// @param sender The address that initiated the swap call, and that received the callback\n\t/// @param recipient The address that received the output of the swap\n\t/// @param amount0 The delta of the token0 balance of the pool\n\t/// @param amount1 The delta of the token1 balance of the pool\n\t/// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n\t/// @param liquidity The liquidity of the pool after the swap\n\t/// @param tick The log base 1.0001 of price of the pool after the swap\n\tevent Swap(\n\t\taddress indexed sender,\n\t\taddress indexed recipient,\n\t\tint256 amount0,\n\t\tint256 amount1,\n\t\tuint160 sqrtPriceX96,\n\t\tuint128 liquidity,\n\t\tint24 tick\n\t);\n\n\t/// @notice Emitted by the pool for any flashes of token0/token1\n\t/// @param sender The address that initiated the swap call, and that received the callback\n\t/// @param recipient The address that received the tokens from flash\n\t/// @param amount0 The amount of token0 that was flashed\n\t/// @param amount1 The amount of token1 that was flashed\n\t/// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n\t/// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n\tevent Flash(\n\t\taddress indexed sender,\n\t\taddress indexed recipient,\n\t\tuint256 amount0,\n\t\tuint256 amount1,\n\t\tuint256 paid0,\n\t\tuint256 paid1\n\t);\n\n\t/// @notice Emitted by the pool for increases to the number of observations that can be stored\n\t/// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n\t/// just before a mint/swap/burn.\n\t/// @param observationCardinalityNextOld The previous value of the next observation cardinality\n\t/// @param observationCardinalityNextNew The updated value of the next observation cardinality\n\tevent IncreaseObservationCardinalityNext(\n\t\tuint16 observationCardinalityNextOld,\n\t\tuint16 observationCardinalityNextNew\n\t);\n\n\t/// @notice Emitted when the protocol fee is changed by the pool\n\t/// @param feeProtocol0Old The previous value of the token0 protocol fee\n\t/// @param feeProtocol1Old The previous value of the token1 protocol fee\n\t/// @param feeProtocol0New The updated value of the token0 protocol fee\n\t/// @param feeProtocol1New The updated value of the token1 protocol fee\n\tevent SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n\t/// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n\t/// @param sender The address that collects the protocol fees\n\t/// @param recipient The address that receives the collected protocol fees\n\t/// @param amount0 The amount of token0 protocol fees that is withdrawn\n\t/// @param amount0 The amount of token1 protocol fees that is withdrawn\n\tevent CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolImmutables.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n\t/// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n\t/// @return The contract address\n\tfunction factory() external view returns (address);\n\n\t/// @notice The first of the two tokens of the pool, sorted by address\n\t/// @return The token contract address\n\tfunction token0() external view returns (address);\n\n\t/// @notice The second of the two tokens of the pool, sorted by address\n\t/// @return The token contract address\n\tfunction token1() external view returns (address);\n\n\t/// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n\t/// @return The fee\n\tfunction fee() external view returns (uint24);\n\n\t/// @notice The pool tick spacing\n\t/// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n\t/// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n\t/// This value is an int24 to avoid casting even though it is always positive.\n\t/// @return The tick spacing\n\tfunction tickSpacing() external view returns (int24);\n\n\t/// @notice The maximum amount of position liquidity that can use any tick in the range\n\t/// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n\t/// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n\t/// @return The max amount of liquidity per tick\n\tfunction maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "pragma solidity >=0.6.11;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n\t/// @notice Set the denominator of the protocol's % share of the fees\n\t/// @param feeProtocol0 new protocol fee for token0 of the pool\n\t/// @param feeProtocol1 new protocol fee for token1 of the pool\n\tfunction setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n\t/// @notice Collect the protocol fee accrued to the pool\n\t/// @param recipient The address to which collected protocol fees should be sent\n\t/// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n\t/// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n\t/// @return amount0 The protocol fee collected in token0\n\t/// @return amount1 The protocol fee collected in token1\n\tfunction collectProtocol(\n\t\taddress recipient,\n\t\tuint128 amount0Requested,\n\t\tuint128 amount1Requested\n\t) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/dependencies/uniswap/contracts/v3/pool/IUniswapV3PoolState.sol": {
      "content": "pragma solidity >=0.6.11;\n\n\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n\t/// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n\t/// when accessed externally.\n\t/// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n\t/// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n\t/// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n\t/// boundary.\n\t/// observationIndex The index of the last oracle observation that was written,\n\t/// observationCardinality The current maximum number of observations stored in the pool,\n\t/// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n\t/// feeProtocol The protocol fee for both tokens of the pool.\n\t/// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n\t/// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n\t/// unlocked Whether the pool is currently locked to reentrancy\n\tfunction slot0()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint160 sqrtPriceX96,\n\t\t\tint24 tick,\n\t\t\tuint16 observationIndex,\n\t\t\tuint16 observationCardinality,\n\t\t\tuint16 observationCardinalityNext,\n\t\t\tuint8 feeProtocol,\n\t\t\tbool unlocked\n\t\t);\n\n\t/// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n\t/// @dev This value can overflow the uint256\n\tfunction feeGrowthGlobal0X128() external view returns (uint256);\n\n\t/// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n\t/// @dev This value can overflow the uint256\n\tfunction feeGrowthGlobal1X128() external view returns (uint256);\n\n\t/// @notice The amounts of token0 and token1 that are owed to the protocol\n\t/// @dev Protocol fees will never exceed uint128 max in either token\n\tfunction protocolFees() external view returns (uint128 token0, uint128 token1);\n\n\t/// @notice The currently in range liquidity available to the pool\n\t/// @dev This value has no relationship to the total liquidity across all ticks\n\tfunction liquidity() external view returns (uint128);\n\n\t/// @notice Look up information about a specific tick in the pool\n\t/// @param tick The tick to look up\n\t/// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n\t/// tick upper,\n\t/// liquidityNet how much liquidity changes when the pool price crosses the tick,\n\t/// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n\t/// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n\t/// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n\t/// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n\t/// secondsOutside the seconds spent on the other side of the tick from the current tick,\n\t/// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n\t/// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n\t/// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n\t/// a specific position.\n\tfunction ticks(\n\t\tint24 tick\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint128 liquidityGross,\n\t\t\tint128 liquidityNet,\n\t\t\tuint256 feeGrowthOutside0X128,\n\t\t\tuint256 feeGrowthOutside1X128,\n\t\t\tint56 tickCumulativeOutside,\n\t\t\tuint160 secondsPerLiquidityOutsideX128,\n\t\t\tuint32 secondsOutside,\n\t\t\tbool initialized\n\t\t);\n\n\t/// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n\tfunction tickBitmap(int16 wordPosition) external view returns (uint256);\n\n\t/// @notice Returns the information about a position by the position's key\n\t/// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n\t/// @return _liquidity The amount of liquidity in the position,\n\t/// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n\t/// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n\t/// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n\t/// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n\tfunction positions(\n\t\tbytes32 key\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint128 _liquidity,\n\t\t\tuint256 feeGrowthInside0LastX128,\n\t\t\tuint256 feeGrowthInside1LastX128,\n\t\t\tuint128 tokensOwed0,\n\t\t\tuint128 tokensOwed1\n\t\t);\n\n\t/// @notice Returns data about a specific observation index\n\t/// @param index The element of the observations array to fetch\n\t/// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n\t/// ago, rather than at a specific index in the array.\n\t/// @return blockTimestamp The timestamp of the observation,\n\t/// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n\t/// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n\t/// Returns initialized whether the observation has been initialized and the values are safe to use\n\tfunction observations(\n\t\tuint256 index\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint32 blockTimestamp,\n\t\t\tint56 tickCumulative,\n\t\t\tuint160 secondsPerLiquidityCumulativeX128,\n\t\t\tbool initialized\n\t\t);\n}\n"
    },
    "contracts/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface AggregatorInterface {\n\tfunction latestAnswer() external view returns (int256);\n\n\tfunction latestTimestamp() external view returns (uint256);\n\n\tfunction latestRound() external view returns (uint256);\n\n\tfunction getAnswer(uint256 roundId) external view returns (int256);\n\n\tfunction getTimestamp(uint256 roundId) external view returns (uint256);\n\n\tevent AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n\tevent NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "contracts/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface AggregatorV3Interface {\n\tfunction decimals() external view returns (uint8);\n\n\tfunction description() external view returns (string memory);\n\n\tfunction version() external view returns (uint256);\n\n\t// getRoundData and latestRoundData should both raise \"No data present\"\n\t// if they do not have data to report, instead of returning unset values\n\t// which could be misinterpreted as actual reported values.\n\tfunction getRoundData(\n\t\tuint80 _roundId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n\tfunction latestRoundData()\n\t\texternal\n\t\tview\n\t\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/interfaces/balancer/IWeightedPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma abicoder v2;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBasePool is IERC20 {\n\tfunction getSwapFeePercentage() external view returns (uint256);\n\n\tfunction setSwapFeePercentage(uint256 swapFeePercentage) external;\n\n\tfunction setAssetManagerPoolConfig(IERC20 token, IAssetManager.PoolConfig memory poolConfig) external;\n\n\tfunction setPaused(bool paused) external;\n\n\tfunction getVault() external view returns (IVault);\n\n\tfunction getPoolId() external view returns (bytes32);\n\n\tfunction getOwner() external view returns (address);\n}\n\ninterface IWeightedPoolFactory {\n\tfunction create(\n\t\tstring memory name,\n\t\tstring memory symbol,\n\t\tIERC20[] memory tokens,\n\t\tuint256[] memory weights,\n\t\taddress[] memory rateProviders,\n\t\tuint256 swapFeePercentage,\n\t\taddress owner\n\t) external returns (address);\n}\n\ninterface IWeightedPool is IBasePool {\n\tfunction getSwapEnabled() external view returns (bool);\n\n\tfunction getNormalizedWeights() external view returns (uint256[] memory);\n\n\tfunction getGradualWeightUpdateParams()\n\t\texternal\n\t\tview\n\t\treturns (uint256 startTime, uint256 endTime, uint256[] memory endWeights);\n\n\tfunction setSwapEnabled(bool swapEnabled) external;\n\n\tfunction updateWeightsGradually(uint256 startTime, uint256 endTime, uint256[] memory endWeights) external;\n\n\tfunction withdrawCollectedManagementFees(address recipient) external;\n\n\tenum JoinKind {\n\t\tINIT,\n\t\tEXACT_TOKENS_IN_FOR_BPT_OUT,\n\t\tTOKEN_IN_FOR_EXACT_BPT_OUT\n\t}\n\tenum ExitKind {\n\t\tEXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n\t\tEXACT_BPT_IN_FOR_TOKENS_OUT,\n\t\tBPT_IN_FOR_EXACT_TOKENS_OUT\n\t}\n}\n\ninterface IAssetManager {\n\tstruct PoolConfig {\n\t\tuint64 targetPercentage;\n\t\tuint64 criticalPercentage;\n\t\tuint64 feePercentage;\n\t}\n\n\tfunction setPoolConfig(bytes32 poolId, PoolConfig calldata config) external;\n}\n\ninterface IAsset {}\n\ninterface IVault {\n\tfunction hasApprovedRelayer(address user, address relayer) external view returns (bool);\n\n\tfunction setRelayerApproval(address sender, address relayer, bool approved) external;\n\n\tevent RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\n\n\tfunction getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\n\n\tfunction manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n\tstruct UserBalanceOp {\n\t\tUserBalanceOpKind kind;\n\t\tIAsset asset;\n\t\tuint256 amount;\n\t\taddress sender;\n\t\taddress payable recipient;\n\t}\n\n\tenum UserBalanceOpKind {\n\t\tDEPOSIT_INTERNAL,\n\t\tWITHDRAW_INTERNAL,\n\t\tTRANSFER_INTERNAL,\n\t\tTRANSFER_EXTERNAL\n\t}\n\tevent InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\tevent ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n\tenum PoolSpecialization {\n\t\tGENERAL,\n\t\tMINIMAL_SWAP_INFO,\n\t\tTWO_TOKEN\n\t}\n\n\tfunction registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n\tevent PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n\tfunction getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n\tfunction registerTokens(bytes32 poolId, IERC20[] memory tokens, address[] memory assetManagers) external;\n\n\tevent TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n\tfunction deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\n\n\tevent TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n\tfunction getPoolTokenInfo(\n\t\tbytes32 poolId,\n\t\tIERC20 token\n\t) external view returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);\n\n\tfunction getPoolTokens(\n\t\tbytes32 poolId\n\t) external view returns (IERC20[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\n\n\tfunction joinPool(\n\t\tbytes32 poolId,\n\t\taddress sender,\n\t\taddress recipient,\n\t\tJoinPoolRequest memory request\n\t) external payable;\n\n\tstruct JoinPoolRequest {\n\t\tIAsset[] assets;\n\t\tuint256[] maxAmountsIn;\n\t\tbytes userData;\n\t\tbool fromInternalBalance;\n\t}\n\n\tfunction exitPool(\n\t\tbytes32 poolId,\n\t\taddress sender,\n\t\taddress payable recipient,\n\t\tExitPoolRequest memory request\n\t) external;\n\n\tstruct ExitPoolRequest {\n\t\tIAsset[] assets;\n\t\tuint256[] minAmountsOut;\n\t\tbytes userData;\n\t\tbool toInternalBalance;\n\t}\n\n\tevent PoolBalanceChanged(\n\t\tbytes32 indexed poolId,\n\t\taddress indexed liquidityProvider,\n\t\tIERC20[] tokens,\n\t\tint256[] deltas,\n\t\tuint256[] protocolFeeAmounts\n\t);\n\n\tenum PoolBalanceChangeKind {\n\t\tJOIN,\n\t\tEXIT\n\t}\n\n\tenum SwapKind {\n\t\tGIVEN_IN,\n\t\tGIVEN_OUT\n\t}\n\n\tfunction swap(\n\t\tSingleSwap memory singleSwap,\n\t\tFundManagement memory funds,\n\t\tuint256 limit,\n\t\tuint256 deadline\n\t) external payable returns (uint256);\n\n\tstruct SingleSwap {\n\t\tbytes32 poolId;\n\t\tSwapKind kind;\n\t\tIAsset assetIn;\n\t\tIAsset assetOut;\n\t\tuint256 amount;\n\t\tbytes userData;\n\t}\n\n\tfunction batchSwap(\n\t\tSwapKind kind,\n\t\tBatchSwapStep[] memory swaps,\n\t\tIAsset[] memory assets,\n\t\tFundManagement memory funds,\n\t\tint256[] memory limits,\n\t\tuint256 deadline\n\t) external payable returns (int256[] memory);\n\n\tstruct BatchSwapStep {\n\t\tbytes32 poolId;\n\t\tuint256 assetInIndex;\n\t\tuint256 assetOutIndex;\n\t\tuint256 amount;\n\t\tbytes userData;\n\t}\n\n\tevent Swap(\n\t\tbytes32 indexed poolId,\n\t\tIERC20 indexed tokenIn,\n\t\tIERC20 indexed tokenOut,\n\t\tuint256 amountIn,\n\t\tuint256 amountOut\n\t);\n\tstruct FundManagement {\n\t\taddress sender;\n\t\tbool fromInternalBalance;\n\t\taddress payable recipient;\n\t\tbool toInternalBalance;\n\t}\n\n\tfunction queryBatchSwap(\n\t\tSwapKind kind,\n\t\tBatchSwapStep[] memory swaps,\n\t\tIAsset[] memory assets,\n\t\tFundManagement memory funds\n\t) external returns (int256[] memory assetDeltas);\n\n\tfunction managePoolBalance(PoolBalanceOp[] memory ops) external;\n\n\tstruct PoolBalanceOp {\n\t\tPoolBalanceOpKind kind;\n\t\tbytes32 poolId;\n\t\tIERC20 token;\n\t\tuint256 amount;\n\t}\n\n\tenum PoolBalanceOpKind {\n\t\tWITHDRAW,\n\t\tDEPOSIT,\n\t\tUPDATE\n\t}\n\tevent PoolBalanceManaged(\n\t\tbytes32 indexed poolId,\n\t\taddress indexed assetManager,\n\t\tIERC20 indexed token,\n\t\tint256 cashDelta,\n\t\tint256 managedDelta\n\t);\n\n\tfunction setPaused(bool paused) external;\n}\n"
    },
    "contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface IAaveIncentivesController {\n\tevent RewardsAccrued(address indexed user, uint256 amount);\n\n\tevent RewardsClaimed(address indexed user, address indexed to, uint256 amount);\n\n\tevent RewardsClaimed(address indexed user, address indexed to, address indexed claimer, uint256 amount);\n\n\tevent ClaimerSet(address indexed user, address indexed claimer);\n\n\t/*\n\t * @dev Returns the configuration of the distribution for a certain asset\n\t * @param asset The address of the reference asset of the distribution\n\t * @return The asset index, the emission per second and the last updated timestamp\n\t **/\n\tfunction getAssetData(address asset) external view returns (uint256, uint256, uint256);\n\n\t/**\n\t * @dev Whitelists an address to claim the rewards on behalf of another address\n\t * @param user The address of the user\n\t * @param claimer The address of the claimer\n\t */\n\tfunction setClaimer(address user, address claimer) external;\n\n\t/**\n\t * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n\t * @param user The address of the user\n\t * @return The claimer address\n\t */\n\tfunction getClaimer(address user) external view returns (address);\n\n\t/**\n\t * @dev Configure assets for a certain rewards emission\n\t * @param assets The assets to incentivize\n\t * @param emissionsPerSecond The emission for each asset\n\t */\n\tfunction configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;\n\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t **/\n\tfunction handleActionBefore(address user) external;\n\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t * @param userBalance The balance of the user of the asset in the lending pool\n\t * @param totalSupply The total supply of the asset in the lending pool\n\t **/\n\tfunction handleActionAfter(address user, uint256 userBalance, uint256 totalSupply) external;\n\n\t/**\n\t * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n\t * @param user The address of the user\n\t * @return The rewards\n\t **/\n\tfunction getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n\t/**\n\t * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n\t * @param amount Amount of rewards to claim\n\t * @param to Address that will be receiving the rewards\n\t * @return Rewards claimed\n\t **/\n\tfunction claimRewards(address[] calldata assets, uint256 amount, address to) external returns (uint256);\n\n\t/**\n\t * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n\t * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n\t * @param amount Amount of rewards to claim\n\t * @param user Address to check and claim rewards\n\t * @param to Address that will be receiving the rewards\n\t * @return Rewards claimed\n\t **/\n\tfunction claimRewardsOnBehalf(\n\t\taddress[] calldata assets,\n\t\tuint256 amount,\n\t\taddress user,\n\t\taddress to\n\t) external returns (uint256);\n\n\t/**\n\t * @dev returns the unclaimed rewards of the user\n\t * @param user the address of the user\n\t * @return the unclaimed user rewards\n\t */\n\tfunction getUserUnclaimedRewards(address user) external view returns (uint256);\n\n\t/**\n\t * @dev returns the unclaimed rewards of the user\n\t * @param user the address of the user\n\t * @param asset The asset to incentivize\n\t * @return the user index for the asset\n\t */\n\tfunction getUserAssetData(address user, address asset) external view returns (uint256);\n\n\t/**\n\t * @dev for backward compatibility with previous implementation of the Incentives controller\n\t */\n\tfunction REWARD_TOKEN() external view returns (address);\n\n\t/**\n\t * @dev for backward compatibility with previous implementation of the Incentives controller\n\t */\n\tfunction PRECISION() external view returns (uint8);\n\n\t/**\n\t * @dev Gets the distribution end timestamp of the emissions\n\t */\n\tfunction DISTRIBUTION_END() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAaveOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title IAaveOracle interface\n * @notice Interface for the Aave oracle.\n **/\n\ninterface IAaveOracle {\n\tfunction BASE_CURRENCY() external view returns (address); // if usd returns 0x0, if eth returns weth address\n\n\tfunction BASE_CURRENCY_UNIT() external view returns (uint256);\n\n\t/***********\n    @dev returns the asset price in ETH\n     */\n\tfunction getAssetPrice(address asset) external view returns (uint256);\n\n\tfunction getSourceOfAsset(address asset) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IScaledBalanceToken} from \"./IScaledBalanceToken.sol\";\nimport {IInitializableAToken} from \"./IInitializableAToken.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n\t/**\n\t * @dev Emitted after the mint action\n\t * @param from The address performing the mint\n\t * @param value The amount being\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tevent Mint(address indexed from, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Mints `amount` aTokens to `user`\n\t * @param user The address receiving the minted tokens\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t * @return `true` if the the previous balance of the user was 0\n\t */\n\tfunction mint(address user, uint256 amount, uint256 index) external returns (bool);\n\n\t/**\n\t * @dev Emitted after aTokens are burned\n\t * @param from The owner of the aTokens, getting them burned\n\t * @param target The address that will receive the underlying\n\t * @param value The amount being burned\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tevent Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Emitted during the transfer action\n\t * @param from The user whose tokens are being transferred\n\t * @param to The recipient\n\t * @param value The amount being transferred\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tevent BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n\t * @param user The owner of the aTokens, getting them burned\n\t * @param receiverOfUnderlying The address that will receive the underlying\n\t * @param amount The amount being burned\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tfunction burn(address user, address receiverOfUnderlying, uint256 amount, uint256 index) external;\n\n\t/**\n\t * @dev Mints aTokens to the reserve treasury\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t */\n\tfunction mintToTreasury(uint256 amount, uint256 index) external;\n\n\t/**\n\t * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n\t * @param from The address getting liquidated, current owner of the aTokens\n\t * @param to The recipient\n\t * @param value The amount of tokens getting transferred\n\t **/\n\tfunction transferOnLiquidation(address from, address to, uint256 value) external;\n\n\t/**\n\t * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n\t * assets in borrow(), withdraw() and flashLoan()\n\t * @param user The recipient of the underlying\n\t * @param amount The amount getting transferred\n\t * @return The amount transferred\n\t **/\n\tfunction transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n\t/**\n\t * @dev Invoked to execute actions on the aToken side after a repayment.\n\t * @param user The user executing the repayment\n\t * @param amount The amount getting repaid\n\t **/\n\tfunction handleRepayment(address user, uint256 amount) external;\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view returns (IAaveIncentivesController);\n\n\t/**\n\t * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t **/\n\tfunction UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IBaseOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IBaseOracle {\n\tfunction latestAnswer() external view returns (uint256 price);\n\n\tfunction latestAnswerInEth() external view returns (uint256 price);\n\n\tfunction update() external;\n\n\tfunction canUpdate() external view returns (bool);\n\n\tfunction consult() external view returns (uint256 price);\n}\n"
    },
    "contracts/interfaces/IBountyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IBountyManager {\n\tfunction quote(address _param) external returns (uint256 bounty);\n\n\tfunction claim(address _param) external returns (uint256 bounty);\n\n\tfunction minDLPBalance() external view returns (uint256 amt);\n}\n"
    },
    "contracts/interfaces/IChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\n\npragma solidity 0.8.12;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface IChainlinkAggregator is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "contracts/interfaces/IChefIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface IChefIncentivesController {\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t **/\n\tfunction handleActionBefore(address user) external;\n\n\t/**\n\t * @dev Called by the corresponding asset on any update that affects the rewards distribution\n\t * @param user The address of the user\n\t * @param userBalance The balance of the user of the asset in the lending pool\n\t * @param totalSupply The total supply of the asset in the lending pool\n\t **/\n\tfunction handleActionAfter(address user, uint256 userBalance, uint256 totalSupply) external;\n\n\t/**\n\t * @dev Called by the locking contracts after locking or unlocking happens\n\t * @param user The address of the user\n\t **/\n\tfunction beforeLockUpdate(address user) external;\n\n\t/**\n\t * @notice Hook for lock update.\n\t * @dev Called by the locking contracts after locking or unlocking happens\n\t */\n\tfunction afterLockUpdate(address _user) external;\n\n\tfunction addPool(address _token, uint256 _allocPoint) external;\n\n\tfunction claim(address _user, address[] calldata _tokens) external;\n\n\tfunction setClaimReceiver(address _user, address _receiver) external;\n\n\tfunction getRegisteredTokens() external view returns (address[] memory);\n\n\tfunction disqualifyUser(address _user, address _hunter) external returns (uint256 bounty);\n\n\tfunction bountyForUser(address _user) external view returns (uint256 bounty);\n\n\tfunction allPendingRewards(address _user) external view returns (uint256 pending);\n\n\tfunction claimAll(address _user) external;\n\n\tfunction claimBounty(address _user, bool _execute) external returns (bool issueBaseBounty);\n\n\tfunction setEligibilityExempt(address _address, bool _value) external;\n}\n"
    },
    "contracts/interfaces/ICompounder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface ICompounder {\n\tfunction claimCompound(address _user, bool _execute) external returns (uint256 tokensOut);\n\n\tfunction viewPendingRewards(address user) external view returns (address[] memory tokens, uint256[] memory amts);\n\n\tfunction estimateReturns(address _in, address _out, uint256 amtIn) external view returns (uint256 amtOut);\n}\n"
    },
    "contracts/interfaces/ICreditDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface ICreditDelegationToken {\n\tevent BorrowAllowanceDelegated(address indexed fromUser, address indexed toUser, address asset, uint256 amount);\n\n\t/**\n\t * @dev delegates borrowing power to a user on the specific debt token\n\t * @param delegatee the address receiving the delegated borrowing power\n\t * @param amount the maximum amount being delegated. Delegation will still\n\t * respect the liquidation constraints (even if delegated, a delegatee cannot\n\t * force a delegator HF to go below 1)\n\t **/\n\tfunction approveDelegation(address delegatee, uint256 amount) external;\n\n\t/**\n\t * @dev returns the borrow allowance of the user\n\t * @param fromUser The user to giving allowance\n\t * @param toUser The user to give allowance to\n\t * @return the current allowance of toUser\n\t **/\n\tfunction borrowAllowance(address fromUser, address toUser) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDelegationToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title IDelegationToken\n * @dev Implements an interface for tokens with delegation COMP/UNI compatible\n * @author Aave\n **/\ninterface IDelegationToken {\n\tfunction delegate(address delegatee) external;\n}\n"
    },
    "contracts/interfaces/IEligibilityDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface IEligibilityDataProvider {\n\tfunction refresh(address user) external;\n\n\tfunction updatePrice() external;\n\n\tfunction requiredEthValue(address user) external view returns (uint256 required);\n\n\tfunction isEligibleForRewards(address _user) external view returns (bool isEligible);\n\n\tfunction lastEligibleTime(address user) external view returns (uint256 lastEligibleTimestamp);\n\n\tfunction lockedUsdValue(address user) external view returns (uint256);\n\n\tfunction requiredUsdValue(address user) external view returns (uint256 required);\n\n\tfunction lastEligibleStatus(address user) external view returns (bool);\n\n\tfunction isMarketDisqualified(address user) external view returns (bool);\n\n\tfunction rewardEligibleAmount(address token) external view returns (uint256);\n\n\tfunction setDqTime(address _user, uint256 _time) external;\n\n\tfunction getDqTime(address _user) external view returns (uint256);\n\n\tfunction autoprune() external returns (uint256 processed);\n\n\tfunction requiredDepositRatio() external view returns (uint256);\n\n\tfunction RATIO_DIVISOR() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20DetailedBytes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20DetailedBytes is IERC20 {\n\tfunction name() external view returns (bytes32);\n\n\tfunction symbol() external view returns (bytes32);\n\n\tfunction decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IExchangeAdapter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IExchangeAdapter {\n\tevent Exchange(\n\t\taddress indexed from,\n\t\taddress indexed to,\n\t\taddress indexed platform,\n\t\tuint256 fromAmount,\n\t\tuint256 toAmount\n\t);\n\n\tfunction approveExchange(IERC20[] calldata tokens) external;\n\n\tfunction exchange(address from, address to, uint256 amount, uint256 maxSlippage) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"./LockedBalance.sol\";\n\ninterface IFeeDistribution {\n\tstruct RewardData {\n\t\taddress token;\n\t\tuint256 amount;\n\t}\n\n\tfunction addReward(address rewardsToken) external;\n\n\tfunction lockedBalances(\n\t\taddress user\n\t) external view returns (uint256, uint256, uint256, uint256, LockedBalance[] memory);\n}\n"
    },
    "contracts/interfaces/IIncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IScaledBalanceToken} from \"./IScaledBalanceToken.sol\";\nimport {IInitializableAToken} from \"./IInitializableAToken.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\ninterface IIncentivizedERC20 {\n\tfunction getAssetPrice() external view returns (uint256);\n\n\tfunction decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingPool} from \"./ILendingPool.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\n/**\n * @title IInitializableAToken\n * @notice Interface for the initialize function on AToken\n * @author Aave\n **/\ninterface IInitializableAToken {\n\t/**\n\t * @dev Emitted when an aToken is initialized\n\t * @param underlyingAsset The address of the underlying asset\n\t * @param pool The address of the associated lending pool\n\t * @param treasury The address of the treasury\n\t * @param incentivesController The address of the incentives controller for this aToken\n\t * @param aTokenDecimals the decimals of the underlying\n\t * @param aTokenName the name of the aToken\n\t * @param aTokenSymbol the symbol of the aToken\n\t * @param params A set of encoded parameters for additional initialization\n\t **/\n\tevent Initialized(\n\t\taddress indexed underlyingAsset,\n\t\taddress indexed pool,\n\t\taddress treasury,\n\t\taddress incentivesController,\n\t\tuint8 aTokenDecimals,\n\t\tstring aTokenName,\n\t\tstring aTokenSymbol,\n\t\tbytes params\n\t);\n\n\t/**\n\t * @dev Initializes the aToken\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n\t * @param aTokenName The name of the aToken\n\t * @param aTokenSymbol The symbol of the aToken\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress treasury,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 aTokenDecimals,\n\t\tstring calldata aTokenName,\n\t\tstring calldata aTokenSymbol,\n\t\tbytes calldata params\n\t) external;\n}\n"
    },
    "contracts/interfaces/IInitializableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingPool} from \"./ILendingPool.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\n/**\n * @title IInitializableDebtToken\n * @notice Interface for the initialize function common between debt tokens\n * @author Aave\n **/\ninterface IInitializableDebtToken {\n\t/**\n\t * @dev Emitted when a debt token is initialized\n\t * @param underlyingAsset The address of the underlying asset\n\t * @param pool The address of the associated lending pool\n\t * @param incentivesController The address of the incentives controller for this aToken\n\t * @param debtTokenDecimals the decimals of the debt token\n\t * @param debtTokenName the name of the debt token\n\t * @param debtTokenSymbol the symbol of the debt token\n\t * @param params A set of encoded parameters for additional initialization\n\t **/\n\tevent Initialized(\n\t\taddress indexed underlyingAsset,\n\t\taddress indexed pool,\n\t\taddress incentivesController,\n\t\tuint8 debtTokenDecimals,\n\t\tstring debtTokenName,\n\t\tstring debtTokenSymbol,\n\t\tbytes params\n\t);\n\n\t/**\n\t * @dev Initializes the debt token.\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n\t * @param debtTokenName The name of the token\n\t * @param debtTokenSymbol The symbol of the token\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 debtTokenDecimals,\n\t\tstring memory debtTokenName,\n\t\tstring memory debtTokenSymbol,\n\t\tbytes calldata params\n\t) external;\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\nimport {DataTypes} from \"../lending/libraries/types/DataTypes.sol\";\n\ninterface ILendingPool {\n\t/**\n\t * @dev Emitted on deposit()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address initiating the deposit\n\t * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n\t * @param amount The amount deposited\n\t * @param referral The referral code used\n\t **/\n\tevent Deposit(\n\t\taddress indexed reserve,\n\t\taddress user,\n\t\taddress indexed onBehalfOf,\n\t\tuint256 amount,\n\t\tuint16 indexed referral\n\t);\n\n\t/**\n\t * @dev Emitted on withdraw()\n\t * @param reserve The address of the underlyng asset being withdrawn\n\t * @param user The address initiating the withdrawal, owner of aTokens\n\t * @param to Address that will receive the underlying\n\t * @param amount The amount to be withdrawn\n\t **/\n\tevent Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n\t/**\n\t * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n\t * @param reserve The address of the underlying asset being borrowed\n\t * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n\t * initiator of the transaction on flashLoan()\n\t * @param onBehalfOf The address that will be getting the debt\n\t * @param amount The amount borrowed out\n\t * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n\t * @param borrowRate The numeric rate at which the user has borrowed\n\t * @param referral The referral code used\n\t **/\n\tevent Borrow(\n\t\taddress indexed reserve,\n\t\taddress user,\n\t\taddress indexed onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 borrowRateMode,\n\t\tuint256 borrowRate,\n\t\tuint16 indexed referral\n\t);\n\n\t/**\n\t * @dev Emitted on repay()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The beneficiary of the repayment, getting his debt reduced\n\t * @param repayer The address of the user initiating the repay(), providing the funds\n\t * @param amount The amount repaid\n\t **/\n\tevent Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n\t/**\n\t * @dev Emitted on swapBorrowRateMode()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user swapping his rate mode\n\t * @param rateMode The rate mode that the user wants to swap to\n\t **/\n\tevent Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n\t/**\n\t * @dev Emitted on setUserUseReserveAsCollateral()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user enabling the usage as collateral\n\t **/\n\tevent ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted on setUserUseReserveAsCollateral()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user enabling the usage as collateral\n\t **/\n\tevent ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted on rebalanceStableBorrowRate()\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param user The address of the user for which the rebalance has been executed\n\t **/\n\tevent RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted on flashLoan()\n\t * @param target The address of the flash loan receiver contract\n\t * @param initiator The address initiating the flash loan\n\t * @param asset The address of the asset being flash borrowed\n\t * @param amount The amount flash borrowed\n\t * @param premium The fee flash borrowed\n\t * @param referralCode The referral code used\n\t **/\n\tevent FlashLoan(\n\t\taddress indexed target,\n\t\taddress indexed initiator,\n\t\taddress indexed asset,\n\t\tuint256 amount,\n\t\tuint256 premium,\n\t\tuint16 referralCode\n\t);\n\n\t/**\n\t * @dev Emitted when the pause is triggered.\n\t */\n\tevent Paused();\n\n\t/**\n\t * @dev Emitted when the pause is lifted.\n\t */\n\tevent Unpaused();\n\n\t/**\n\t * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n\t * LendingPoolCollateral manager using a DELEGATECALL\n\t * This allows to have the events in the generated ABI for LendingPool.\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n\t * @param liquidator The address of the liquidator\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tevent LiquidationCall(\n\t\taddress indexed collateralAsset,\n\t\taddress indexed debtAsset,\n\t\taddress indexed user,\n\t\tuint256 debtToCover,\n\t\tuint256 liquidatedCollateralAmount,\n\t\taddress liquidator,\n\t\tbool receiveAToken\n\t);\n\n\t/**\n\t * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n\t * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n\t * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n\t * gets added to the LendingPool ABI\n\t * @param reserve The address of the underlying asset of the reserve\n\t * @param liquidityRate The new liquidity rate\n\t * @param stableBorrowRate The new stable borrow rate\n\t * @param variableBorrowRate The new variable borrow rate\n\t * @param liquidityIndex The new liquidity index\n\t * @param variableBorrowIndex The new variable borrow index\n\t **/\n\tevent ReserveDataUpdated(\n\t\taddress indexed reserve,\n\t\tuint256 liquidityRate,\n\t\tuint256 stableBorrowRate,\n\t\tuint256 variableBorrowRate,\n\t\tuint256 liquidityIndex,\n\t\tuint256 variableBorrowIndex\n\t);\n\n\t/**\n\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n\t * @param asset The address of the underlying asset to deposit\n\t * @param amount The amount to be deposited\n\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n\t *   is a different wallet\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n\tfunction depositWithAutoDLP(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n\t/**\n\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n\t * @param asset The address of the underlying asset to withdraw\n\t * @param amount The underlying amount to be withdrawn\n\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n\t * @param to Address that will receive the underlying, same as msg.sender if the user\n\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n\t *   different wallet\n\t * @return The final amount withdrawn\n\t **/\n\tfunction withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n\t/**\n\t * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n\t * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n\t * corresponding debt token (StableDebtToken or VariableDebtToken)\n\t * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n\t *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n\t * @param asset The address of the underlying asset to borrow\n\t * @param amount The amount to be borrowed\n\t * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n\t * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n\t * if he has been given credit delegation allowance\n\t **/\n\tfunction borrow(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 interestRateMode,\n\t\tuint16 referralCode,\n\t\taddress onBehalfOf\n\t) external;\n\n\t/**\n\t * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n\t * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n\t * @param asset The address of the borrowed underlying asset previously borrowed\n\t * @param amount The amount to repay\n\t * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n\t * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n\t * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n\t * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n\t * other borrower whose debt should be removed\n\t * @return The final amount repaid\n\t **/\n\tfunction repay(address asset, uint256 amount, uint256 rateMode, address onBehalfOf) external returns (uint256);\n\n\t/**\n\t * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n\t * @param asset The address of the underlying asset borrowed\n\t * @param rateMode The rate mode that the user wants to swap to\n\t **/\n\tfunction swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n\t/**\n\t * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n\t * - Users can be rebalanced if the following conditions are satisfied:\n\t *     1. Usage ratio is above 95%\n\t *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n\t *        borrowed at a stable rate and depositors are not earning enough\n\t * @param asset The address of the underlying asset borrowed\n\t * @param user The address of the user to be rebalanced\n\t **/\n\tfunction rebalanceStableBorrowRate(address asset, address user) external;\n\n\t/**\n\t * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n\t * @param asset The address of the underlying asset deposited\n\t * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n\t **/\n\tfunction setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n\t/**\n\t * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n\t * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n\t *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tfunction liquidationCall(\n\t\taddress collateralAsset,\n\t\taddress debtAsset,\n\t\taddress user,\n\t\tuint256 debtToCover,\n\t\tbool receiveAToken\n\t) external;\n\n\t/**\n\t * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n\t * as long as the amount taken plus a fee is returned.\n\t * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n\t * For further details please visit https://developers.aave.com\n\t * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n\t * @param assets The addresses of the assets being flash-borrowed\n\t * @param amounts The amounts amounts being flash-borrowed\n\t * @param modes Types of the debt to open if the flash loan is not returned:\n\t *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n\t *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n\t * @param params Variadic packed params to pass to the receiver as extra information\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction flashLoan(\n\t\taddress receiverAddress,\n\t\taddress[] calldata assets,\n\t\tuint256[] calldata amounts,\n\t\tuint256[] calldata modes,\n\t\taddress onBehalfOf,\n\t\tbytes calldata params,\n\t\tuint16 referralCode\n\t) external;\n\n\t/**\n\t * @dev Returns the user account data across all the reserves\n\t * @param user The address of the user\n\t * @return totalCollateralETH the total collateral in ETH of the user\n\t * @return totalDebtETH the total debt in ETH of the user\n\t * @return availableBorrowsETH the borrowing power left of the user\n\t * @return currentLiquidationThreshold the liquidation threshold of the user\n\t * @return ltv the loan to value of the user\n\t * @return healthFactor the current health factor of the user\n\t **/\n\tfunction getUserAccountData(\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 totalCollateralETH,\n\t\t\tuint256 totalDebtETH,\n\t\t\tuint256 availableBorrowsETH,\n\t\t\tuint256 currentLiquidationThreshold,\n\t\t\tuint256 ltv,\n\t\t\tuint256 healthFactor\n\t\t);\n\n\tfunction initReserve(\n\t\taddress reserve,\n\t\taddress aTokenAddress,\n\t\taddress stableDebtAddress,\n\t\taddress variableDebtAddress,\n\t\taddress interestRateStrategyAddress\n\t) external;\n\n\tfunction setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n\tfunction setConfiguration(address reserve, uint256 configuration) external;\n\n\t/**\n\t * @dev Returns the configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The configuration of the reserve\n\t **/\n\tfunction getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n\t/**\n\t * @dev Returns the configuration of the user across all the reserves\n\t * @param user The user address\n\t * @return The configuration of the user\n\t **/\n\tfunction getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n\t/**\n\t * @dev Returns the normalized income normalized income of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve's normalized income\n\t */\n\tfunction getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the normalized variable debt per unit of asset\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve normalized variable debt\n\t */\n\tfunction getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the state and configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The state of the reserve\n\t **/\n\tfunction getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n\tfunction finalizeTransfer(\n\t\taddress asset,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount,\n\t\tuint256 balanceFromAfter,\n\t\tuint256 balanceToBefore\n\t) external;\n\n\tfunction getReservesList() external view returns (address[] memory);\n\n\tfunction getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n\tfunction setPause(bool val) external;\n\n\tfunction paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n\tevent MarketIdSet(string newMarketId);\n\tevent LendingPoolUpdated(address indexed newAddress);\n\tevent ConfigurationAdminUpdated(address indexed newAddress);\n\tevent EmergencyAdminUpdated(address indexed newAddress);\n\tevent LendingPoolConfiguratorUpdated(address indexed newAddress);\n\tevent LendingPoolCollateralManagerUpdated(address indexed newAddress);\n\tevent PriceOracleUpdated(address indexed newAddress);\n\tevent LendingRateOracleUpdated(address indexed newAddress);\n\tevent ProxyCreated(bytes32 id, address indexed newAddress);\n\tevent AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n\tfunction getMarketId() external view returns (string memory);\n\n\tfunction setMarketId(string calldata marketId) external;\n\n\tfunction setAddress(bytes32 id, address newAddress) external;\n\n\tfunction setAddressAsProxy(bytes32 id, address impl) external;\n\n\tfunction getAddress(bytes32 id) external view returns (address);\n\n\tfunction getLendingPool() external view returns (address);\n\n\tfunction setLendingPoolImpl(address pool) external;\n\n\tfunction getLendingPoolConfigurator() external view returns (address);\n\n\tfunction setLendingPoolConfiguratorImpl(address configurator) external;\n\n\tfunction getLendingPoolCollateralManager() external view returns (address);\n\n\tfunction setLendingPoolCollateralManager(address manager) external;\n\n\tfunction getPoolAdmin() external view returns (address);\n\n\tfunction setPoolAdmin(address admin) external;\n\n\tfunction getEmergencyAdmin() external view returns (address);\n\n\tfunction setEmergencyAdmin(address admin) external;\n\n\tfunction getPriceOracle() external view returns (address);\n\n\tfunction setPriceOracle(address priceOracle) external;\n\n\tfunction getLendingRateOracle() external view returns (address);\n\n\tfunction setLendingRateOracle(address lendingRateOracle) external;\n\n\tfunction getLiquidationFeeTo() external view returns (address);\n\n\tfunction setLiquidationFeeTo(address liquidationFeeTo) external;\n}\n"
    },
    "contracts/interfaces/ILendingPoolAddressesProviderRegistry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title LendingPoolAddressesProviderRegistry contract\n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets\n * - Used for indexing purposes of Aave protocol's markets\n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with,\n *   for example with `0` for the Aave main market and `1` for the next created\n * @author Aave\n **/\ninterface ILendingPoolAddressesProviderRegistry {\n\tevent AddressesProviderRegistered(address indexed newAddress);\n\tevent AddressesProviderUnregistered(address indexed newAddress);\n\n\tfunction getAddressesProvidersList() external view returns (address[] memory);\n\n\tfunction getAddressesProviderIdByAddress(address addressesProvider) external view returns (uint256);\n\n\tfunction registerAddressesProvider(address provider, uint256 id) external;\n\n\tfunction unregisterAddressesProvider(address provider) external;\n}\n"
    },
    "contracts/interfaces/ILendingPoolCollateralManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title ILendingPoolCollateralManager\n * @author Aave\n * @notice Defines the actions involving management of collateral in the protocol.\n **/\ninterface ILendingPoolCollateralManager {\n\t/**\n\t * @dev Emitted when a borrower is liquidated\n\t * @param collateral The address of the collateral being liquidated\n\t * @param principal The address of the reserve\n\t * @param user The address of the user being liquidated\n\t * @param debtToCover The total amount liquidated\n\t * @param liquidatedCollateralAmount The amount of collateral being liquidated\n\t * @param liquidator The address of the liquidator\n\t * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise\n\t **/\n\tevent LiquidationCall(\n\t\taddress indexed collateral,\n\t\taddress indexed principal,\n\t\taddress indexed user,\n\t\tuint256 debtToCover,\n\t\tuint256 liquidatedCollateralAmount,\n\t\taddress liquidator,\n\t\tbool receiveAToken,\n\t\taddress liquidationFeeTo\n\t);\n\n\t/**\n\t * @dev Emitted when a reserve is disabled as collateral for an user\n\t * @param reserve The address of the reserve\n\t * @param user The address of the user\n\t **/\n\tevent ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Emitted when a reserve is enabled as collateral for an user\n\t * @param reserve The address of the reserve\n\t * @param user The address of the user\n\t **/\n\tevent ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n\t/**\n\t * @dev Users can invoke this function to liquidate an undercollateralized position.\n\t * @param collateral The address of the collateral to liquidated\n\t * @param principal The address of the principal reserve\n\t * @param user The address of the borrower\n\t * @param debtToCover The amount of principal that the liquidator wants to repay\n\t * @param receiveAToken true if the liquidators wants to receive the aTokens, false if\n\t * he wants to receive the underlying asset directly\n\t **/\n\tfunction liquidationCall(\n\t\taddress collateral,\n\t\taddress principal,\n\t\taddress user,\n\t\tuint256 debtToCover,\n\t\tbool receiveAToken,\n\t\taddress liquidationFeeTo\n\t) external returns (uint256, string memory);\n}\n"
    },
    "contracts/interfaces/ILendingPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n//[[0xEf9bBa295a4b3acB014304C4Ada27a3D190E3BB2],[0x6695EdB1671d78E434224977709911BB1F5AC1A9],[0xf67a2D777bDC066793aD79873fCfA33Fb01ab619],[6],[0xc6F3222E3a4fC4Fda7170f34FE8C84FAa7A20e4C],[0x1fdE0eCc619726f4cD597887C9F3b4c8740e19e2],[0x58F3499Ce37791fef39D0b6F6339c60844895AFc],[0x530C6d01F7Ea4f968CEB9053708431a089A9a352],[\"10\"],[\"USDT\"],[\"USDTATOKEN\"],[\"USDTATOKEN\"],[\"USDTVDTOKEN\"],[\"USDTVDTOKEN\"],[\"USDTSDTOKEN\"],[\"USDTSDTOKEN\"],[\"0x10\"]]\ninterface ILendingPoolConfigurator {\n\tstruct InitReserveInput {\n\t\taddress aTokenImpl;\n\t\taddress stableDebtTokenImpl;\n\t\taddress variableDebtTokenImpl;\n\t\tuint8 underlyingAssetDecimals;\n\t\taddress interestRateStrategyAddress;\n\t\taddress underlyingAsset;\n\t\taddress treasury;\n\t\taddress incentivesController;\n\t\tuint256 allocPoint;\n\t\tstring underlyingAssetName;\n\t\tstring aTokenName;\n\t\tstring aTokenSymbol;\n\t\tstring variableDebtTokenName;\n\t\tstring variableDebtTokenSymbol;\n\t\tstring stableDebtTokenName;\n\t\tstring stableDebtTokenSymbol;\n\t\tbytes params;\n\t}\n\n\tstruct UpdateATokenInput {\n\t\taddress asset;\n\t\taddress treasury;\n\t\taddress incentivesController;\n\t\tstring name;\n\t\tstring symbol;\n\t\taddress implementation;\n\t\tbytes params;\n\t}\n\n\tstruct UpdateDebtTokenInput {\n\t\taddress asset;\n\t\taddress incentivesController;\n\t\tstring name;\n\t\tstring symbol;\n\t\taddress implementation;\n\t\tbytes params;\n\t}\n\n\t/**\n\t * @dev Emitted when a reserve is initialized.\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param aToken The address of the associated aToken contract\n\t * @param stableDebtToken The address of the associated stable rate debt token\n\t * @param variableDebtToken The address of the associated variable rate debt token\n\t * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve\n\t **/\n\tevent ReserveInitialized(\n\t\taddress indexed asset,\n\t\taddress indexed aToken,\n\t\taddress stableDebtToken,\n\t\taddress variableDebtToken,\n\t\taddress interestRateStrategyAddress\n\t);\n\n\t/**\n\t * @dev Emitted when borrowing is enabled on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param stableRateEnabled True if stable rate borrowing is enabled, false otherwise\n\t **/\n\tevent BorrowingEnabledOnReserve(address indexed asset, bool stableRateEnabled);\n\n\t/**\n\t * @dev Emitted when borrowing is disabled on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent BorrowingDisabledOnReserve(address indexed asset);\n\n\t/**\n\t * @dev Emitted when the collateralization risk parameters for the specified asset are updated.\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param ltv The loan to value of the asset when used as collateral\n\t * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n\t * @param liquidationBonus The bonus liquidators receive to liquidate this asset\n\t **/\n\tevent CollateralConfigurationChanged(\n\t\taddress indexed asset,\n\t\tuint256 ltv,\n\t\tuint256 liquidationThreshold,\n\t\tuint256 liquidationBonus\n\t);\n\n\t/**\n\t * @dev Emitted when stable rate borrowing is enabled on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent StableRateEnabledOnReserve(address indexed asset);\n\n\t/**\n\t * @dev Emitted when stable rate borrowing is disabled on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent StableRateDisabledOnReserve(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve is activated\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent ReserveActivated(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve is deactivated\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent ReserveDeactivated(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve is frozen\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent ReserveFrozen(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve is unfrozen\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tevent ReserveUnfrozen(address indexed asset);\n\n\t/**\n\t * @dev Emitted when a reserve factor is updated\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param factor The new reserve factor\n\t **/\n\tevent ReserveFactorChanged(address indexed asset, uint256 factor);\n\n\t/**\n\t * @dev Emitted when the reserve decimals are updated\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param decimals The new decimals\n\t **/\n\tevent ReserveDecimalsChanged(address indexed asset, uint256 decimals);\n\n\t/**\n\t * @dev Emitted when a reserve interest strategy contract is updated\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param strategy The new address of the interest strategy contract\n\t **/\n\tevent ReserveInterestRateStrategyChanged(address indexed asset, address strategy);\n\n\t/**\n\t * @dev Emitted when an aToken implementation is upgraded\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param proxy The aToken proxy address\n\t * @param implementation The new aToken implementation\n\t **/\n\tevent ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n\n\t/**\n\t * @dev Emitted when the implementation of a stable debt token is upgraded\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param proxy The stable debt token proxy address\n\t * @param implementation The new aToken implementation\n\t **/\n\tevent StableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n\n\t/**\n\t * @dev Emitted when the implementation of a variable debt token is upgraded\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param proxy The variable debt token proxy address\n\t * @param implementation The new aToken implementation\n\t **/\n\tevent VariableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);\n}\n"
    },
    "contracts/interfaces/ILendingRateOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title ILendingRateOracle interface\n * @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\n **/\n\ninterface ILendingRateOracle {\n\t/**\n    @dev returns the market borrow rate in ray\n    **/\n\tfunction getMarketBorrowRate(address asset) external view returns (uint256);\n\n\t/**\n    @dev sets the market borrow rate. Rate value must be in ray\n    **/\n\tfunction setMarketBorrowRate(address asset, uint256 rate) external;\n}\n"
    },
    "contracts/interfaces/ILeverager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface ILeverager {\n\tfunction wethToZap(address user) external view returns (uint256);\n\n\tfunction zapWETHWithBorrow(uint256 amount, address borrower) external returns (uint256 liquidity);\n\n\tfunction zapWETHWithBorrow(\n\t\tuint256 amount,\n\t\taddress borrower,\n\t\taddress onBehalfOf\n\t) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/ILiquidityZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface ILiquidityZap {\n\tfunction _WETH() external view returns (address);\n\n\tfunction _token() external view returns (address);\n\n\tfunction _tokenWETHPair() external view returns (address);\n\n\tfunction addLiquidityETHOnly(address to) external returns (uint256 liquidity);\n\n\tfunction addLiquidityTokensOnly(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) external returns (uint256 liquidity);\n\n\tfunction getLPTokenPerEthUnit(uint256 ethAmt) external view returns (uint256 liquidity);\n\n\tfunction initLiquidityZap(\n\t\taddress token,\n\t\taddress WETH,\n\t\taddress tokenWethPair,\n\t\taddress helper\n\t) external;\n\n\tfunction quote(uint256 wethAmount) external view returns (uint256 optimalTokenAmount);\n\n\tfunction quoteFromToken(uint256 tokenAmount) external view returns (uint256 optimalWETHAmount);\n\n\tfunction removeAllLiquidityETHOnly(address to) external returns (uint256 amount);\n\n\tfunction removeAllLiquidityTokenOnly(address to) external returns (uint256 amount);\n\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\taddress to\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETHOnly(address to, uint256 liquidity) external returns (uint256 amountOut);\n\n\tfunction removeLiquidityTokenOnly(address to, uint256 liquidity) external returns (uint256 amount);\n\n\tfunction standardAdd(\n\t\tuint256 tokenAmount,\n\t\tuint256 _wethAmt,\n\t\taddress to\n\t) external payable returns (uint256 liquidity);\n\n\tfunction unzap() external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction unzapToETH() external returns (uint256 amount);\n\n\tfunction unzapToTokens() external returns (uint256 amount);\n\n\tfunction zapETH(address payable _onBehalf) external payable returns (uint256 liquidity);\n\n\tfunction zapTokens(uint256 amount) external returns (uint256 liquidity);\n\n\tfunction addLiquidityWETHOnly(uint256 _amount, address payable to) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/ILockerList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ninterface ILockerList {\n\tfunction lockersCount() external view returns (uint256);\n\n\tfunction getUsers(uint256 page, uint256 limit) external view returns (address[] memory);\n\n\tfunction addToList(address user) external;\n\n\tfunction removeFromList(address user) external;\n}\n"
    },
    "contracts/interfaces/ILockZap.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\ninterface ILockZap {\n\tfunction zap(\n\t\tbool _borrow,\n\t\tuint256 _wethAmt,\n\t\tuint256 _rdntAmt,\n\t\tuint256 _lockTypeIndex\n\t) external returns (uint256 liquidity);\n\n\tfunction zapOnBehalf(\n\t\tbool _borrow,\n\t\tuint256 _wethAmt,\n\t\tuint256 _rdntAmt,\n\t\taddress _onBehalf\n\t) external returns (uint256 liquidity);\n}\n"
    },
    "contracts/interfaces/IMiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"./LockedBalance.sol\";\nimport {IFeeDistribution} from \"./IMultiFeeDistribution.sol\";\n\ninterface IMiddleFeeDistribution is IFeeDistribution {\n\tfunction forwardReward(address[] memory _rewardTokens) external;\n\n\tfunction getRdntTokenAddress() external view returns (address);\n\n\tfunction getMultiFeeDistributionAddress() external view returns (address);\n\n\tfunction operationExpenseRatio() external view returns (uint256);\n\n\tfunction operationExpenses() external view returns (address);\n\n\tfunction isRewardToken(address) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IMintableToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMintableToken is IERC20 {\n\tfunction mint(address _receiver, uint256 _amount) external returns (bool);\n\n\tfunction burn(uint256 _amount) external returns (bool);\n\n\tfunction setMinter(address _minter) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IMultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"./LockedBalance.sol\";\nimport \"./IFeeDistribution.sol\";\nimport \"./IMintableToken.sol\";\n\ninterface IMultiFeeDistribution is IFeeDistribution {\n\tfunction exit(bool claimRewards) external;\n\n\tfunction stake(uint256 amount, address onBehalfOf, uint256 typeIndex) external;\n\n\tfunction rdntToken() external view returns (IMintableToken);\n\n\tfunction getPriceProvider() external view returns (address);\n\n\tfunction lockInfo(address user) external view returns (LockedBalance[] memory);\n\n\tfunction autocompoundEnabled(address user) external view returns (bool);\n\n\tfunction defaultLockIndex(address _user) external view returns (uint256);\n\n\tfunction autoRelockDisabled(address user) external view returns (bool);\n\n\tfunction totalBalance(address user) external view returns (uint256);\n\n\tfunction zapVestingToLp(address _address) external returns (uint256);\n\n\tfunction withdrawExpiredLocksFor(address _address) external returns (uint256);\n\n\tfunction claimableRewards(address account) external view returns (IFeeDistribution.RewardData[] memory rewards);\n\n\tfunction setDefaultRelockTypeIndex(uint256 _index) external;\n\n\tfunction daoTreasury() external view returns (address);\n\n\tfunction stakingToken() external view returns (address);\n\n\tfunction claimFromConverter(address) external;\n\n\tfunction mint(address user, uint256 amount, bool withPenalty) external;\n}\n\ninterface IMFDPlus is IMultiFeeDistribution {\n\tfunction getLastClaimTime(address _user) external returns (uint256);\n\n\tfunction claimBounty(address _user, bool _execute) external returns (bool issueBaseBounty);\n\n\tfunction claimCompound(address _user, bool _execute) external returns (uint256 bountyAmt);\n\n\tfunction setAutocompound(bool _newVal) external;\n\n\tfunction getAutocompoundEnabled(address _user) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOnwardIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IOnwardIncentivesController {\n\tfunction handleAction(address _token, address _user, uint256 _balance, uint256 _totalSupply) external;\n}\n"
    },
    "contracts/interfaces/IPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPoolHelper {\n\tfunction lpTokenAddr() external view returns (address);\n\n\tfunction zapWETH(uint256 amount) external returns (uint256);\n\n\tfunction zapTokens(uint256 _wethAmt, uint256 _rdntAmt) external returns (uint256);\n\n\tfunction quoteFromToken(uint256 tokenAmount) external view returns (uint256 optimalWETHAmount);\n\n\tfunction getLpPrice(uint rdntPriceInEth) external view returns (uint256 priceInEth);\n\n\tfunction getReserves() external view returns (uint256 rdnt, uint256 weth, uint256 lpTokenSupply);\n\n\tfunction getPrice() external view returns (uint256 priceInEth);\n}\n\ninterface IBalancerPoolHelper is IPoolHelper {\n\tfunction initializePool(string calldata _tokenName, string calldata _tokenSymbol) external;\n}\n\ninterface IUniswapPoolHelper is IPoolHelper {\n\tfunction initializePool() external;\n}\n\ninterface ITestPoolHelper is IPoolHelper {\n\tfunction sell(uint256 _amount) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/************\n@title IPriceOracle interface\n@notice Interface for the Aave price oracle.*/\ninterface IPriceOracle {\n\t/***********\n    @dev returns the asset price in ETH\n     */\n\tfunction getAssetPrice(address asset) external view returns (uint256);\n\n\t/***********\n    @dev sets the asset price, in wei\n     */\n\tfunction setAssetPrice(address asset, uint256 price) external;\n}\n"
    },
    "contracts/interfaces/IPriceOracleGetter.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title IPriceOracleGetter interface\n * @notice Interface for the Aave price oracle.\n **/\n\ninterface IPriceOracleGetter {\n\t/**\n\t * @dev returns the asset price in ETH\n\t * @param asset the address of the asset\n\t * @return the ETH price of the asset\n\t **/\n\tfunction getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IPriceProvider {\n\tfunction getTokenPrice() external view returns (uint256);\n\n\tfunction getTokenPriceUsd() external view returns (uint256);\n\n\tfunction getLpTokenPrice() external view returns (uint256);\n\n\tfunction getLpTokenPriceUsd() external view returns (uint256);\n\n\tfunction decimals() external view returns (uint256);\n\n\tfunction update() external;\n\n\tfunction baseTokenPriceInUsdProxyAggregator() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title IReserveInterestRateStrategyInterface interface\n * @dev Interface for the calculation of the interest rates\n * @author Aave\n */\ninterface IReserveInterestRateStrategy {\n\tfunction baseVariableBorrowRate() external view returns (uint256);\n\n\tfunction getMaxVariableBorrowRate() external view returns (uint256);\n\n\tfunction calculateInterestRates(\n\t\taddress reserve,\n\t\tuint256 availableLiquidity,\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 averageStableBorrowRate,\n\t\tuint256 reserveFactor\n\t) external view returns (uint256, uint256, uint256);\n\n\tfunction calculateInterestRates(\n\t\taddress reserve,\n\t\taddress aToken,\n\t\tuint256 liquidityAdded,\n\t\tuint256 liquidityTaken,\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 averageStableBorrowRate,\n\t\tuint256 reserveFactor\n\t) external view returns (uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate);\n}\n"
    },
    "contracts/interfaces/IRouterETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.12;\npragma abicoder v2;\n\ninterface IRouterETH {\n\tfunction swapETH(\n\t\tuint16 _dstChainId, // destination Stargate chainId\n\t\taddress payable _refundAddress, // refund additional messageFee to this address\n\t\tbytes calldata _toAddress, // the receiver of the destination ETH\n\t\tuint256 _amountLD, // the amount, in Local Decimals, to be swapped\n\t\tuint256 _minAmountLD // the minimum amount accepted out on destination\n\t) external payable;\n}\n"
    },
    "contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IScaledBalanceToken {\n\t/**\n\t * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n\t * updated stored balance divided by the reserve's liquidity index at the moment of the update\n\t * @param user The user whose balance is calculated\n\t * @return The scaled balance of the user\n\t **/\n\tfunction scaledBalanceOf(address user) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the scaled balance of the user and the scaled total supply.\n\t * @param user The address of the user\n\t * @return The scaled balance of the user\n\t * @return The scaled balance and the scaled total supply\n\t **/\n\tfunction getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n\t/**\n\t * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n\t * @return The scaled total supply\n\t **/\n\tfunction scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {IInitializableDebtToken} from \"./IInitializableDebtToken.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\n/**\n * @title IStableDebtToken\n * @notice Defines the interface for the stable debt token\n * @dev It does not inherit from IERC20 to save in code size\n * @author Aave\n **/\n\ninterface IStableDebtToken is IInitializableDebtToken {\n\t/**\n\t * @dev Emitted when new stable debt is minted\n\t * @param user The address of the user who triggered the minting\n\t * @param onBehalfOf The recipient of stable debt tokens\n\t * @param amount The amount minted\n\t * @param currentBalance The current balance of the user\n\t * @param balanceIncrease The increase in balance since the last action of the user\n\t * @param newRate The rate of the debt after the minting\n\t * @param avgStableRate The new average stable rate after the minting\n\t * @param newTotalSupply The new total supply of the stable debt token after the action\n\t **/\n\tevent Mint(\n\t\taddress indexed user,\n\t\taddress indexed onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 currentBalance,\n\t\tuint256 balanceIncrease,\n\t\tuint256 newRate,\n\t\tuint256 avgStableRate,\n\t\tuint256 newTotalSupply\n\t);\n\n\t/**\n\t * @dev Emitted when new stable debt is burned\n\t * @param user The address of the user\n\t * @param amount The amount being burned\n\t * @param currentBalance The current balance of the user\n\t * @param balanceIncrease The the increase in balance since the last action of the user\n\t * @param avgStableRate The new average stable rate after the burning\n\t * @param newTotalSupply The new total supply of the stable debt token after the action\n\t **/\n\tevent Burn(\n\t\taddress indexed user,\n\t\tuint256 amount,\n\t\tuint256 currentBalance,\n\t\tuint256 balanceIncrease,\n\t\tuint256 avgStableRate,\n\t\tuint256 newTotalSupply\n\t);\n\n\t/**\n\t * @dev Mints debt token to the `onBehalfOf` address.\n\t * - The resulting rate is the weighted average between the rate of the new debt\n\t * and the rate of the previous debt\n\t * @param user The address receiving the borrowed underlying, being the delegatee in case\n\t * of credit delegate, or same as `onBehalfOf` otherwise\n\t * @param onBehalfOf The address receiving the debt tokens\n\t * @param amount The amount of debt tokens to mint\n\t * @param rate The rate of the debt being minted\n\t **/\n\tfunction mint(address user, address onBehalfOf, uint256 amount, uint256 rate) external returns (bool);\n\n\t/**\n\t * @dev Burns debt of `user`\n\t * - The resulting rate is the weighted average between the rate of the new debt\n\t * and the rate of the previous debt\n\t * @param user The address of the user getting his debt burned\n\t * @param amount The amount of debt tokens getting burned\n\t **/\n\tfunction burn(address user, uint256 amount) external;\n\n\t/**\n\t * @dev Returns the average rate of all the stable rate loans.\n\t * @return The average stable rate\n\t **/\n\tfunction getAverageStableRate() external view returns (uint256);\n\n\t/**\n\t * @dev Returns the stable rate of the user debt\n\t * @return The stable rate of the user\n\t **/\n\tfunction getUserStableRate(address user) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the timestamp of the last update of the user\n\t * @return The timestamp\n\t **/\n\tfunction getUserLastUpdated(address user) external view returns (uint40);\n\n\t/**\n\t * @dev Returns the principal, the total supply and the average stable rate\n\t **/\n\tfunction getSupplyData() external view returns (uint256, uint256, uint256, uint40);\n\n\t/**\n\t * @dev Returns the timestamp of the last update of the total supply\n\t * @return The timestamp\n\t **/\n\tfunction getTotalSupplyLastUpdated() external view returns (uint40);\n\n\t/**\n\t * @dev Returns the total supply and the average stable rate\n\t **/\n\tfunction getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\n\n\t/**\n\t * @dev Returns the principal debt balance of the user\n\t * @return The debt balance of the user since the last burn/mint action\n\t **/\n\tfunction principalBalanceOf(address user) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view returns (IAaveIncentivesController);\n}\n"
    },
    "contracts/interfaces/IStargateRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.12;\npragma abicoder v2;\n\ninterface IStargateRouter {\n\tstruct lzTxObj {\n\t\tuint256 dstGasForCall;\n\t\tuint256 dstNativeAmount;\n\t\tbytes dstNativeAddr;\n\t}\n\n\tfunction addLiquidity(uint256 _poolId, uint256 _amountLD, address _to) external;\n\n\tfunction swap(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress,\n\t\tuint256 _amountLD,\n\t\tuint256 _minAmountLD,\n\t\tlzTxObj memory _lzTxParams,\n\t\tbytes calldata _to,\n\t\tbytes calldata _payload\n\t) external payable;\n\n\tfunction redeemRemote(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress,\n\t\tuint256 _amountLP,\n\t\tuint256 _minAmountLD,\n\t\tbytes calldata _to,\n\t\tlzTxObj memory _lzTxParams\n\t) external payable;\n\n\tfunction instantRedeemLocal(uint16 _srcPoolId, uint256 _amountLP, address _to) external returns (uint256);\n\n\tfunction redeemLocal(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress,\n\t\tuint256 _amountLP,\n\t\tbytes calldata _to,\n\t\tlzTxObj memory _lzTxParams\n\t) external payable;\n\n\tfunction sendCredits(\n\t\tuint16 _dstChainId,\n\t\tuint256 _srcPoolId,\n\t\tuint256 _dstPoolId,\n\t\taddress payable _refundAddress\n\t) external payable;\n\n\tfunction quoteLayerZeroFee(\n\t\tuint16 _dstChainId,\n\t\tuint8 _functionType,\n\t\tbytes calldata _toAddress,\n\t\tbytes calldata _transferAndCallPayload,\n\t\tlzTxObj memory _lzTxParams\n\t) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/IUiPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\ninterface IUiPoolDataProvider {\n\tstruct AggregatedReserveData {\n\t\taddress underlyingAsset;\n\t\tstring name;\n\t\tstring symbol;\n\t\tuint256 decimals;\n\t\tuint256 baseLTVasCollateral;\n\t\tuint256 reserveLiquidationThreshold;\n\t\tuint256 reserveLiquidationBonus;\n\t\tuint256 reserveFactor;\n\t\tbool usageAsCollateralEnabled;\n\t\tbool borrowingEnabled;\n\t\tbool stableBorrowRateEnabled;\n\t\tbool isActive;\n\t\tbool isFrozen;\n\t\t// base data\n\t\tuint128 liquidityIndex;\n\t\tuint128 variableBorrowIndex;\n\t\tuint128 liquidityRate;\n\t\tuint128 variableBorrowRate;\n\t\tuint128 stableBorrowRate;\n\t\tuint40 lastUpdateTimestamp;\n\t\taddress aTokenAddress;\n\t\taddress stableDebtTokenAddress;\n\t\taddress variableDebtTokenAddress;\n\t\taddress interestRateStrategyAddress;\n\t\t//\n\t\tuint256 availableLiquidity;\n\t\tuint256 totalPrincipalStableDebt;\n\t\tuint256 averageStableRate;\n\t\tuint256 stableDebtLastUpdateTimestamp;\n\t\tuint256 totalScaledVariableDebt;\n\t\tuint256 priceInEth;\n\t\tuint256 variableRateSlope1;\n\t\tuint256 variableRateSlope2;\n\t\tuint256 stableRateSlope1;\n\t\tuint256 stableRateSlope2;\n\t\t// incentives\n\t\tuint256 aEmissionPerSecond;\n\t\tuint256 vEmissionPerSecond;\n\t\tuint256 sEmissionPerSecond;\n\t\tuint256 aIncentivesLastUpdateTimestamp;\n\t\tuint256 vIncentivesLastUpdateTimestamp;\n\t\tuint256 sIncentivesLastUpdateTimestamp;\n\t\tuint256 aTokenIncentivesIndex;\n\t\tuint256 vTokenIncentivesIndex;\n\t\tuint256 sTokenIncentivesIndex;\n\t}\n\n\tstruct UserReserveData {\n\t\taddress underlyingAsset;\n\t\tuint256 scaledATokenBalance;\n\t\tbool usageAsCollateralEnabledOnUser;\n\t\tuint256 stableBorrowRate;\n\t\tuint256 scaledVariableDebt;\n\t\tuint256 principalStableDebt;\n\t\tuint256 stableBorrowLastUpdateTimestamp;\n\t\t// incentives\n\t\tuint256 aTokenincentivesUserIndex;\n\t\tuint256 vTokenincentivesUserIndex;\n\t\tuint256 sTokenincentivesUserIndex;\n\t}\n\n\tstruct IncentivesControllerData {\n\t\tuint256 userUnclaimedRewards;\n\t\tuint256 emissionEndTimestamp;\n\t}\n\n\tfunction getReservesData(\n\t\tILendingPoolAddressesProvider provider,\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (AggregatedReserveData[] memory, UserReserveData[] memory, uint256, IncentivesControllerData memory);\n}\n"
    },
    "contracts/interfaces/IUiPoolDataProviderV3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from \"./ILendingPoolAddressesProvider.sol\";\n\ninterface IUiPoolDataProviderV3 {\n\tstruct AggregatedReserveData {\n\t\taddress underlyingAsset;\n\t\tstring name;\n\t\tstring symbol;\n\t\tuint256 decimals;\n\t\tuint256 baseLTVasCollateral;\n\t\tuint256 reserveLiquidationThreshold;\n\t\tuint256 reserveLiquidationBonus;\n\t\tuint256 reserveFactor;\n\t\tbool usageAsCollateralEnabled;\n\t\tbool borrowingEnabled;\n\t\tbool stableBorrowRateEnabled;\n\t\tbool isActive;\n\t\tbool isFrozen;\n\t\t// base data\n\t\tuint128 liquidityIndex;\n\t\tuint128 variableBorrowIndex;\n\t\tuint128 liquidityRate;\n\t\tuint128 variableBorrowRate;\n\t\tuint128 stableBorrowRate;\n\t\tuint40 lastUpdateTimestamp;\n\t\taddress aTokenAddress;\n\t\taddress stableDebtTokenAddress;\n\t\taddress variableDebtTokenAddress;\n\t\taddress interestRateStrategyAddress;\n\t\t//\n\t\tuint256 availableLiquidity;\n\t\tuint256 totalPrincipalStableDebt;\n\t\tuint256 averageStableRate;\n\t\tuint256 stableDebtLastUpdateTimestamp;\n\t\tuint256 totalScaledVariableDebt;\n\t\tuint256 priceInMarketReferenceCurrency;\n\t\tuint256 variableRateSlope1;\n\t\tuint256 variableRateSlope2;\n\t\tuint256 stableRateSlope1;\n\t\tuint256 stableRateSlope2;\n\t\t// v3\n\t\tbool isPaused;\n\t\tuint128 accruedToTreasury;\n\t\tuint128 unbacked;\n\t\tuint128 isolationModeTotalDebt;\n\t\t//\n\t\tuint256 debtCeiling;\n\t\tuint256 debtCeilingDecimals;\n\t\tuint8 eModeCategoryId;\n\t\tuint256 borrowCap;\n\t\tuint256 supplyCap;\n\t\t// eMode\n\t\tuint16 eModeLtv;\n\t\tuint16 eModeLiquidationThreshold;\n\t\tuint16 eModeLiquidationBonus;\n\t\taddress eModePriceSource;\n\t\tstring eModeLabel;\n\t\tbool borrowableInIsolation;\n\t}\n\n\tstruct UserReserveData {\n\t\taddress underlyingAsset;\n\t\tuint256 scaledATokenBalance;\n\t\tbool usageAsCollateralEnabledOnUser;\n\t\tuint256 stableBorrowRate;\n\t\tuint256 scaledVariableDebt;\n\t\tuint256 principalStableDebt;\n\t\tuint256 stableBorrowLastUpdateTimestamp;\n\t}\n\n\tstruct BaseCurrencyInfo {\n\t\tuint256 marketReferenceCurrencyUnit;\n\t\tint256 marketReferenceCurrencyPriceInUsd;\n\t\tint256 networkBaseTokenPriceInUsd;\n\t\tuint8 networkBaseTokenPriceDecimals;\n\t}\n\n\tfunction getReservesList(ILendingPoolAddressesProvider provider) external view returns (address[] memory);\n\n\tfunction getReservesData(\n\t\tILendingPoolAddressesProvider provider\n\t) external view returns (AggregatedReserveData[] memory, BaseCurrencyInfo memory);\n\n\tfunction getUserReservesData(\n\t\tILendingPoolAddressesProvider provider,\n\t\taddress user\n\t) external view returns (UserReserveData[] memory, uint8);\n}\n"
    },
    "contracts/interfaces/IUniV2TwapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IUniV2TwapOracle {\n\tfunction latestAnswer() external view returns (uint256 price);\n\n\tfunction latestAnswerInEth() external view returns (uint256 price);\n\n\tfunction update() external;\n\n\tfunction canUpdate() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IVariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {IScaledBalanceToken} from \"./IScaledBalanceToken.sol\";\nimport {IInitializableDebtToken} from \"./IInitializableDebtToken.sol\";\nimport {IAaveIncentivesController} from \"./IAaveIncentivesController.sol\";\n\n/**\n * @title IVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface for a variable debt token.\n **/\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\n\t/**\n\t * @dev Emitted after the mint action\n\t * @param from The address performing the mint\n\t * @param onBehalfOf The address of the user on which behalf minting has been performed\n\t * @param value The amount to be minted\n\t * @param index The last index of the reserve\n\t **/\n\tevent Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\n\n\t/**\n\t * @dev Mints debt token to the `onBehalfOf` address\n\t * @param user The address receiving the borrowed underlying, being the delegatee in case\n\t * of credit delegate, or same as `onBehalfOf` otherwise\n\t * @param onBehalfOf The address receiving the debt tokens\n\t * @param amount The amount of debt being minted\n\t * @param index The variable debt index of the reserve\n\t * @return `true` if the the previous balance of the user is 0\n\t **/\n\tfunction mint(address user, address onBehalfOf, uint256 amount, uint256 index) external returns (bool);\n\n\t/**\n\t * @dev Emitted when variable debt is burnt\n\t * @param user The user which debt has been burned\n\t * @param amount The amount of debt being burned\n\t * @param index The index of the user\n\t **/\n\tevent Burn(address indexed user, uint256 amount, uint256 index);\n\n\t/**\n\t * @dev Burns user variable debt\n\t * @param user The user which debt is burnt\n\t * @param index The variable debt index of the reserve\n\t **/\n\tfunction burn(address user, uint256 amount, uint256 index) external;\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view returns (IAaveIncentivesController);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IWETH {\n\tfunction balanceOf(address) external returns (uint);\n\n\tfunction deposit() external payable;\n\n\tfunction withdraw(uint256) external;\n\n\tfunction approve(address guy, uint256 wad) external returns (bool);\n\n\tfunction transferFrom(address src, address dst, uint256 wad) external returns (bool);\n\n\tfunction transfer(address to, uint value) external returns (bool);\n\n\tfunction allowance(address owner, address spender) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IWETHGateway.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IWETHGateway {\n\tfunction depositETH(address lendingPool, address onBehalfOf, uint16 referralCode) external payable;\n\n\tfunction withdrawETH(address lendingPool, uint256 amount, address onBehalfOf) external;\n\n\tfunction repayETH(address lendingPool, uint256 amount, uint256 rateMode, address onBehalfOf) external payable;\n\n\tfunction borrowETH(address lendingPool, uint256 amount, uint256 interesRateMode, uint16 referralCode) external;\n}\n"
    },
    "contracts/interfaces/LockedBalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\npragma abicoder v2;\n\nstruct LockedBalance {\n\tuint256 amount;\n\tuint256 unlockTime;\n\tuint256 multiplier;\n\tuint256 duration;\n}\n\nstruct EarnedBalance {\n\tuint256 amount;\n\tuint256 unlockTime;\n\tuint256 penalty;\n}\n\nstruct Reward {\n\tuint256 periodFinish;\n\tuint256 rewardPerSecond;\n\tuint256 lastUpdateTime;\n\tuint256 rewardPerTokenStored;\n\t// tracks already-added balances to handle accrued interest in aToken rewards\n\t// for the stakingToken this value is unused and will always be 0\n\tuint256 balance;\n}\n\nstruct Balances {\n\tuint256 total; // sum of earnings and lockings; no use when LP and RDNT is different\n\tuint256 unlocked; // RDNT token\n\tuint256 locked; // LP token or RDNT token\n\tuint256 lockedWithMultiplier; // Multiplied locked amount\n\tuint256 earned; // RDNT token\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IUniswapV2Factory {\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n\tfunction feeTo() external view returns (address);\n\n\tfunction feeToSetter() external view returns (address);\n\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n\n\tfunction allPairs(uint) external view returns (address pair);\n\n\tfunction allPairsLength() external view returns (uint);\n\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n\n\tfunction setFeeTo(address) external;\n\n\tfunction setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IUniswapV2Pair {\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\n\tfunction name() external pure returns (string memory);\n\n\tfunction symbol() external pure returns (string memory);\n\n\tfunction decimals() external pure returns (uint8);\n\n\tfunction totalSupply() external view returns (uint);\n\n\tfunction balanceOf(address owner) external view returns (uint);\n\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\n\tfunction approve(address spender, uint value) external returns (bool);\n\n\tfunction transfer(address to, uint value) external returns (bool);\n\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\n\tfunction nonces(address owner) external view returns (uint);\n\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n\tevent Mint(address indexed sender, uint amount0, uint amount1);\n\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n\tevent Swap(\n\t\taddress indexed sender,\n\t\tuint amount0In,\n\t\tuint amount1In,\n\t\tuint amount0Out,\n\t\tuint amount1Out,\n\t\taddress indexed to\n\t);\n\tevent Sync(uint112 reserve0, uint112 reserve1);\n\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n\n\tfunction factory() external view returns (address);\n\n\tfunction token0() external view returns (address);\n\n\tfunction token1() external view returns (address);\n\n\tfunction getReserves() external view returns (uint256 reserve0, uint256 reserve1, uint256 blockTimestampLast);\n\n\tfunction price0CumulativeLast() external view returns (uint);\n\n\tfunction price1CumulativeLast() external view returns (uint);\n\n\tfunction kLast() external view returns (uint);\n\n\tfunction mint(address to) external returns (uint liquidity);\n\n\tfunction burn(address to) external returns (uint amount0, uint amount1);\n\n\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\n\tfunction skim(address to) external;\n\n\tfunction sync() external;\n\n\tfunction initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\ninterface IUniswapV2Router01 {\n\tfunction factory() external pure returns (address);\n\n\tfunction WETH() external pure returns (address);\n\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint amountADesired,\n\t\tuint amountBDesired,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountA, uint amountB, uint liquidity);\n\n\tfunction addLiquidityETH(\n\t\taddress token,\n\t\tuint amountTokenDesired,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint liquidity,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountA, uint amountB);\n\n\tfunction removeLiquidityETH(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountToken, uint amountETH);\n\n\tfunction removeLiquidityWithPermit(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint liquidity,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint amountA, uint amountB);\n\n\tfunction removeLiquidityETHWithPermit(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint amountToken, uint amountETH);\n\n\tfunction swapExactTokensForTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapTokensForExactTokens(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapExactETHForTokens(\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable returns (uint[] memory amounts);\n\n\tfunction swapTokensForExactETH(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapExactTokensForETH(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\n\tfunction swapETHForExactTokens(\n\t\tuint amountOut,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable returns (uint[] memory amounts);\n\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountETH);\n\n\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint amountETH);\n\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external;\n\n\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable;\n\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external;\n}\n"
    },
    "contracts/interfaces/uniswap/IWETH.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.5.0;\n\ninterface IWETH {\n\tfunction deposit() external payable;\n\n\tfunction transfer(address to, uint value) external returns (bool);\n\n\tfunction withdraw(uint) external;\n\n\tfunction balanceOf(address) external returns (uint);\n}\n"
    },
    "contracts/lending/AaveOracle.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IChainlinkAggregator} from \"../interfaces/IChainlinkAggregator.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title AaveOracle\n/// @author Aave\n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Aggregator\n///         smart contracts as primary option\n/// - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallbackOracle\n/// - Owned by the Aave governance system, allowed to add sources for assets, replace them\n///   and change the fallbackOracle\ncontract AaveOracle is IPriceOracleGetter, Ownable {\n    using SafeERC20 for IERC20;\n\n    event BaseCurrencySet(\n        address indexed baseCurrency,\n        uint256 baseCurrencyUnit\n    );\n    event AssetSourceUpdated(address indexed asset, address indexed source);\n    event FallbackOracleUpdated(address indexed fallbackOracle);\n\n    mapping(address => IChainlinkAggregator) private assetsSources;\n    IPriceOracleGetter private _fallbackOracle;\n    address public immutable BASE_CURRENCY;\n    uint256 public immutable BASE_CURRENCY_UNIT;\n\n    /// @notice Constructor\n    /// @param assets The addresses of the assets\n    /// @param sources The address of the source` of each asset\n    /// @param fallbackOracle The address of the fallback oracle to use if the data of an\n    ///        aggregator is not consistent\n    /// @param baseCurrency the base currency used for the price quotes. If USD is used, base currency is 0x0\n    /// @param baseCurrencyUnit the unit of the base currency\n    constructor(\n        address[] memory assets,\n        address[] memory sources,\n        address fallbackOracle,\n        address baseCurrency,\n        uint256 baseCurrencyUnit\n    ) {\n        _setFallbackOracle(fallbackOracle);\n        _setAssetsSources(assets, sources);\n        BASE_CURRENCY = baseCurrency;\n        BASE_CURRENCY_UNIT = baseCurrencyUnit;\n        emit BaseCurrencySet(baseCurrency, baseCurrencyUnit);\n    }\n\n    /// @notice External function called by the Aave governance to set or replace sources of assets\n    /// @param assets The addresses of the assets\n    /// @param sources The address of the source of each asset\n    function setAssetSources(\n        address[] calldata assets,\n        address[] calldata sources\n    ) external onlyOwner {\n        _setAssetsSources(assets, sources);\n    }\n\n    /// @notice Sets the fallbackOracle\n    /// - Callable only by the Aave governance\n    /// @param fallbackOracle The address of the fallbackOracle\n    function setFallbackOracle(address fallbackOracle) external onlyOwner {\n        _setFallbackOracle(fallbackOracle);\n    }\n\n    /// @notice Internal function to set the sources for each asset\n    /// @param assets The addresses of the assets\n    /// @param sources The address of the source of each asset\n    function _setAssetsSources(\n        address[] memory assets,\n        address[] memory sources\n    ) internal {\n        require(assets.length == sources.length, \"INCONSISTENT_PARAMS_LENGTH\");\n        for (uint256 i = 0; i < assets.length; i++) {\n            assetsSources[assets[i]] = IChainlinkAggregator(sources[i]);\n            emit AssetSourceUpdated(assets[i], sources[i]);\n        }\n    }\n\n    /// @notice Internal function to set the fallbackOracle\n    /// @param fallbackOracle The address of the fallbackOracle\n    function _setFallbackOracle(address fallbackOracle) internal {\n        _fallbackOracle = IPriceOracleGetter(fallbackOracle);\n        emit FallbackOracleUpdated(fallbackOracle);\n    }\n\n    /// @notice Gets an asset price by address\n    /// @param asset The asset address\n    function getAssetPrice(\n        address asset\n    ) public view override returns (uint256) {\n        IChainlinkAggregator source = assetsSources[asset];\n\n        if (asset == BASE_CURRENCY) {\n            return BASE_CURRENCY_UNIT;\n        } else if (address(source) == address(0)) {\n            return _fallbackOracle.getAssetPrice(asset);\n        } else {\n            int256 price = IChainlinkAggregator(source).latestAnswer();\n            if (price > 0) {\n                return uint256(price);\n            } else {\n                return _fallbackOracle.getAssetPrice(asset);\n            }\n        }\n    }\n\n    /// @notice Gets a list of prices from a list of assets addresses\n    /// @param assets The list of assets addresses\n    function getAssetsPrices(\n        address[] calldata assets\n    ) external view returns (uint256[] memory) {\n        uint256[] memory prices = new uint256[](assets.length);\n        for (uint256 i = 0; i < assets.length; i++) {\n            prices[i] = getAssetPrice(assets[i]);\n        }\n        return prices;\n    }\n\n    /// @notice Gets the address of the source for an asset address\n    /// @param asset The address of the asset\n    /// @return address The address of the source\n    function getSourceOfAsset(address asset) external view returns (address) {\n        return address(assetsSources[asset]);\n    }\n\n    /// @notice Gets the address of the fallback oracle\n    /// @return address The addres of the fallback oracle\n    function getFallbackOracle() external view returns (address) {\n        return address(_fallbackOracle);\n    }\n}\n"
    },
    "contracts/lending/AaveProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ILendingPoolAddressesProvider} from \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport {IStableDebtToken} from \"../interfaces/IStableDebtToken.sol\";\nimport {IVariableDebtToken} from \"../interfaces/IVariableDebtToken.sol\";\nimport {ReserveConfiguration} from \"./libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"./libraries/configuration/UserConfiguration.sol\";\nimport {DataTypes} from \"./libraries/types/DataTypes.sol\";\n\ncontract AaveProtocolDataProvider {\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\taddress constant MKR = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n\taddress constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\tstruct TokenData {\n\t\tstring symbol;\n\t\taddress tokenAddress;\n\t}\n\n\tILendingPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n\n\tconstructor(ILendingPoolAddressesProvider addressesProvider) {\n\t\tADDRESSES_PROVIDER = addressesProvider;\n\t}\n\n\tfunction getAllReservesTokens() external view returns (TokenData[] memory) {\n\t\tILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool());\n\t\taddress[] memory reserves = pool.getReservesList();\n\t\tTokenData[] memory reservesTokens = new TokenData[](reserves.length);\n\t\tfor (uint256 i = 0; i < reserves.length; i++) {\n\t\t\tif (reserves[i] == MKR) {\n\t\t\t\treservesTokens[i] = TokenData({symbol: \"MKR\", tokenAddress: reserves[i]});\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (reserves[i] == ETH) {\n\t\t\t\treservesTokens[i] = TokenData({symbol: \"ETH\", tokenAddress: reserves[i]});\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treservesTokens[i] = TokenData({symbol: IERC20Metadata(reserves[i]).symbol(), tokenAddress: reserves[i]});\n\t\t}\n\t\treturn reservesTokens;\n\t}\n\n\tfunction getAllATokens() external view returns (TokenData[] memory) {\n\t\tILendingPool pool = ILendingPool(ADDRESSES_PROVIDER.getLendingPool());\n\t\taddress[] memory reserves = pool.getReservesList();\n\t\tTokenData[] memory aTokens = new TokenData[](reserves.length);\n\t\tfor (uint256 i = 0; i < reserves.length; i++) {\n\t\t\tDataTypes.ReserveData memory reserveData = pool.getReserveData(reserves[i]);\n\t\t\taTokens[i] = TokenData({\n\t\t\t\tsymbol: IERC20Metadata(reserveData.aTokenAddress).symbol(),\n\t\t\t\ttokenAddress: reserveData.aTokenAddress\n\t\t\t});\n\t\t}\n\t\treturn aTokens;\n\t}\n\n\tfunction getReserveConfigurationData(\n\t\taddress asset\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 decimals,\n\t\t\tuint256 ltv,\n\t\t\tuint256 liquidationThreshold,\n\t\t\tuint256 liquidationBonus,\n\t\t\tuint256 reserveFactor,\n\t\t\tbool usageAsCollateralEnabled,\n\t\t\tbool borrowingEnabled,\n\t\t\tbool stableBorrowRateEnabled,\n\t\t\tbool isActive,\n\t\t\tbool isFrozen\n\t\t)\n\t{\n\t\tDataTypes.ReserveConfigurationMap memory configuration = ILendingPool(ADDRESSES_PROVIDER.getLendingPool())\n\t\t\t.getConfiguration(asset);\n\n\t\t(ltv, liquidationThreshold, liquidationBonus, decimals, reserveFactor) = configuration.getParamsMemory();\n\n\t\t(isActive, isFrozen, borrowingEnabled, stableBorrowRateEnabled) = configuration.getFlagsMemory();\n\n\t\tusageAsCollateralEnabled = liquidationThreshold > 0;\n\t}\n\n\tfunction getReserveData(\n\t\taddress asset\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 availableLiquidity,\n\t\t\tuint256 totalStableDebt,\n\t\t\tuint256 totalVariableDebt,\n\t\t\tuint256 liquidityRate,\n\t\t\tuint256 variableBorrowRate,\n\t\t\tuint256 stableBorrowRate,\n\t\t\tuint256 averageStableBorrowRate,\n\t\t\tuint256 liquidityIndex,\n\t\t\tuint256 variableBorrowIndex,\n\t\t\tuint40 lastUpdateTimestamp\n\t\t)\n\t{\n\t\tDataTypes.ReserveData memory reserve = ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\n\n\t\treturn (\n\t\t\tIERC20Metadata(asset).balanceOf(reserve.aTokenAddress),\n\t\t\tIERC20Metadata(reserve.stableDebtTokenAddress).totalSupply(),\n\t\t\tIERC20Metadata(reserve.variableDebtTokenAddress).totalSupply(),\n\t\t\treserve.currentLiquidityRate,\n\t\t\treserve.currentVariableBorrowRate,\n\t\t\treserve.currentStableBorrowRate,\n\t\t\tIStableDebtToken(reserve.stableDebtTokenAddress).getAverageStableRate(),\n\t\t\treserve.liquidityIndex,\n\t\t\treserve.variableBorrowIndex,\n\t\t\treserve.lastUpdateTimestamp\n\t\t);\n\t}\n\n\tfunction getUserReserveData(\n\t\taddress asset,\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 currentATokenBalance,\n\t\t\tuint256 currentStableDebt,\n\t\t\tuint256 currentVariableDebt,\n\t\t\tuint256 principalStableDebt,\n\t\t\tuint256 scaledVariableDebt,\n\t\t\tuint256 stableBorrowRate,\n\t\t\tuint256 liquidityRate,\n\t\t\tuint40 stableRateLastUpdated,\n\t\t\tbool usageAsCollateralEnabled\n\t\t)\n\t{\n\t\tDataTypes.ReserveData memory reserve = ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\n\n\t\tDataTypes.UserConfigurationMap memory userConfig = ILendingPool(ADDRESSES_PROVIDER.getLendingPool())\n\t\t\t.getUserConfiguration(user);\n\n\t\tcurrentATokenBalance = IERC20Metadata(reserve.aTokenAddress).balanceOf(user);\n\t\tcurrentVariableDebt = IERC20Metadata(reserve.variableDebtTokenAddress).balanceOf(user);\n\t\tcurrentStableDebt = IERC20Metadata(reserve.stableDebtTokenAddress).balanceOf(user);\n\t\tprincipalStableDebt = IStableDebtToken(reserve.stableDebtTokenAddress).principalBalanceOf(user);\n\t\tscaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user);\n\t\tliquidityRate = reserve.currentLiquidityRate;\n\t\tstableBorrowRate = IStableDebtToken(reserve.stableDebtTokenAddress).getUserStableRate(user);\n\t\tstableRateLastUpdated = IStableDebtToken(reserve.stableDebtTokenAddress).getUserLastUpdated(user);\n\t\tusageAsCollateralEnabled = userConfig.isUsingAsCollateral(reserve.id);\n\t}\n\n\tfunction getReserveTokensAddresses(\n\t\taddress asset\n\t) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress) {\n\t\tDataTypes.ReserveData memory reserve = ILendingPool(ADDRESSES_PROVIDER.getLendingPool()).getReserveData(asset);\n\n\t\treturn (reserve.aTokenAddress, reserve.stableDebtTokenAddress, reserve.variableDebtTokenAddress);\n\t}\n}\n"
    },
    "contracts/lending/ATokensAndRatesHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {LendingPool} from \"./lendingpool/LendingPool.sol\";\nimport {LendingPoolAddressesProvider} from \"./configuration/LendingPoolAddressesProvider.sol\";\nimport {LendingPoolConfigurator} from \"./lendingpool/LendingPoolConfigurator.sol\";\nimport {AToken} from \"./tokenization/AToken.sol\";\nimport {DefaultReserveInterestRateStrategy} from \"./lendingpool/DefaultReserveInterestRateStrategy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ATokensAndRatesHelper is Ownable {\n\taddress payable private pool;\n\taddress private addressesProvider;\n\taddress private poolConfigurator;\n\tevent deployedContracts(address aToken, address strategy);\n\n\tstruct InitDeploymentInput {\n\t\taddress asset;\n\t\tuint256[6] rates;\n\t}\n\n\tstruct ConfigureReserveInput {\n\t\taddress asset;\n\t\tuint256 baseLTV;\n\t\tuint256 liquidationThreshold;\n\t\tuint256 liquidationBonus;\n\t\tuint256 reserveFactor;\n\t\tbool stableBorrowingEnabled;\n\t\tbool borrowingEnabled;\n\t}\n\n\tconstructor(address payable _pool, address _addressesProvider, address _poolConfigurator) {\n\t\tpool = _pool;\n\t\taddressesProvider = _addressesProvider;\n\t\tpoolConfigurator = _poolConfigurator;\n\t}\n\n\tfunction initDeployment(InitDeploymentInput[] calldata inputParams) external onlyOwner {\n\t\tfor (uint256 i = 0; i < inputParams.length; i++) {\n\t\t\temit deployedContracts(\n\t\t\t\taddress(new AToken()),\n\t\t\t\taddress(\n\t\t\t\t\tnew DefaultReserveInterestRateStrategy(\n\t\t\t\t\t\tLendingPoolAddressesProvider(addressesProvider),\n\t\t\t\t\t\tinputParams[i].rates[0],\n\t\t\t\t\t\tinputParams[i].rates[1],\n\t\t\t\t\t\tinputParams[i].rates[2],\n\t\t\t\t\t\tinputParams[i].rates[3],\n\t\t\t\t\t\tinputParams[i].rates[4],\n\t\t\t\t\t\tinputParams[i].rates[5]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction configureReserves(ConfigureReserveInput[] calldata inputParams) external onlyOwner {\n\t\tLendingPoolConfigurator configurator = LendingPoolConfigurator(poolConfigurator);\n\t\tfor (uint256 i = 0; i < inputParams.length; i++) {\n\t\t\tconfigurator.configureReserveAsCollateral(\n\t\t\t\tinputParams[i].asset,\n\t\t\t\tinputParams[i].baseLTV,\n\t\t\t\tinputParams[i].liquidationThreshold,\n\t\t\t\tinputParams[i].liquidationBonus\n\t\t\t);\n\n\t\t\tif (inputParams[i].borrowingEnabled) {\n\t\t\t\tconfigurator.enableBorrowingOnReserve(inputParams[i].asset, inputParams[i].stableBorrowingEnabled);\n\t\t\t}\n\t\t\tconfigurator.setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor);\n\t\t}\n\t}\n}\n"
    },
    "contracts/lending/configuration/LendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Prettier ignore to prevent buidler flatter bug\n// prettier-ignore\nimport {InitializableImmutableAdminUpgradeabilityProxy} from '../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol';\n\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider {\n\tstring private _marketId;\n\tmapping(bytes32 => address) private _addresses;\n\taddress private _liquidationFeeTo;\n\n\tbytes32 private constant LENDING_POOL = \"LENDING_POOL\";\n\tbytes32 private constant LENDING_POOL_CONFIGURATOR = \"LENDING_POOL_CONFIGURATOR\";\n\tbytes32 private constant POOL_ADMIN = \"POOL_ADMIN\";\n\tbytes32 private constant EMERGENCY_ADMIN = \"EMERGENCY_ADMIN\";\n\tbytes32 private constant LENDING_POOL_COLLATERAL_MANAGER = \"COLLATERAL_MANAGER\";\n\tbytes32 private constant PRICE_ORACLE = \"PRICE_ORACLE\";\n\tbytes32 private constant LENDING_RATE_ORACLE = \"LENDING_RATE_ORACLE\";\n\n\tconstructor(string memory marketId) {\n\t\t_setMarketId(marketId);\n\t\t_liquidationFeeTo = 0xF90C69D16599A5C657A05Fe76Cd22fD9Cab44598;\n\t}\n\n\t/**\n\t * @dev Returns the id of the Aave market to which this contracts points to\n\t * @return The market id\n\t **/\n\tfunction getMarketId() external view override returns (string memory) {\n\t\treturn _marketId;\n\t}\n\n\t/**\n\t * @dev Allows to set the market which this LendingPoolAddressesProvider represents\n\t * @param marketId The market id\n\t */\n\tfunction setMarketId(string memory marketId) external override onlyOwner {\n\t\t_setMarketId(marketId);\n\t}\n\n\t/**\n\t * @dev General function to update the implementation of a proxy registered with\n\t * certain `id`. If there is no proxy registered, it will instantiate one and\n\t * set as implementation the `implementationAddress`\n\t * IMPORTANT Use this function carefully, only for ids that don't have an explicit\n\t * setter function, in order to avoid unexpected consequences\n\t * @param id The id\n\t * @param implementationAddress The address of the new implementation\n\t */\n\tfunction setAddressAsProxy(bytes32 id, address implementationAddress) external override onlyOwner {\n\t\t_updateImpl(id, implementationAddress);\n\t\temit AddressSet(id, implementationAddress, true);\n\t}\n\n\t/**\n\t * @dev Sets an address for an id replacing the address saved in the addresses map\n\t * IMPORTANT Use this function carefully, as it will do a hard replacement\n\t * @param id The id\n\t * @param newAddress The address to set\n\t */\n\tfunction setAddress(bytes32 id, address newAddress) external override onlyOwner {\n\t\t_addresses[id] = newAddress;\n\t\temit AddressSet(id, newAddress, false);\n\t}\n\n\t/**\n\t * @dev Returns an address by id\n\t * @return The address\n\t */\n\tfunction getAddress(bytes32 id) public view override returns (address) {\n\t\treturn _addresses[id];\n\t}\n\n\t/**\n\t * @dev Returns the address of the LendingPool proxy\n\t * @return The LendingPool proxy address\n\t **/\n\tfunction getLendingPool() external view override returns (address) {\n\t\treturn getAddress(LENDING_POOL);\n\t}\n\n\t/**\n\t * @dev Updates the implementation of the LendingPool, or creates the proxy\n\t * setting the new `pool` implementation on the first time calling it\n\t * @param pool The new LendingPool implementation\n\t **/\n\tfunction setLendingPoolImpl(address pool) external override onlyOwner {\n\t\t_updateImpl(LENDING_POOL, pool);\n\t\temit LendingPoolUpdated(pool);\n\t}\n\n\t/**\n\t * @dev Returns the address of the LendingPoolConfigurator proxy\n\t * @return The LendingPoolConfigurator proxy address\n\t **/\n\tfunction getLendingPoolConfigurator() external view override returns (address) {\n\t\treturn getAddress(LENDING_POOL_CONFIGURATOR);\n\t}\n\n\t/**\n\t * @dev Updates the implementation of the LendingPoolConfigurator, or creates the proxy\n\t * setting the new `configurator` implementation on the first time calling it\n\t * @param configurator The new LendingPoolConfigurator implementation\n\t **/\n\tfunction setLendingPoolConfiguratorImpl(address configurator) external override onlyOwner {\n\t\t_updateImpl(LENDING_POOL_CONFIGURATOR, configurator);\n\t\temit LendingPoolConfiguratorUpdated(configurator);\n\t}\n\n\t/**\n\t * @dev Returns the address of the LendingPoolCollateralManager. Since the manager is used\n\t * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\n\t * the addresses are changed directly\n\t * @return The address of the LendingPoolCollateralManager\n\t **/\n\n\tfunction getLendingPoolCollateralManager() external view override returns (address) {\n\t\treturn getAddress(LENDING_POOL_COLLATERAL_MANAGER);\n\t}\n\n\t/**\n\t * @dev Updates the address of the LendingPoolCollateralManager\n\t * @param manager The new LendingPoolCollateralManager address\n\t **/\n\tfunction setLendingPoolCollateralManager(address manager) external override onlyOwner {\n\t\t_addresses[LENDING_POOL_COLLATERAL_MANAGER] = manager;\n\t\temit LendingPoolCollateralManagerUpdated(manager);\n\t}\n\n\t/**\n\t * @dev The functions below are getters/setters of addresses that are outside the context\n\t * of the protocol hence the upgradable proxy pattern is not used\n\t **/\n\n\tfunction getPoolAdmin() external view override returns (address) {\n\t\treturn getAddress(POOL_ADMIN);\n\t}\n\n\tfunction setPoolAdmin(address admin) external override onlyOwner {\n\t\t_addresses[POOL_ADMIN] = admin;\n\t\temit ConfigurationAdminUpdated(admin);\n\t}\n\n\tfunction getEmergencyAdmin() external view override returns (address) {\n\t\treturn getAddress(EMERGENCY_ADMIN);\n\t}\n\n\tfunction setEmergencyAdmin(address emergencyAdmin) external override onlyOwner {\n\t\t_addresses[EMERGENCY_ADMIN] = emergencyAdmin;\n\t\temit EmergencyAdminUpdated(emergencyAdmin);\n\t}\n\n\tfunction getPriceOracle() external view override returns (address) {\n\t\treturn getAddress(PRICE_ORACLE);\n\t}\n\n\tfunction setPriceOracle(address priceOracle) external override onlyOwner {\n\t\t_addresses[PRICE_ORACLE] = priceOracle;\n\t\temit PriceOracleUpdated(priceOracle);\n\t}\n\n\tfunction getLendingRateOracle() external view override returns (address) {\n\t\treturn getAddress(LENDING_RATE_ORACLE);\n\t}\n\n\tfunction setLendingRateOracle(address lendingRateOracle) external override onlyOwner {\n\t\t_addresses[LENDING_RATE_ORACLE] = lendingRateOracle;\n\t\temit LendingRateOracleUpdated(lendingRateOracle);\n\t}\n\n\tfunction getLiquidationFeeTo() external view override returns (address) {\n\t\treturn _liquidationFeeTo;\n\t}\n\n\tfunction setLiquidationFeeTo(address liquidationFeeTo) external override onlyOwner {\n\t\t_liquidationFeeTo = liquidationFeeTo;\n\t}\n\n\t/**\n\t * @dev Internal function to update the implementation of a specific proxied component of the protocol\n\t * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress`\n\t *   as implementation and calls the initialize() function on the proxy\n\t * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\n\t *   calls the initialize() function via upgradeToAndCall() in the proxy\n\t * @param id The id of the proxy to be updated\n\t * @param newAddress The address of the new implementation\n\t **/\n\tfunction _updateImpl(bytes32 id, address newAddress) internal {\n\t\taddress payable proxyAddress = payable(_addresses[id]);\n\n\t\tInitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(\n\t\t\tproxyAddress\n\t\t);\n\t\tbytes memory params = abi.encodeWithSignature(\"initialize(address)\", address(this));\n\n\t\tif (proxyAddress == address(0)) {\n\t\t\tproxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\n\t\t\tproxy.initialize(newAddress, params);\n\t\t\t_addresses[id] = address(proxy);\n\t\t\temit ProxyCreated(id, address(proxy));\n\t\t} else {\n\t\t\tproxy.upgradeToAndCall(newAddress, params);\n\t\t}\n\t}\n\n\tfunction _setMarketId(string memory marketId) internal {\n\t\t_marketId = marketId;\n\t\temit MarketIdSet(marketId);\n\t}\n}\n"
    },
    "contracts/lending/configuration/LendingPoolAddressesProviderRegistry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ILendingPoolAddressesProviderRegistry} from \"../../interfaces/ILendingPoolAddressesProviderRegistry.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\n\n/**\n * @title LendingPoolAddressesProviderRegistry contract\n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets\n * - Used for indexing purposes of Aave protocol's markets\n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with,\n *   for example with `0` for the Aave main market and `1` for the next created\n * @author Aave\n **/\ncontract LendingPoolAddressesProviderRegistry is Ownable, ILendingPoolAddressesProviderRegistry {\n\tmapping(address => uint256) private _addressesProviders;\n\taddress[] private _addressesProvidersList;\n\n\t/**\n\t * @dev Returns the list of registered addresses provider\n\t * @return The list of addresses provider, potentially containing address(0) elements\n\t **/\n\tfunction getAddressesProvidersList() external view override returns (address[] memory) {\n\t\taddress[] memory addressesProvidersList = _addressesProvidersList;\n\n\t\tuint256 maxLength = addressesProvidersList.length;\n\n\t\taddress[] memory activeProviders = new address[](maxLength);\n\n\t\tfor (uint256 i = 0; i < maxLength; i++) {\n\t\t\tif (_addressesProviders[addressesProvidersList[i]] > 0) {\n\t\t\t\tactiveProviders[i] = addressesProvidersList[i];\n\t\t\t}\n\t\t}\n\n\t\treturn activeProviders;\n\t}\n\n\t/**\n\t * @dev Registers an addresses provider\n\t * @param provider The address of the new LendingPoolAddressesProvider\n\t * @param id The id for the new LendingPoolAddressesProvider, referring to the market it belongs to\n\t **/\n\tfunction registerAddressesProvider(address provider, uint256 id) external override onlyOwner {\n\t\trequire(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID);\n\n\t\t_addressesProviders[provider] = id;\n\t\t_addToAddressesProvidersList(provider);\n\t\temit AddressesProviderRegistered(provider);\n\t}\n\n\t/**\n\t * @dev Removes a LendingPoolAddressesProvider from the list of registered addresses provider\n\t * @param provider The LendingPoolAddressesProvider address\n\t **/\n\tfunction unregisterAddressesProvider(address provider) external override onlyOwner {\n\t\trequire(_addressesProviders[provider] > 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED);\n\t\t_addressesProviders[provider] = 0;\n\t\temit AddressesProviderUnregistered(provider);\n\t}\n\n\t/**\n\t * @dev Returns the id on a registered LendingPoolAddressesProvider\n\t * @return The id or 0 if the LendingPoolAddressesProvider is not registered\n\t */\n\tfunction getAddressesProviderIdByAddress(address addressesProvider) external view override returns (uint256) {\n\t\treturn _addressesProviders[addressesProvider];\n\t}\n\n\tfunction _addToAddressesProvidersList(address provider) internal {\n\t\tuint256 providersCount = _addressesProvidersList.length;\n\n\t\tfor (uint256 i = 0; i < providersCount; i++) {\n\t\t\tif (_addressesProvidersList[i] == provider) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t_addressesProvidersList.push(provider);\n\t}\n}\n"
    },
    "contracts/lending/flashloan/base/FlashLoanReceiverBase.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IFlashLoanReceiver} from \"../interfaces/IFlashLoanReceiver.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../../../interfaces/ILendingPool.sol\";\n\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\tILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n\tILendingPool public immutable override LENDING_POOL;\n\n\tconstructor(ILendingPoolAddressesProvider provider) {\n\t\tADDRESSES_PROVIDER = provider;\n\t\tLENDING_POOL = ILendingPool(provider.getLendingPool());\n\t}\n}\n"
    },
    "contracts/lending/flashloan/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingPoolAddressesProvider} from \"../../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../../../interfaces/ILendingPool.sol\";\n\n/**\n * @title IFlashLoanReceiver interface\n * @notice Interface for the Aave fee IFlashLoanReceiver.\n * @author Aave\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n **/\ninterface IFlashLoanReceiver {\n\tfunction executeOperation(\n\t\taddress[] calldata assets,\n\t\tuint256[] calldata amounts,\n\t\tuint256[] calldata premiums,\n\t\taddress initiator,\n\t\tbytes calldata params\n\t) external returns (bool);\n\n\tfunction ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n\tfunction LENDING_POOL() external view returns (ILendingPool);\n}\n"
    },
    "contracts/lending/lendingpool/DefaultReserveInterestRateStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IReserveInterestRateStrategy} from \"../../interfaces/IReserveInterestRateStrategy.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingRateOracle} from \"../../interfaces/ILendingRateOracle.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title DefaultReserveInterestRateStrategy contract\n * @notice Implements the calculation of the interest rates depending on the reserve state\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_UTILIZATION_RATE`\n * point of utilization and another from that one to 100%\n * - An instance of this same contract, can't be used across different Aave markets, due to the caching\n *   of the LendingPoolAddressesProvider\n * @author Aave\n **/\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\n\tusing WadRayMath for uint256;\n\tusing SafeMath for uint256;\n\tusing PercentageMath for uint256;\n\n\t/**\n\t * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates.\n\t * Expressed in ray\n\t **/\n\tuint256 public immutable OPTIMAL_UTILIZATION_RATE;\n\n\t/**\n\t * @dev This constant represents the excess utilization rate above the optimal. It's always equal to\n\t * 1-optimal utilization rate. Added as a constant here for gas optimizations.\n\t * Expressed in ray\n\t **/\n\n\tuint256 public immutable EXCESS_UTILIZATION_RATE;\n\n\tILendingPoolAddressesProvider public immutable addressesProvider;\n\n\t// Base variable borrow rate when Utilization rate = 0. Expressed in ray\n\tuint256 internal immutable _baseVariableBorrowRate;\n\n\t// Slope of the variable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n\tuint256 internal immutable _variableRateSlope1;\n\n\t// Slope of the variable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n\tuint256 internal immutable _variableRateSlope2;\n\n\t// Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n\tuint256 internal immutable _stableRateSlope1;\n\n\t// Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n\tuint256 internal immutable _stableRateSlope2;\n\n\tconstructor(\n\t\tILendingPoolAddressesProvider provider,\n\t\tuint256 optimalUtilizationRate_,\n\t\tuint256 baseVariableBorrowRate_,\n\t\tuint256 variableRateSlope1_,\n\t\tuint256 variableRateSlope2_,\n\t\tuint256 stableRateSlope1_,\n\t\tuint256 stableRateSlope2_\n\t) {\n\t\tOPTIMAL_UTILIZATION_RATE = optimalUtilizationRate_;\n\t\tEXCESS_UTILIZATION_RATE = WadRayMath.ray().sub(optimalUtilizationRate_);\n\t\taddressesProvider = provider;\n\t\t_baseVariableBorrowRate = baseVariableBorrowRate_;\n\t\t_variableRateSlope1 = variableRateSlope1_;\n\t\t_variableRateSlope2 = variableRateSlope2_;\n\t\t_stableRateSlope1 = stableRateSlope1_;\n\t\t_stableRateSlope2 = stableRateSlope2_;\n\t}\n\n\tfunction variableRateSlope1() external view returns (uint256) {\n\t\treturn _variableRateSlope1;\n\t}\n\n\tfunction variableRateSlope2() external view returns (uint256) {\n\t\treturn _variableRateSlope2;\n\t}\n\n\tfunction stableRateSlope1() external view returns (uint256) {\n\t\treturn _stableRateSlope1;\n\t}\n\n\tfunction stableRateSlope2() external view returns (uint256) {\n\t\treturn _stableRateSlope2;\n\t}\n\n\tfunction baseVariableBorrowRate() external view override returns (uint256) {\n\t\treturn _baseVariableBorrowRate;\n\t}\n\n\tfunction getMaxVariableBorrowRate() external view override returns (uint256) {\n\t\treturn _baseVariableBorrowRate.add(_variableRateSlope1).add(_variableRateSlope2);\n\t}\n\n\t/**\n\t * @dev Calculates the interest rates depending on the reserve's state and configurations\n\t * @param reserve The address of the reserve\n\t * @param liquidityAdded The liquidity added during the operation\n\t * @param liquidityTaken The liquidity taken during the operation\n\t * @param totalStableDebt The total borrowed from the reserve a stable rate\n\t * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n\t * @param averageStableBorrowRate The weighted average of all the stable rate loans\n\t * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n\t * @return The liquidity rate, the stable borrow rate and the variable borrow rate\n\t **/\n\tfunction calculateInterestRates(\n\t\taddress reserve,\n\t\taddress aToken,\n\t\tuint256 liquidityAdded,\n\t\tuint256 liquidityTaken,\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 averageStableBorrowRate,\n\t\tuint256 reserveFactor\n\t) external view override returns (uint256, uint256, uint256) {\n\t\tuint256 availableLiquidity = IERC20(reserve).balanceOf(aToken);\n\t\t//avoid stack too deep\n\t\tavailableLiquidity = availableLiquidity.add(liquidityAdded).sub(liquidityTaken);\n\n\t\treturn\n\t\t\tcalculateInterestRates(\n\t\t\t\treserve,\n\t\t\t\tavailableLiquidity,\n\t\t\t\ttotalStableDebt,\n\t\t\t\ttotalVariableDebt,\n\t\t\t\taverageStableBorrowRate,\n\t\t\t\treserveFactor\n\t\t\t);\n\t}\n\n\tstruct CalcInterestRatesLocalVars {\n\t\tuint256 totalDebt;\n\t\tuint256 currentVariableBorrowRate;\n\t\tuint256 currentStableBorrowRate;\n\t\tuint256 currentLiquidityRate;\n\t\tuint256 utilizationRate;\n\t}\n\n\t/**\n\t * @dev Calculates the interest rates depending on the reserve's state and configurations.\n\t * NOTE This function is kept for compatibility with the previous DefaultInterestRateStrategy interface.\n\t * New protocol implementation uses the new calculateInterestRates() interface\n\t * @param reserve The address of the reserve\n\t * @param availableLiquidity The liquidity available in the corresponding aToken\n\t * @param totalStableDebt The total borrowed from the reserve a stable rate\n\t * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n\t * @param averageStableBorrowRate The weighted average of all the stable rate loans\n\t * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n\t * @return The liquidity rate, the stable borrow rate and the variable borrow rate\n\t **/\n\tfunction calculateInterestRates(\n\t\taddress reserve,\n\t\tuint256 availableLiquidity,\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 averageStableBorrowRate,\n\t\tuint256 reserveFactor\n\t) public view override returns (uint256, uint256, uint256) {\n\t\tCalcInterestRatesLocalVars memory vars;\n\n\t\tvars.totalDebt = totalStableDebt.add(totalVariableDebt);\n\t\tvars.currentVariableBorrowRate = 0;\n\t\tvars.currentStableBorrowRate = 0;\n\t\tvars.currentLiquidityRate = 0;\n\n\t\tvars.utilizationRate = vars.totalDebt == 0 ? 0 : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\n\n\t\tvars.currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle()).getMarketBorrowRate(\n\t\t\treserve\n\t\t);\n\n\t\tif (vars.utilizationRate > OPTIMAL_UTILIZATION_RATE) {\n\t\t\tuint256 excessUtilizationRateRatio = vars.utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(\n\t\t\t\tEXCESS_UTILIZATION_RATE\n\t\t\t);\n\n\t\t\tvars.currentStableBorrowRate = vars.currentStableBorrowRate.add(_stableRateSlope1).add(\n\t\t\t\t_stableRateSlope2.rayMul(excessUtilizationRateRatio)\n\t\t\t);\n\n\t\t\tvars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add(\n\t\t\t\t_variableRateSlope2.rayMul(excessUtilizationRateRatio)\n\t\t\t);\n\t\t} else {\n\t\t\tvars.currentStableBorrowRate = vars.currentStableBorrowRate.add(\n\t\t\t\t_stableRateSlope1.rayMul(vars.utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE))\n\t\t\t);\n\t\t\tvars.currentVariableBorrowRate = _baseVariableBorrowRate.add(\n\t\t\t\tvars.utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE)\n\t\t\t);\n\t\t}\n\n\t\tvars.currentLiquidityRate = _getOverallBorrowRate(\n\t\t\ttotalStableDebt,\n\t\t\ttotalVariableDebt,\n\t\t\tvars.currentVariableBorrowRate,\n\t\t\taverageStableBorrowRate\n\t\t).rayMul(vars.utilizationRate).percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor));\n\n\t\treturn (vars.currentLiquidityRate, vars.currentStableBorrowRate, vars.currentVariableBorrowRate);\n\t}\n\n\t/**\n\t * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable debt\n\t * @param totalStableDebt The total borrowed from the reserve a stable rate\n\t * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n\t * @param currentVariableBorrowRate The current variable borrow rate of the reserve\n\t * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\n\t * @return The weighted averaged borrow rate\n\t **/\n\tfunction _getOverallBorrowRate(\n\t\tuint256 totalStableDebt,\n\t\tuint256 totalVariableDebt,\n\t\tuint256 currentVariableBorrowRate,\n\t\tuint256 currentAverageStableBorrowRate\n\t) internal pure returns (uint256) {\n\t\tuint256 totalDebt = totalStableDebt.add(totalVariableDebt);\n\n\t\tif (totalDebt == 0) return 0;\n\n\t\tuint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\n\n\t\tuint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);\n\n\t\tuint256 overallBorrowRate = weightedVariableRate.add(weightedStableRate).rayDiv(totalDebt.wadToRay());\n\n\t\treturn overallBorrowRate;\n\t}\n}\n"
    },
    "contracts/lending/lendingpool/LendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {IVariableDebtToken} from \"../../interfaces/IVariableDebtToken.sol\";\nimport {IFlashLoanReceiver} from \"../flashloan/interfaces/IFlashLoanReceiver.sol\";\nimport {IPriceOracleGetter} from \"../../interfaces/IPriceOracleGetter.sol\";\nimport {IStableDebtToken} from \"../../interfaces/IStableDebtToken.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {ILeverager} from \"../../interfaces/ILeverager.sol\";\nimport {VersionedInitializable} from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {Helpers} from \"../libraries/helpers/Helpers.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"../libraries/configuration/UserConfiguration.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendingPoolStorage} from \"./LendingPoolStorage.sol\";\n\n/**\n * @title LendingPool contract\n * @dev Main point of interaction with an Aave protocol's market\n * - Users can:\n *   # Deposit\n *   # Withdraw\n *   # Borrow\n *   # Repay\n *   # Swap their loans between variable and stable rate\n *   # Enable/disable their deposits as collateral rebalance stable rate borrow positions\n *   # Liquidate positions\n *   # Execute Flash Loans\n * - To be covered by a proxy contract, owned by the LendingPoolAddressesProvider of the specific market\n * - All admin functions are callable by the LendingPoolConfigurator contract defined also in the\n *   LendingPoolAddressesProvider\n * @author Aave\n **/\ncontract LendingPool is VersionedInitializable, ILendingPool, LendingPoolStorage {\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tuint256 public constant LENDINGPOOL_REVISION = 0x2;\n\n\tILeverager public leverager;\n\n\taddress public owner;\n\n\tmodifier whenNotPaused() {\n\t\t_whenNotPaused();\n\t\t_;\n\t}\n\n\tmodifier onlyLendingPoolConfigurator() {\n\t\t_onlyLendingPoolConfigurator();\n\t\t_;\n\t}\n\n\tfunction _whenNotPaused() internal view {\n\t\trequire(!_paused, Errors.LP_IS_PAUSED);\n\t}\n\n\tfunction _onlyLendingPoolConfigurator() internal view {\n\t\trequire(\n\t\t\t_addressesProvider.getLendingPoolConfigurator() == msg.sender,\n\t\t\tErrors.LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR\n\t\t);\n\t}\n\n\tfunction getRevision() internal pure override returns (uint256) {\n\t\treturn LENDINGPOOL_REVISION;\n\t}\n\n\t/**\n\t * @dev Function is invoked by the proxy contract when the LendingPool contract is added to the\n\t * LendingPoolAddressesProvider of the market.\n\t * - Caching the address of the LendingPoolAddressesProvider in order to reduce gas consumption\n\t *   on subsequent operations\n\t * @param provider The address of the LendingPoolAddressesProvider\n\t **/\n\tfunction initialize(ILendingPoolAddressesProvider provider) public initializer {\n\t\t_addressesProvider = provider;\n\t\t_maxStableRateBorrowSizePercent = 2500;\n\t\t_flashLoanPremiumTotal = 9;\n\t\t_maxNumberOfReserves = 128;\n\t\towner = tx.origin;\n\t}\n\n\t/**\n\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n\t * @param asset The address of the underlying asset to deposit\n\t * @param amount The amount to be deposited\n\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n\t *   is a different wallet\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction deposit(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\taddress onBehalfOf,\n\t\tuint16 referralCode\n\t) public override whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\tValidationLogic.validateDeposit(reserve, amount);\n\n\t\taddress aToken = reserve.aTokenAddress;\n\n\t\treserve.updateState();\n\t\treserve.updateInterestRates(asset, aToken, amount, 0);\n\n\t\tIERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\n\n\t\tif (IAToken(aToken).balanceOf(onBehalfOf) == 0) {\n\t\t\t_usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n\t\t\temit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n\t\t}\n\n\t\tIAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\n\n\t\temit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\n\t}\n\n\tfunction depositWithAutoDLP(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\taddress onBehalfOf,\n\t\tuint16 referralCode\n\t) external override whenNotPaused {\n\t\trequire(tx.origin == onBehalfOf);\n\t\tdeposit(asset, amount, onBehalfOf, referralCode);\n\t\tleverager.zapWETHWithBorrow(leverager.wethToZap(onBehalfOf), onBehalfOf);\n\t}\n\n\t/**\n\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n\t * @param asset The address of the underlying asset to withdraw\n\t * @param amount The underlying amount to be withdrawn\n\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n\t * @param to Address that will receive the underlying, same as msg.sender if the user\n\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n\t *   different wallet\n\t * @return The final amount withdrawn\n\t **/\n\tfunction withdraw(address asset, uint256 amount, address to) external override whenNotPaused returns (uint256) {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\taddress aToken = reserve.aTokenAddress;\n\n\t\tuint256 userBalance = IAToken(aToken).balanceOf(msg.sender);\t\n\n\t\tuint256 amountToWithdraw = amount;\n\n\t\tif (amount == type(uint256).max) {\n\t\t\tamountToWithdraw = userBalance;\n\t\t}\n\n\t\tValidationLogic.validateWithdraw(\n\t\t\tasset,\n\t\t\tamountToWithdraw,\n\t\t\tuserBalance,\n\t\t\t_reserves,\n\t\t\t_usersConfig[msg.sender],\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\t_addressesProvider.getPriceOracle()\n\t\t);\n\n\t\treserve.updateState();\n\n\t\treserve.updateInterestRates(asset, aToken, 0, amountToWithdraw);\n\n\t\tif (amountToWithdraw == userBalance) {\n\t\t\t_usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n\t\t\temit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n\t\t}\n\n\t\tIAToken(aToken).burn(msg.sender, to, amountToWithdraw, reserve.liquidityIndex);\n\n\t\temit Withdraw(asset, msg.sender, to, amountToWithdraw);\n\n\t\treturn amountToWithdraw;\n\t}\n\n\t/**\n\t * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n\t * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n\t * corresponding debt token (StableDebtToken or VariableDebtToken)\n\t * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n\t *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n\t * @param asset The address of the underlying asset to borrow\n\t * @param amount The amount to be borrowed\n\t * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n\t * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n\t * if he has been given credit delegation allowance\n\t **/\n\tfunction borrow(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 interestRateMode,\n\t\tuint16 referralCode,\n\t\taddress onBehalfOf\n\t) external override whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\t_executeBorrow(\n\t\t\tExecuteBorrowParams(\n\t\t\t\tasset,\n\t\t\t\tmsg.sender,\n\t\t\t\tonBehalfOf,\n\t\t\t\tamount,\n\t\t\t\tinterestRateMode,\n\t\t\t\treserve.aTokenAddress,\n\t\t\t\treferralCode,\n\t\t\t\ttrue\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n\t * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n\t * @param asset The address of the borrowed underlying asset previously borrowed\n\t * @param amount The amount to repay\n\t * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n\t * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n\t * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n\t * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n\t * other borrower whose debt should be removed\n\t * @return The final amount repaid\n\t **/\n\tfunction repay(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 rateMode,\n\t\taddress onBehalfOf\n\t) external override whenNotPaused returns (uint256) {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\t(uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\n\n\t\tDataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\n\n\t\tValidationLogic.validateRepay(reserve, amount, interestRateMode, onBehalfOf, stableDebt, variableDebt);\n\n\t\tuint256 paybackAmount = interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;\n\n\t\tif (amount < paybackAmount) {\n\t\t\tpaybackAmount = amount;\n\t\t}\n\n\t\treserve.updateState();\n\n\t\tif (interestRateMode == DataTypes.InterestRateMode.STABLE) {\n\t\t\tIStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);\n\t\t} else {\n\t\t\tIVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n\t\t\t\tonBehalfOf,\n\t\t\t\tpaybackAmount,\n\t\t\t\treserve.variableBorrowIndex\n\t\t\t);\n\t\t}\n\n\t\taddress aToken = reserve.aTokenAddress;\n\t\treserve.updateInterestRates(asset, aToken, paybackAmount, 0);\n\n\t\tif (stableDebt.add(variableDebt).sub(paybackAmount) == 0) {\n\t\t\t_usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\n\t\t}\n\n\t\tIERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount);\n\n\t\tIAToken(aToken).handleRepayment(msg.sender, paybackAmount);\n\n\t\temit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\n\n\t\treturn paybackAmount;\n\t}\n\n\t/**\n\t * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n\t * @param asset The address of the underlying asset borrowed\n\t * @param rateMode The rate mode that the user wants to swap to\n\t **/\n\tfunction swapBorrowRateMode(address asset, uint256 rateMode) external override whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\t(uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserve);\n\n\t\tDataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\n\n\t\tValidationLogic.validateSwapRateMode(\n\t\t\treserve,\n\t\t\t_usersConfig[msg.sender],\n\t\t\tstableDebt,\n\t\t\tvariableDebt,\n\t\t\tinterestRateMode\n\t\t);\n\n\t\treserve.updateState();\n\n\t\tif (interestRateMode == DataTypes.InterestRateMode.STABLE) {\n\t\t\tIStableDebtToken(reserve.stableDebtTokenAddress).burn(msg.sender, stableDebt);\n\t\t\tIVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n\t\t\t\tmsg.sender,\n\t\t\t\tmsg.sender,\n\t\t\t\tstableDebt,\n\t\t\t\treserve.variableBorrowIndex\n\t\t\t);\n\t\t} else {\n\t\t\tIVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n\t\t\t\tmsg.sender,\n\t\t\t\tvariableDebt,\n\t\t\t\treserve.variableBorrowIndex\n\t\t\t);\n\t\t\tIStableDebtToken(reserve.stableDebtTokenAddress).mint(\n\t\t\t\tmsg.sender,\n\t\t\t\tmsg.sender,\n\t\t\t\tvariableDebt,\n\t\t\t\treserve.currentStableBorrowRate\n\t\t\t);\n\t\t}\n\n\t\treserve.updateInterestRates(asset, reserve.aTokenAddress, 0, 0);\n\n\t\temit Swap(asset, msg.sender, rateMode);\n\t}\n\n\t/**\n\t * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n\t * - Users can be rebalanced if the following conditions are satisfied:\n\t *     1. Usage ratio is above 95%\n\t *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n\t *        borrowed at a stable rate and depositors are not earning enough\n\t * @param asset The address of the underlying asset borrowed\n\t * @param user The address of the user to be rebalanced\n\t **/\n\tfunction rebalanceStableBorrowRate(address asset, address user) external override whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\tIERC20 stableDebtToken = IERC20(reserve.stableDebtTokenAddress);\n\t\tIERC20 variableDebtToken = IERC20(reserve.variableDebtTokenAddress);\n\t\taddress aTokenAddress = reserve.aTokenAddress;\n\n\t\tuint256 stableDebt = IERC20(stableDebtToken).balanceOf(user);\n\n\t\tValidationLogic.validateRebalanceStableBorrowRate(\n\t\t\treserve,\n\t\t\tasset,\n\t\t\tstableDebtToken,\n\t\t\tvariableDebtToken,\n\t\t\taTokenAddress\n\t\t);\n\n\t\treserve.updateState();\n\n\t\tIStableDebtToken(address(stableDebtToken)).burn(user, stableDebt);\n\t\tIStableDebtToken(address(stableDebtToken)).mint(user, user, stableDebt, reserve.currentStableBorrowRate);\n\n\t\treserve.updateInterestRates(asset, aTokenAddress, 0, 0);\n\n\t\temit RebalanceStableBorrowRate(asset, user);\n\t}\n\n\t/**\n\t * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n\t * @param asset The address of the underlying asset deposited\n\t * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n\t **/\n\tfunction setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external override whenNotPaused {\n\t\tDataTypes.ReserveData storage reserve = _reserves[asset];\n\n\t\tValidationLogic.validateSetUseReserveAsCollateral(\n\t\t\treserve,\n\t\t\tasset,\n\t\t\tuseAsCollateral,\n\t\t\t_reserves,\n\t\t\t_usersConfig[msg.sender],\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\t_addressesProvider.getPriceOracle()\n\t\t);\n\n\t\t_usersConfig[msg.sender].setUsingAsCollateral(reserve.id, useAsCollateral);\n\n\t\tif (useAsCollateral) {\n\t\t\temit ReserveUsedAsCollateralEnabled(asset, msg.sender);\n\t\t} else {\n\t\t\temit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n\t * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n\t *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tfunction liquidationCall(\n\t\taddress collateralAsset,\n\t\taddress debtAsset,\n\t\taddress user,\n\t\tuint256 debtToCover,\n\t\tbool receiveAToken\n\t) external override whenNotPaused {\n\t\taddress collateralManager = _addressesProvider.getLendingPoolCollateralManager();\n\t\taddress liquidationFeeTo = _addressesProvider.getLiquidationFeeTo();\n\t\tif (liquidationFeeTo == address(0)) {\n\t\t\tliquidationFeeTo = msg.sender;\n\t\t}\n\n\t\t//solium-disable-next-line\n\t\t(bool success, bytes memory result) = collateralManager.delegatecall(\n\t\t\tabi.encodeWithSignature(\n\t\t\t\t\"liquidationCall(address,address,address,uint256,bool,address)\",\n\t\t\t\tcollateralAsset,\n\t\t\t\tdebtAsset,\n\t\t\t\tuser,\n\t\t\t\tdebtToCover,\n\t\t\t\treceiveAToken,\n\t\t\t\tliquidationFeeTo\n\t\t\t)\n\t\t);\n\n\t\trequire(success, Errors.LP_LIQUIDATION_CALL_FAILED);\n\n\t\t(uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\n\n\t\trequire(returnCode == 0, string(abi.encodePacked(returnMessage)));\n\t}\n\n\tstruct FlashLoanLocalVars {\n\t\tIFlashLoanReceiver receiver;\n\t\taddress oracle;\n\t\tuint256 i;\n\t\taddress currentAsset;\n\t\taddress currentATokenAddress;\n\t\tuint256 currentAmount;\n\t\tuint256 currentPremium;\n\t\tuint256 currentAmountPlusPremium;\n\t\taddress debtToken;\n\t}\n\n\t/**\n\t * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n\t * as long as the amount taken plus a fee is returned.\n\t * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n\t * For further details please visit https://developers.aave.com\n\t * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n\t * @param assets The addresses of the assets being flash-borrowed\n\t * @param amounts The amounts amounts being flash-borrowed\n\t * @param modes Types of the debt to open if the flash loan is not returned:\n\t *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n\t *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n\t * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n\t * @param params Variadic packed params to pass to the receiver as extra information\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n\t *   0 if the action is executed directly by the user, without any middle-man\n\t **/\n\tfunction flashLoan(\n\t\taddress receiverAddress,\n\t\taddress[] calldata assets,\n\t\tuint256[] calldata amounts,\n\t\tuint256[] calldata modes,\n\t\taddress onBehalfOf,\n\t\tbytes calldata params,\n\t\tuint16 referralCode\n\t) external override whenNotPaused {\n\t\tFlashLoanLocalVars memory vars;\n\n\t\tValidationLogic.validateFlashloan(assets, amounts);\n\n\t\taddress[] memory aTokenAddresses = new address[](assets.length);\n\t\tuint256[] memory premiums = new uint256[](assets.length);\n\n\t\tvars.receiver = IFlashLoanReceiver(receiverAddress);\n\n\t\tfor (vars.i = 0; vars.i < assets.length; vars.i++) {\n\t\t\taTokenAddresses[vars.i] = _reserves[assets[vars.i]].aTokenAddress;\n\n\t\t\tpremiums[vars.i] = amounts[vars.i].mul(_flashLoanPremiumTotal).div(10000);\n\n\t\t\tIAToken(aTokenAddresses[vars.i]).transferUnderlyingTo(receiverAddress, amounts[vars.i]);\n\t\t}\n\n\t\trequire(\n\t\t\tvars.receiver.executeOperation(assets, amounts, premiums, msg.sender, params),\n\t\t\tErrors.LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN\n\t\t);\n\n\t\tfor (vars.i = 0; vars.i < assets.length; vars.i++) {\n\t\t\tvars.currentAsset = assets[vars.i];\n\t\t\tvars.currentAmount = amounts[vars.i];\n\t\t\tvars.currentPremium = premiums[vars.i];\n\t\t\tvars.currentATokenAddress = aTokenAddresses[vars.i];\n\t\t\tvars.currentAmountPlusPremium = vars.currentAmount.add(vars.currentPremium);\n\n\t\t\tif (DataTypes.InterestRateMode(modes[vars.i]) == DataTypes.InterestRateMode.NONE) {\n\t\t\t\t_reserves[vars.currentAsset].updateState();\n\t\t\t\t_reserves[vars.currentAsset].cumulateToLiquidityIndex(\n\t\t\t\t\tIERC20(vars.currentATokenAddress).totalSupply(),\n\t\t\t\t\tvars.currentPremium\n\t\t\t\t);\n\t\t\t\t_reserves[vars.currentAsset].updateInterestRates(\n\t\t\t\t\tvars.currentAsset,\n\t\t\t\t\tvars.currentATokenAddress,\n\t\t\t\t\tvars.currentAmountPlusPremium,\n\t\t\t\t\t0\n\t\t\t\t);\n\n\t\t\t\tIERC20(vars.currentAsset).safeTransferFrom(\n\t\t\t\t\treceiverAddress,\n\t\t\t\t\tvars.currentATokenAddress,\n\t\t\t\t\tvars.currentAmountPlusPremium\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// If the user chose to not return the funds, the system checks if there is enough collateral and\n\t\t\t\t// eventually opens a debt position\n\t\t\t\t_executeBorrow(\n\t\t\t\t\tExecuteBorrowParams(\n\t\t\t\t\t\tvars.currentAsset,\n\t\t\t\t\t\tmsg.sender,\n\t\t\t\t\t\tonBehalfOf,\n\t\t\t\t\t\tvars.currentAmount,\n\t\t\t\t\t\tmodes[vars.i],\n\t\t\t\t\t\tvars.currentATokenAddress,\n\t\t\t\t\t\treferralCode,\n\t\t\t\t\t\tfalse\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\temit FlashLoan(\n\t\t\t\treceiverAddress,\n\t\t\t\tmsg.sender,\n\t\t\t\tvars.currentAsset,\n\t\t\t\tvars.currentAmount,\n\t\t\t\tvars.currentPremium,\n\t\t\t\treferralCode\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the state and configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The state of the reserve\n\t **/\n\tfunction getReserveData(address asset) external view override returns (DataTypes.ReserveData memory) {\n\t\treturn _reserves[asset];\n\t}\n\n\t/**\n\t * @dev Returns the user account data across all the reserves\n\t * @param user The address of the user\n\t * @return totalCollateralETH the total collateral in ETH of the user\n\t * @return totalDebtETH the total debt in ETH of the user\n\t * @return availableBorrowsETH the borrowing power left of the user\n\t * @return currentLiquidationThreshold the liquidation threshold of the user\n\t * @return ltv the loan to value of the user\n\t * @return healthFactor the current health factor of the user\n\t **/\n\tfunction getUserAccountData(\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (\n\t\t\tuint256 totalCollateralETH,\n\t\t\tuint256 totalDebtETH,\n\t\t\tuint256 availableBorrowsETH,\n\t\t\tuint256 currentLiquidationThreshold,\n\t\t\tuint256 ltv,\n\t\t\tuint256 healthFactor\n\t\t)\n\t{\n\t\t(totalCollateralETH, totalDebtETH, ltv, currentLiquidationThreshold, healthFactor) = GenericLogic\n\t\t\t.calculateUserAccountData(\n\t\t\t\tuser,\n\t\t\t\t_reserves,\n\t\t\t\t_usersConfig[user],\n\t\t\t\t_reservesList,\n\t\t\t\t_reservesCount,\n\t\t\t\t_addressesProvider.getPriceOracle()\n\t\t\t);\n\n\t\tavailableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(totalCollateralETH, totalDebtETH, ltv);\n\t}\n\n\t/**\n\t * @dev Returns the configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The configuration of the reserve\n\t **/\n\tfunction getConfiguration(address asset) external view override returns (DataTypes.ReserveConfigurationMap memory) {\n\t\treturn _reserves[asset].configuration;\n\t}\n\n\t/**\n\t * @dev Returns the configuration of the user across all the reserves\n\t * @param user The user address\n\t * @return The configuration of the user\n\t **/\n\tfunction getUserConfiguration(address user) external view override returns (DataTypes.UserConfigurationMap memory) {\n\t\treturn _usersConfig[user];\n\t}\n\n\t/**\n\t * @dev Returns the normalized income per unit of asset\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve's normalized income\n\t */\n\tfunction getReserveNormalizedIncome(address asset) external view virtual override returns (uint256) {\n\t\treturn _reserves[asset].getNormalizedIncome();\n\t}\n\n\t/**\n\t * @dev Returns the normalized variable debt per unit of asset\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The reserve normalized variable debt\n\t */\n\tfunction getReserveNormalizedVariableDebt(address asset) external view override returns (uint256) {\n\t\treturn _reserves[asset].getNormalizedDebt();\n\t}\n\n\t/**\n\t * @dev Returns if the LendingPool is paused\n\t */\n\tfunction paused() external view override returns (bool) {\n\t\treturn _paused;\n\t}\n\n\t/**\n\t * @dev Returns the list of the initialized reserves\n\t **/\n\tfunction getReservesList() external view override returns (address[] memory) {\n\t\taddress[] memory _activeReserves = new address[](_reservesCount);\n\n\t\tfor (uint256 i = 0; i < _reservesCount; i++) {\n\t\t\t_activeReserves[i] = _reservesList[i];\n\t\t}\n\t\treturn _activeReserves;\n\t}\n\n\t/**\n\t * @dev Returns the cached LendingPoolAddressesProvider connected to this contract\n\t **/\n\tfunction getAddressesProvider() external view override returns (ILendingPoolAddressesProvider) {\n\t\treturn _addressesProvider;\n\t}\n\n\t/**\n\t * @dev Returns the percentage of available liquidity that can be borrowed at once at stable rate\n\t */\n\tfunction MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view returns (uint256) {\n\t\treturn _maxStableRateBorrowSizePercent;\n\t}\n\n\t/**\n\t * @dev Returns the fee on flash loans\n\t */\n\tfunction FLASHLOAN_PREMIUM_TOTAL() public view returns (uint256) {\n\t\treturn _flashLoanPremiumTotal;\n\t}\n\n\t/**\n\t * @dev Returns the maximum number of reserves supported to be listed in this LendingPool\n\t */\n\tfunction MAX_NUMBER_RESERVES() public view returns (uint256) {\n\t\treturn _maxNumberOfReserves;\n\t}\n\n\t/**\n\t * @dev Validates and finalizes an aToken transfer\n\t * - Only callable by the overlying aToken of the `asset`\n\t * @param asset The address of the underlying asset of the aToken\n\t * @param from The user from which the aTokens are transferred\n\t * @param to The user receiving the aTokens\n\t * @param amount The amount being transferred/withdrawn\n\t * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n\t * @param balanceToBefore The aToken balance of the `to` user before the transfer\n\t */\n\tfunction finalizeTransfer(\n\t\taddress asset,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount,\n\t\tuint256 balanceFromBefore,\n\t\tuint256 balanceToBefore\n\t) external override whenNotPaused {\n\t\trequire(msg.sender == _reserves[asset].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN);\n\n\t\tValidationLogic.validateTransfer(\n\t\t\tfrom,\n\t\t\t_reserves,\n\t\t\t_usersConfig[from],\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\t_addressesProvider.getPriceOracle()\n\t\t);\n\n\t\tuint256 reserveId = _reserves[asset].id;\n\n\t\tif (from != to) {\n\t\t\tif (balanceFromBefore.sub(amount) == 0) {\n\t\t\t\tDataTypes.UserConfigurationMap storage fromConfig = _usersConfig[from];\n\t\t\t\tfromConfig.setUsingAsCollateral(reserveId, false);\n\t\t\t\temit ReserveUsedAsCollateralDisabled(asset, from);\n\t\t\t}\n\n\t\t\tif (balanceToBefore == 0 && amount != 0) {\n\t\t\t\tDataTypes.UserConfigurationMap storage toConfig = _usersConfig[to];\n\t\t\t\ttoConfig.setUsingAsCollateral(reserveId, true);\n\t\t\t\temit ReserveUsedAsCollateralEnabled(asset, to);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n\t * interest rate strategy\n\t * - Only callable by the LendingPoolConfigurator contract\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n\t * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n\t * @param aTokenAddress The address of the VariableDebtToken that will be assigned to the reserve\n\t * @param interestRateStrategyAddress The address of the interest rate strategy contract\n\t **/\n\tfunction initReserve(\n\t\taddress asset,\n\t\taddress aTokenAddress,\n\t\taddress stableDebtAddress,\n\t\taddress variableDebtAddress,\n\t\taddress interestRateStrategyAddress\n\t) external override onlyLendingPoolConfigurator {\n\t\trequire(Address.isContract(asset), Errors.LP_NOT_CONTRACT);\n\t\t_reserves[asset].init(aTokenAddress, stableDebtAddress, variableDebtAddress, interestRateStrategyAddress);\n\t\t_addReserveToList(asset);\n\t}\n\n\t/**\n\t * @dev Updates the address of the interest rate strategy contract\n\t * - Only callable by the LendingPoolConfigurator contract\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param rateStrategyAddress The address of the interest rate strategy contract\n\t **/\n\tfunction setReserveInterestRateStrategyAddress(\n\t\taddress asset,\n\t\taddress rateStrategyAddress\n\t) external override onlyLendingPoolConfigurator {\n\t\t_reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n\t}\n\n\t/**\n\t * @dev Sets the configuration bitmap of the reserve as a whole\n\t * - Only callable by the LendingPoolConfigurator contract\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param configuration The new configuration bitmap\n\t **/\n\tfunction setConfiguration(address asset, uint256 configuration) external override onlyLendingPoolConfigurator {\n\t\t_reserves[asset].configuration.data = configuration;\n\t}\n\n\t/**\n\t * @dev Set the _pause state of a reserve\n\t * - Only callable by the LendingPoolConfigurator contract\n\t * @param val `true` to pause the reserve, `false` to un-pause it\n\t */\n\tfunction setPause(bool val) external override onlyLendingPoolConfigurator {\n\t\t_paused = val;\n\t\tif (_paused) {\n\t\t\temit Paused();\n\t\t} else {\n\t\t\temit Unpaused();\n\t\t}\n\t}\n\n\tstruct ExecuteBorrowParams {\n\t\taddress asset;\n\t\taddress user;\n\t\taddress onBehalfOf;\n\t\tuint256 amount;\n\t\tuint256 interestRateMode;\n\t\taddress aTokenAddress;\n\t\tuint16 referralCode;\n\t\tbool releaseUnderlying;\n\t}\n\n\tfunction _executeBorrow(ExecuteBorrowParams memory vars) internal {\n\t\tDataTypes.ReserveData storage reserve = _reserves[vars.asset];\n\t\tDataTypes.UserConfigurationMap storage userConfig = _usersConfig[vars.onBehalfOf];\n\n\t\taddress oracle = _addressesProvider.getPriceOracle();\n\n\t\tuint256 amountInETH = IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(\n\t\t\t10 ** reserve.configuration.getDecimals()\n\t\t);\n\n\t\tValidationLogic.validateBorrow(\n\t\t\tvars.asset,\n\t\t\treserve,\n\t\t\tvars.onBehalfOf,\n\t\t\tvars.amount,\n\t\t\tamountInETH,\n\t\t\tvars.interestRateMode,\n\t\t\t_maxStableRateBorrowSizePercent,\n\t\t\t_reserves,\n\t\t\tuserConfig,\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\toracle\n\t\t);\n\n\t\treserve.updateState();\n\n\t\tuint256 currentStableRate = 0;\n\n\t\tbool isFirstBorrowing = false;\n\t\tif (DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE) {\n\t\t\tcurrentStableRate = reserve.currentStableBorrowRate;\n\n\t\t\tisFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n\t\t\t\tvars.user,\n\t\t\t\tvars.onBehalfOf,\n\t\t\t\tvars.amount,\n\t\t\t\tcurrentStableRate\n\t\t\t);\n\t\t} else {\n\t\t\tisFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n\t\t\t\tvars.user,\n\t\t\t\tvars.onBehalfOf,\n\t\t\t\tvars.amount,\n\t\t\t\treserve.variableBorrowIndex\n\t\t\t);\n\t\t}\n\n\t\tif (isFirstBorrowing) {\n\t\t\tuserConfig.setBorrowing(reserve.id, true);\n\t\t}\n\n\t\treserve.updateInterestRates(vars.asset, vars.aTokenAddress, 0, vars.releaseUnderlying ? vars.amount : 0);\n\n\t\tif (vars.releaseUnderlying) {\n\t\t\tIAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);\n\t\t}\n \n\t\temit Borrow(\n\t\t\tvars.asset,\n\t\t\tvars.user,\n\t\t\tvars.onBehalfOf,\n\t\t\tvars.amount,\n\t\t\tvars.interestRateMode,\n\t\t\tDataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE\n\t\t\t\t? currentStableRate\n\t\t\t\t: reserve.currentVariableBorrowRate,\n\t\t\tvars.referralCode\n\t\t);\n\t}\n\n\tfunction _addReserveToList(address asset) internal {\n\t\tuint256 reservesCount = _reservesCount;\n\n\t\trequire(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\n\n\t\tbool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\n\n\t\tif (!reserveAlreadyAdded) {\n\t\t\t_reserves[asset].id = uint8(reservesCount);\n\t\t\t_reservesList[reservesCount] = asset;\n\n\t\t\t_reservesCount = reservesCount + 1;\n\t\t}\n\t}\n\n\tfunction setLeverager(ILeverager _leverager) external {\n\t\trequire(msg.sender == owner, \"!owner\");\n\t\t//require(address(leverager) == address(0), \"Leverager Already Set\");\n\t\tleverager = _leverager;\n\t}\n\n\tfunction setNewOwner(address _newOwner) external {\n\t\trequire(msg.sender == owner, \"!owner\");\n\t\towner = _newOwner;\n\t}\n}\n"
    },
    "contracts/lending/lendingpool/LendingPoolCollateralManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {IStableDebtToken} from \"../../interfaces/IStableDebtToken.sol\";\nimport {IVariableDebtToken} from \"../../interfaces/IVariableDebtToken.sol\";\nimport {IPriceOracleGetter} from \"../../interfaces/IPriceOracleGetter.sol\";\nimport {ILendingPoolCollateralManager} from \"../../interfaces/ILendingPoolCollateralManager.sol\";\nimport {VersionedInitializable} from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {GenericLogic} from \"../libraries/logic/GenericLogic.sol\";\nimport {Helpers} from \"../libraries/helpers/Helpers.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {ValidationLogic} from \"../libraries/logic/ValidationLogic.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {LendingPoolStorage} from \"./LendingPoolStorage.sol\";\nimport {UserConfiguration} from \"../libraries/configuration/UserConfiguration.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\n\n/**\n * @title LendingPoolCollateralManager contract\n * @author Aave\n * @dev Implements actions involving management of collateral in the protocol, the main one being the liquidations\n * IMPORTANT This contract will run always via DELEGATECALL, through the LendingPool, so the chain of inheritance\n * is the same as the LendingPool, to have compatible storage layouts\n **/\ncontract LendingPoolCollateralManager is ILendingPoolCollateralManager, VersionedInitializable, LendingPoolStorage {\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tuint256 internal constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000;\n\n\tstruct LiquidationCallLocalVars {\n\t\tuint256 userCollateralBalance;\n\t\tuint256 userStableDebt;\n\t\tuint256 userVariableDebt;\n\t\tuint256 maxLiquidatableDebt;\n\t\tuint256 actualDebtToLiquidate;\n\t\tuint256 liquidationRatio;\n\t\tuint256 maxAmountCollateralToLiquidate;\n\t\tuint256 userStableRate;\n\t\tuint256 maxCollateralToLiquidate;\n\t\tuint256 liquidationFee;\n\t\tuint256 debtAmountNeeded;\n\t\tuint256 healthFactor;\n\t\tuint256 liquidatorPreviousATokenBalance;\n\t\tIAToken collateralAtoken;\n\t\tbool isCollateralEnabled;\n\t\tDataTypes.InterestRateMode borrowRateMode;\n\t\tuint256 errorCode;\n\t\tstring errorMsg;\n\t}\n\n\t/**\n\t * @dev As thIS contract extends the VersionedInitializable contract to match the state\n\t * of the LendingPool contract, the getRevision() function is needed, but the value is not\n\t * important, as the initialize() function will never be called here\n\t */\n\tfunction getRevision() internal pure override returns (uint256) {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * @dev Function to liquidate a position if its Health Factor drops below 1\n\t * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n\t *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param user The address of the borrower getting liquidated\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n\t * to receive the underlying collateral asset directly\n\t **/\n\tfunction liquidationCall(\n\t\taddress collateralAsset,\n\t\taddress debtAsset,\n\t\taddress user,\n\t\tuint256 debtToCover,\n\t\tbool receiveAToken,\n\t\taddress liquidationFeeTo\n\t) external override returns (uint256, string memory) {\n\t\tDataTypes.ReserveData storage collateralReserve = _reserves[collateralAsset];\n\t\tDataTypes.ReserveData storage debtReserve = _reserves[debtAsset];\n\t\tDataTypes.UserConfigurationMap storage userConfig = _usersConfig[user];\n\n\t\tLiquidationCallLocalVars memory vars;\n\n\t\t(, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\n\t\t\tuser,\n\t\t\t_reserves,\n\t\t\tuserConfig,\n\t\t\t_reservesList,\n\t\t\t_reservesCount,\n\t\t\t_addressesProvider.getPriceOracle()\n\t\t);\n\n\t\t(vars.userStableDebt, vars.userVariableDebt) = Helpers.getUserCurrentDebt(user, debtReserve);\n\n\t\t(vars.errorCode, vars.errorMsg) = ValidationLogic.validateLiquidationCall(\n\t\t\tcollateralReserve,\n\t\t\tdebtReserve,\n\t\t\tuserConfig,\n\t\t\tvars.healthFactor,\n\t\t\tvars.userStableDebt,\n\t\t\tvars.userVariableDebt\n\t\t);\n\n\t\tif (Errors.CollateralManagerErrors(vars.errorCode) != Errors.CollateralManagerErrors.NO_ERROR) {\n\t\t\treturn (vars.errorCode, vars.errorMsg);\n\t\t}\n\n\t\tvars.collateralAtoken = IAToken(collateralReserve.aTokenAddress);\n\n\t\tvars.userCollateralBalance = vars.collateralAtoken.balanceOf(user);\n\n\t\tvars.maxLiquidatableDebt = vars.userStableDebt.add(vars.userVariableDebt).percentMul(\n\t\t\tLIQUIDATION_CLOSE_FACTOR_PERCENT\n\t\t);\n\n\t\tvars.actualDebtToLiquidate = debtToCover > vars.maxLiquidatableDebt ? vars.maxLiquidatableDebt : debtToCover;\n\n\t\t(\n\t\t\tvars.maxCollateralToLiquidate,\n\t\t\tvars.liquidationFee,\n\t\t\tvars.debtAmountNeeded\n\t\t) = _calculateAvailableCollateralToLiquidate(\n\t\t\tcollateralReserve,\n\t\t\tdebtReserve,\n\t\t\tcollateralAsset,\n\t\t\tdebtAsset,\n\t\t\tvars.actualDebtToLiquidate,\n\t\t\tvars.userCollateralBalance\n\t\t);\n\n\t\t// If debtAmountNeeded < actualDebtToLiquidate, there isn't enough\n\t\t// collateral to cover the actual amount that is being liquidated, hence we liquidate\n\t\t// a smaller amount\n\n\t\tif (vars.debtAmountNeeded < vars.actualDebtToLiquidate) {\n\t\t\tvars.actualDebtToLiquidate = vars.debtAmountNeeded;\n\t\t}\n\n\t\t// If the liquidator reclaims the underlying asset, we make sure there is enough available liquidity in the\n\t\t// collateral reserve\n\t\tif (!receiveAToken) {\n\t\t\tuint256 currentAvailableCollateral = IERC20(collateralAsset).balanceOf(address(vars.collateralAtoken));\n\t\t\tif (currentAvailableCollateral < vars.maxCollateralToLiquidate) {\n\t\t\t\treturn (\n\t\t\t\t\tuint256(Errors.CollateralManagerErrors.NOT_ENOUGH_LIQUIDITY),\n\t\t\t\t\tErrors.LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tdebtReserve.updateState();\n\n\t\tif (vars.userVariableDebt >= vars.actualDebtToLiquidate) {\n\t\t\tIVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n\t\t\t\tuser,\n\t\t\t\tvars.actualDebtToLiquidate,\n\t\t\t\tdebtReserve.variableBorrowIndex\n\t\t\t);\n\t\t} else {\n\t\t\t// If the user doesn't have variable debt, no need to try to burn variable debt tokens\n\t\t\tif (vars.userVariableDebt > 0) {\n\t\t\t\tIVariableDebtToken(debtReserve.variableDebtTokenAddress).burn(\n\t\t\t\t\tuser,\n\t\t\t\t\tvars.userVariableDebt,\n\t\t\t\t\tdebtReserve.variableBorrowIndex\n\t\t\t\t);\n\t\t\t}\n\t\t\tIStableDebtToken(debtReserve.stableDebtTokenAddress).burn(\n\t\t\t\tuser,\n\t\t\t\tvars.actualDebtToLiquidate.sub(vars.userVariableDebt)\n\t\t\t);\n\t\t}\n\n\t\tdebtReserve.updateInterestRates(debtAsset, debtReserve.aTokenAddress, vars.actualDebtToLiquidate, 0);\n\n\t\tif (receiveAToken) {\n\t\t\tvars.liquidatorPreviousATokenBalance = IERC20(vars.collateralAtoken).balanceOf(msg.sender);\n\t\t\tvars.collateralAtoken.transferOnLiquidation(\n\t\t\t\tuser,\n\t\t\t\tmsg.sender,\n\t\t\t\tvars.maxCollateralToLiquidate.sub(vars.liquidationFee)\n\t\t\t);\n\t\t\tvars.collateralAtoken.transferOnLiquidation(user, liquidationFeeTo, vars.liquidationFee);\n\n\t\t\tif (vars.liquidatorPreviousATokenBalance == 0) {\n\t\t\t\tDataTypes.UserConfigurationMap storage liquidatorConfig = _usersConfig[msg.sender];\n\t\t\t\tliquidatorConfig.setUsingAsCollateral(collateralReserve.id, true);\n\t\t\t\temit ReserveUsedAsCollateralEnabled(collateralAsset, msg.sender);\n\t\t\t}\n\t\t} else {\n\t\t\tcollateralReserve.updateState();\n\t\t\tcollateralReserve.updateInterestRates(\n\t\t\t\tcollateralAsset,\n\t\t\t\taddress(vars.collateralAtoken),\n\t\t\t\t0,\n\t\t\t\tvars.maxCollateralToLiquidate\n\t\t\t);\n\n\t\t\t// Burn the equivalent amount of aToken, sending the underlying to the liquidator\n\t\t\tvars.collateralAtoken.burn(\n\t\t\t\tuser,\n\t\t\t\tmsg.sender,\n\t\t\t\tvars.maxCollateralToLiquidate.sub(vars.liquidationFee),\n\t\t\t\tcollateralReserve.liquidityIndex\n\t\t\t);\n\t\t\tvars.collateralAtoken.burn(user, liquidationFeeTo, vars.liquidationFee, collateralReserve.liquidityIndex);\n\t\t}\n\n\t\t// If the collateral being liquidated is equal to the user balance,\n\t\t// we set the currency as not being used as collateral anymore\n\t\tif (vars.maxCollateralToLiquidate == vars.userCollateralBalance) {\n\t\t\tuserConfig.setUsingAsCollateral(collateralReserve.id, false);\n\t\t\temit ReserveUsedAsCollateralDisabled(collateralAsset, user);\n\t\t}\n\n\t\t// Transfers the debt asset being repaid to the aToken, where the liquidity is kept\n\t\tIERC20(debtAsset).safeTransferFrom(msg.sender, debtReserve.aTokenAddress, vars.actualDebtToLiquidate);\n\n\t\temit LiquidationCall(\n\t\t\tcollateralAsset,\n\t\t\tdebtAsset,\n\t\t\tuser,\n\t\t\tvars.actualDebtToLiquidate,\n\t\t\tvars.maxCollateralToLiquidate,\n\t\t\tmsg.sender,\n\t\t\treceiveAToken,\n\t\t\tliquidationFeeTo\n\t\t);\n\n\t\treturn (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\n\t}\n\n\tstruct AvailableCollateralToLiquidateLocalVars {\n\t\tuint256 userCompoundedBorrowBalance;\n\t\tuint256 liquidationBonus;\n\t\tuint256 collateralPrice;\n\t\tuint256 debtAssetPrice;\n\t\tuint256 maxAmountCollateralToLiquidate;\n\t\tuint256 debtAssetDecimals;\n\t\tuint256 collateralDecimals;\n\t}\n\n\t/**\n\t * @dev Calculates how much of a specific collateral can be liquidated, given\n\t * a certain amount of debt asset.\n\t * - This function needs to be called after all the checks to validate the liquidation have been performed,\n\t *   otherwise it might fail.\n\t * @param collateralReserve The data of the collateral reserve\n\t * @param debtReserve The data of the debt reserve\n\t * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n\t * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n\t * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n\t * @param userCollateralBalance The collateral balance for the specific `collateralAsset` of the user being liquidated\n\t * @return collateralAmount: The maximum amount that is possible to liquidate given all the liquidation constraints\n\t *                           (user balance, close factor)\n\t *         debtAmountNeeded: The amount to repay with the liquidation\n\t **/\n\tfunction _calculateAvailableCollateralToLiquidate(\n\t\tDataTypes.ReserveData storage collateralReserve,\n\t\tDataTypes.ReserveData storage debtReserve,\n\t\taddress collateralAsset,\n\t\taddress debtAsset,\n\t\tuint256 debtToCover,\n\t\tuint256 userCollateralBalance\n\t) internal view returns (uint256, uint256, uint256) {\n\t\tuint256 collateralAmount = 0;\n\t\tuint256 debtAmountNeeded = 0;\n\t\tIPriceOracleGetter oracle = IPriceOracleGetter(_addressesProvider.getPriceOracle());\n\n\t\tAvailableCollateralToLiquidateLocalVars memory vars;\n\n\t\tvars.collateralPrice = oracle.getAssetPrice(collateralAsset);\n\t\tvars.debtAssetPrice = oracle.getAssetPrice(debtAsset);\n\n\t\t(, , vars.liquidationBonus, vars.collateralDecimals, ) = collateralReserve.configuration.getParams();\n\t\tvars.debtAssetDecimals = debtReserve.configuration.getDecimals();\n\n\t\t// This is the maximum possible amount of the selected collateral that can be liquidated, given the\n\t\t// max amount of liquidatable debt\n\t\tvars.maxAmountCollateralToLiquidate = vars\n\t\t\t.debtAssetPrice\n\t\t\t.mul(debtToCover)\n\t\t\t.mul(10 ** vars.collateralDecimals)\n\t\t\t.percentMul(vars.liquidationBonus)\n\t\t\t.div(vars.collateralPrice.mul(10 ** vars.debtAssetDecimals));\n\n\t\tif (vars.maxAmountCollateralToLiquidate > userCollateralBalance) {\n\t\t\tcollateralAmount = userCollateralBalance;\n\t\t\tdebtAmountNeeded = vars\n\t\t\t\t.collateralPrice\n\t\t\t\t.mul(collateralAmount)\n\t\t\t\t.mul(10 ** vars.debtAssetDecimals)\n\t\t\t\t.div(vars.debtAssetPrice.mul(10 ** vars.collateralDecimals))\n\t\t\t\t.percentDiv(vars.liquidationBonus);\n\t\t} else {\n\t\t\tcollateralAmount = vars.maxAmountCollateralToLiquidate;\n\t\t\tdebtAmountNeeded = debtToCover;\n\t\t}\n\t\tuint256 bonusCollateral = collateralAmount.sub(\n\t\t\tvars.debtAssetPrice.mul(debtAmountNeeded).mul(10 ** vars.collateralDecimals).div(\n\t\t\t\tvars.collateralPrice.mul(10 ** vars.debtAssetDecimals)\n\t\t\t)\n\t\t);\n\t\treturn (collateralAmount, bonusCollateral.div(2), debtAmountNeeded);\n\t}\n}\n"
    },
    "contracts/lending/lendingpool/LendingPoolConfigurator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {VersionedInitializable} from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {InitializableImmutableAdminUpgradeabilityProxy} from \"../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {PercentageMath} from \"../libraries/math/PercentageMath.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {IInitializableDebtToken} from \"../../interfaces/IInitializableDebtToken.sol\";\nimport {IInitializableAToken} from \"../../interfaces/IInitializableAToken.sol\";\nimport {IChefIncentivesController} from \"../../interfaces/IChefIncentivesController.sol\";\nimport {ILendingPoolConfigurator} from \"../../interfaces/ILendingPoolConfigurator.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\n\n/**\n * @title LendingPoolConfigurator contract\n * @author Aave\n * @dev Implements the configuration methods for the Aave protocol\n **/\n\ncontract LendingPoolConfigurator is VersionedInitializable, ILendingPoolConfigurator {\n\tusing SafeMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n\tILendingPoolAddressesProvider internal addressesProvider;\n\tILendingPool internal pool;\n\n\tmodifier onlyPoolAdmin() {\n\t\trequire(addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n\t\t_;\n\t}\n\n\tmodifier onlyEmergencyAdmin() {\n\t\trequire(addressesProvider.getEmergencyAdmin() == msg.sender, Errors.LPC_CALLER_NOT_EMERGENCY_ADMIN);\n\t\t_;\n\t}\n\n\tuint256 internal constant CONFIGURATOR_REVISION = 0x1;\n\n\tfunction getRevision() internal pure override returns (uint256) {\n\t\treturn CONFIGURATOR_REVISION;\n\t}\n\n\tfunction initialize(ILendingPoolAddressesProvider provider) public initializer {\n\t\taddressesProvider = provider;\n\t\tpool = ILendingPool(addressesProvider.getLendingPool());\n\t}\n\n\t/**\n\t * @dev Initializes reserves in batch\n\t **/\n\tfunction batchInitReserve(InitReserveInput[] calldata input) external onlyPoolAdmin {\n\t\tILendingPool cachedPool = pool;\n\t\tfor (uint256 i = 0; i < input.length; i++) {\n\t\t\t_initReserve(cachedPool, input[i]);\n\t\t}\n\t}\n\n\tfunction _initReserve(ILendingPool _pool, InitReserveInput calldata input) internal {\n\t\tIChefIncentivesController incentivesController = IChefIncentivesController(input.incentivesController);\n\t\taddress aTokenProxyAddress = _initTokenWithProxy(\n\t\t\tinput.aTokenImpl,\n\t\t\tabi.encodeWithSelector(\n\t\t\t\tIInitializableAToken.initialize.selector,\n\t\t\t\t_pool,\n\t\t\t\tinput.treasury,\n\t\t\t\tinput.underlyingAsset,\n\t\t\t\tincentivesController,\n\t\t\t\tinput.underlyingAssetDecimals,\n\t\t\t\tinput.aTokenName,\n\t\t\t\tinput.aTokenSymbol,\n\t\t\t\tinput.params\n\t\t\t)\n\t\t);\n\t\tincentivesController.addPool(aTokenProxyAddress, input.allocPoint);\n\t\tIMultiFeeDistribution(input.treasury).addReward(aTokenProxyAddress);\n\n\t\taddress stableDebtTokenProxyAddress = _initTokenWithProxy(\n\t\t\tinput.stableDebtTokenImpl,\n\t\t\tabi.encodeWithSelector(\n\t\t\t\tIInitializableDebtToken.initialize.selector,\n\t\t\t\t_pool,\n\t\t\t\tinput.underlyingAsset,\n\t\t\t\tIChefIncentivesController(input.incentivesController),\n\t\t\t\tinput.underlyingAssetDecimals,\n\t\t\t\tinput.stableDebtTokenName,\n\t\t\t\tinput.stableDebtTokenSymbol,\n\t\t\t\tinput.params\n\t\t\t)\n\t\t);\n\t\t// stableDebt is not added to incentives controller\n\t\t// GEIST does not support stable lending\n\n\t\taddress variableDebtTokenProxyAddress = _initTokenWithProxy(\n\t\t\tinput.variableDebtTokenImpl,\n\t\t\tabi.encodeWithSelector(\n\t\t\t\tIInitializableDebtToken.initialize.selector,\n\t\t\t\t_pool,\n\t\t\t\tinput.underlyingAsset,\n\t\t\t\tIChefIncentivesController(input.incentivesController),\n\t\t\t\tinput.underlyingAssetDecimals,\n\t\t\t\tinput.variableDebtTokenName,\n\t\t\t\tinput.variableDebtTokenSymbol,\n\t\t\t\tinput.params\n\t\t\t)\n\t\t);\n\t\tincentivesController.addPool(variableDebtTokenProxyAddress, input.allocPoint);\n\n\t\t_pool.initReserve(\n\t\t\tinput.underlyingAsset,\n\t\t\taTokenProxyAddress,\n\t\t\tstableDebtTokenProxyAddress,\n\t\t\tvariableDebtTokenProxyAddress,\n\t\t\tinput.interestRateStrategyAddress\n\t\t);\n\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(input.underlyingAsset);\n\n\t\tcurrentConfig.setDecimals(input.underlyingAssetDecimals);\n\n\t\tcurrentConfig.setActive(true);\n\t\tcurrentConfig.setFrozen(false);\n\n\t\tpool.setConfiguration(input.underlyingAsset, currentConfig.data);\n\n\t\temit ReserveInitialized(\n\t\t\tinput.underlyingAsset,\n\t\t\taTokenProxyAddress,\n\t\t\tstableDebtTokenProxyAddress,\n\t\t\tvariableDebtTokenProxyAddress,\n\t\t\tinput.interestRateStrategyAddress\n\t\t);\n\t}\n\n\t/**\n\t * @dev Updates the aToken implementation for the reserve\n\t **/\n\tfunction updateAToken(UpdateATokenInput calldata input) external onlyPoolAdmin {\n\t\tILendingPool cachedPool = pool;\n\n\t\tDataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n\t\t(, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\n\n\t\tbytes memory encodedCall = abi.encodeWithSelector(\n\t\t\tIInitializableAToken.initialize.selector,\n\t\t\tcachedPool,\n\t\t\tinput.treasury,\n\t\t\tinput.asset,\n\t\t\tinput.incentivesController,\n\t\t\tdecimals,\n\t\t\tinput.name,\n\t\t\tinput.symbol,\n\t\t\tinput.params\n\t\t);\n\n\t\t_upgradeTokenImplementation(reserveData.aTokenAddress, input.implementation, encodedCall);\n\n\t\temit ATokenUpgraded(input.asset, reserveData.aTokenAddress, input.implementation);\n\t}\n\n\t/**\n\t * @dev Updates the stable debt token implementation for the reserve\n\t **/\n\tfunction updateStableDebtToken(UpdateDebtTokenInput calldata input) external onlyPoolAdmin {\n\t\tILendingPool cachedPool = pool;\n\n\t\tDataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n\t\t(, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\n\n\t\tbytes memory encodedCall = abi.encodeWithSelector(\n\t\t\tIInitializableDebtToken.initialize.selector,\n\t\t\tcachedPool,\n\t\t\tinput.asset,\n\t\t\tinput.incentivesController,\n\t\t\tdecimals,\n\t\t\tinput.name,\n\t\t\tinput.symbol,\n\t\t\tinput.params\n\t\t);\n\n\t\t_upgradeTokenImplementation(reserveData.stableDebtTokenAddress, input.implementation, encodedCall);\n\n\t\temit StableDebtTokenUpgraded(input.asset, reserveData.stableDebtTokenAddress, input.implementation);\n\t}\n\n\t/**\n\t * @dev Updates the variable debt token implementation for the asset\n\t **/\n\tfunction updateVariableDebtToken(UpdateDebtTokenInput calldata input) external onlyPoolAdmin {\n\t\tILendingPool cachedPool = pool;\n\n\t\tDataTypes.ReserveData memory reserveData = cachedPool.getReserveData(input.asset);\n\n\t\t(, , , uint256 decimals, ) = cachedPool.getConfiguration(input.asset).getParamsMemory();\n\n\t\tbytes memory encodedCall = abi.encodeWithSelector(\n\t\t\tIInitializableDebtToken.initialize.selector,\n\t\t\tcachedPool,\n\t\t\tinput.asset,\n\t\t\tinput.incentivesController,\n\t\t\tdecimals,\n\t\t\tinput.name,\n\t\t\tinput.symbol,\n\t\t\tinput.params\n\t\t);\n\n\t\t_upgradeTokenImplementation(reserveData.variableDebtTokenAddress, input.implementation, encodedCall);\n\n\t\temit VariableDebtTokenUpgraded(input.asset, reserveData.variableDebtTokenAddress, input.implementation);\n\t}\n\n\t/**\n\t * @dev Enables borrowing on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param stableBorrowRateEnabled True if stable borrow rate needs to be enabled by default on this reserve\n\t **/\n\tfunction enableBorrowingOnReserve(address asset, bool stableBorrowRateEnabled) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setBorrowingEnabled(true);\n\t\tcurrentConfig.setStableRateBorrowingEnabled(stableBorrowRateEnabled);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit BorrowingEnabledOnReserve(asset, stableBorrowRateEnabled);\n\t}\n\n\t/**\n\t * @dev Disables borrowing on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction disableBorrowingOnReserve(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setBorrowingEnabled(false);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\t\temit BorrowingDisabledOnReserve(asset);\n\t}\n\n\t/**\n\t * @dev Configures the reserve collateralization parameters\n\t * all the values are expressed in percentages with two decimals of precision. A valid value is 10000, which means 100.00%\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param ltv The loan to value of the asset when used as collateral\n\t * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized\n\t * @param liquidationBonus The bonus liquidators receive to liquidate this asset. The values is always above 100%. A value of 105%\n\t * means the liquidator will receive a 5% bonus\n\t **/\n\tfunction configureReserveAsCollateral(\n\t\taddress asset,\n\t\tuint256 ltv,\n\t\tuint256 liquidationThreshold,\n\t\tuint256 liquidationBonus\n\t) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\t//validation of the parameters: the LTV can\n\t\t//only be lower or equal than the liquidation threshold\n\t\t//(otherwise a loan against the asset would cause instantaneous liquidation)\n\t\trequire(ltv <= liquidationThreshold, Errors.LPC_INVALID_CONFIGURATION);\n\n\t\tif (liquidationThreshold != 0) {\n\t\t\t//liquidation bonus must be bigger than 100.00%, otherwise the liquidator would receive less\n\t\t\t//collateral than needed to cover the debt\n\t\t\trequire(liquidationBonus > PercentageMath.PERCENTAGE_FACTOR, Errors.LPC_INVALID_CONFIGURATION);\n\n\t\t\t//if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment\n\t\t\t//a loan is taken there is enough collateral available to cover the liquidation bonus\n\t\t\trequire(\n\t\t\t\tliquidationThreshold.percentMul(liquidationBonus) <= PercentageMath.PERCENTAGE_FACTOR,\n\t\t\t\tErrors.LPC_INVALID_CONFIGURATION\n\t\t\t);\n\t\t} else {\n\t\t\trequire(liquidationBonus == 0, Errors.LPC_INVALID_CONFIGURATION);\n\t\t\t//if the liquidation threshold is being set to 0,\n\t\t\t// the reserve is being disabled as collateral. To do so,\n\t\t\t//we need to ensure no liquidity is deposited\n\t\t\t_checkNoLiquidity(asset);\n\t\t}\n\n\t\tcurrentConfig.setLtv(ltv);\n\t\tcurrentConfig.setLiquidationThreshold(liquidationThreshold);\n\t\tcurrentConfig.setLiquidationBonus(liquidationBonus);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit CollateralConfigurationChanged(asset, ltv, liquidationThreshold, liquidationBonus);\n\t}\n\n\t/**\n\t * @dev Enable stable rate borrowing on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction enableReserveStableRate(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setStableRateBorrowingEnabled(true);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit StableRateEnabledOnReserve(asset);\n\t}\n\n\t/**\n\t * @dev Disable stable rate borrowing on a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction disableReserveStableRate(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setStableRateBorrowingEnabled(false);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit StableRateDisabledOnReserve(asset);\n\t}\n\n\t/**\n\t * @dev Activates a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction activateReserve(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setActive(true);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveActivated(asset);\n\t}\n\n\t/**\n\t * @dev Deactivates a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction deactivateReserve(address asset) external onlyPoolAdmin {\n\t\t_checkNoLiquidity(asset);\n\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setActive(false);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveDeactivated(asset);\n\t}\n\n\t/**\n\t * @dev Freezes a reserve. A frozen reserve doesn't allow any new deposit, borrow or rate swap\n\t *  but allows repayments, liquidations, rate rebalances and withdrawals\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction freezeReserve(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setFrozen(true);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveFrozen(asset);\n\t}\n\n\t/**\n\t * @dev Unfreezes a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t **/\n\tfunction unfreezeReserve(address asset) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setFrozen(false);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveUnfrozen(asset);\n\t}\n\n\t/**\n\t * @dev Updates the reserve factor of a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param reserveFactor The new reserve factor of the reserve\n\t **/\n\tfunction setReserveFactor(address asset, uint256 reserveFactor) external onlyPoolAdmin {\n\t\tDataTypes.ReserveConfigurationMap memory currentConfig = pool.getConfiguration(asset);\n\n\t\tcurrentConfig.setReserveFactor(reserveFactor);\n\n\t\tpool.setConfiguration(asset, currentConfig.data);\n\n\t\temit ReserveFactorChanged(asset, reserveFactor);\n\t}\n\n\t/**\n\t * @dev Sets the interest rate strategy of a reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param rateStrategyAddress The new address of the interest strategy contract\n\t **/\n\tfunction setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external onlyPoolAdmin {\n\t\tpool.setReserveInterestRateStrategyAddress(asset, rateStrategyAddress);\n\t\temit ReserveInterestRateStrategyChanged(asset, rateStrategyAddress);\n\t}\n\n\t/**\n\t * @dev pauses or unpauses all the actions of the protocol, including aToken transfers\n\t * @param val true if protocol needs to be paused, false otherwise\n\t **/\n\tfunction setPoolPause(bool val) external onlyEmergencyAdmin {\n\t\tpool.setPause(val);\n\t}\n\n\tfunction _initTokenWithProxy(address implementation, bytes memory initParams) internal returns (address) {\n\t\tInitializableImmutableAdminUpgradeabilityProxy proxy = new InitializableImmutableAdminUpgradeabilityProxy(\n\t\t\taddress(this)\n\t\t);\n\n\t\tproxy.initialize(implementation, initParams);\n\n\t\treturn address(proxy);\n\t}\n\n\tfunction _upgradeTokenImplementation(\n\t\taddress proxyAddress,\n\t\taddress implementation,\n\t\tbytes memory initParams\n\t) internal {\n\t\tInitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(\n\t\t\tpayable(proxyAddress)\n\t\t);\n\n\t\tproxy.upgradeToAndCall(implementation, initParams);\n\t}\n\n\tfunction _checkNoLiquidity(address asset) internal view {\n\t\tDataTypes.ReserveData memory reserveData = pool.getReserveData(asset);\n\n\t\tuint256 availableLiquidity = IERC20Metadata(asset).balanceOf(reserveData.aTokenAddress);\n\n\t\trequire(availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0);\n\t}\n}\n"
    },
    "contracts/lending/lendingpool/LendingPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {UserConfiguration} from \"../libraries/configuration/UserConfiguration.sol\";\nimport {ReserveConfiguration} from \"../libraries/configuration/ReserveConfiguration.sol\";\nimport {ReserveLogic} from \"../libraries/logic/ReserveLogic.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\ncontract LendingPoolStorage {\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tILendingPoolAddressesProvider internal _addressesProvider;\n\n\tmapping(address => DataTypes.ReserveData) internal _reserves;\n\tmapping(address => DataTypes.UserConfigurationMap) internal _usersConfig;\n\n\t// the list of the available reserves, structured as a mapping for gas savings reasons\n\tmapping(uint256 => address) internal _reservesList;\n\n\tuint256 internal _reservesCount;\n\n\tbool internal _paused;\n\n\tuint256 internal _maxStableRateBorrowSizePercent;\n\n\tuint256 internal _flashLoanPremiumTotal;\n\n\tuint256 internal _maxNumberOfReserves;\n}\n"
    },
    "contracts/lending/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol\";\n\n/**\n * @title BaseImmutableAdminUpgradeabilityProxy\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\n * helps saving transactions costs\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n\taddress immutable ADMIN;\n\n\tconstructor(address _admin) {\n\t\tADMIN = _admin;\n\t}\n\n\tmodifier ifAdmin() {\n\t\tif (msg.sender == ADMIN) {\n\t\t\t_;\n\t\t} else {\n\t\t\t_fallback();\n\t\t}\n\t}\n\n\t/**\n\t * @return _address The address of the proxy admin.\n\t */\n\tfunction admin() external ifAdmin returns (address _address) {\n\t\treturn ADMIN;\n\t}\n\n\t/**\n\t * @return _address The address of the implementation.\n\t */\n\tfunction implementation() external ifAdmin returns (address _address) {\n\t\treturn _implementation();\n\t}\n\n\t/**\n\t * @dev Upgrade the backing implementation of the proxy.\n\t * Only the admin can call this function.\n\t * @param newImplementation Address of the new implementation.\n\t */\n\tfunction upgradeTo(address newImplementation) external ifAdmin {\n\t\t_upgradeTo(newImplementation);\n\t}\n\n\t/**\n\t * @dev Upgrade the backing implementation of the proxy and call a function\n\t * on the new implementation.\n\t * This is useful to initialize the proxied contract.\n\t * @param newImplementation Address of the new implementation.\n\t * @param data Data to send as msg.data in the low level call.\n\t * It should include the signature and the parameters of the function to be called, as described in\n\t * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n\t */\n\tfunction upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n\t\t_upgradeTo(newImplementation);\n\t\t(bool success, ) = newImplementation.delegatecall(data);\n\t\trequire(success);\n\t}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal virtual override {\n\t\trequire(msg.sender != ADMIN, \"Cannot call fallback function from the proxy admin\");\n\t\tsuper._willFallback();\n\t}\n}\n"
    },
    "contracts/lending/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"./BaseImmutableAdminUpgradeabilityProxy.sol\";\nimport \"../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol\";\n\n/**\n * @title InitializableAdminUpgradeabilityProxy\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\n */\ncontract InitializableImmutableAdminUpgradeabilityProxy is\n\tBaseImmutableAdminUpgradeabilityProxy,\n\tInitializableUpgradeabilityProxy\n{\n\tconstructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {}\n\n\t/**\n\t * @dev Only fall back when the sender is not the admin.\n\t */\n\tfunction _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\n\t\tBaseImmutableAdminUpgradeabilityProxy._willFallback();\n\t}\n}\n"
    },
    "contracts/lending/libraries/aave-upgradeability/VersionedInitializable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title VersionedInitializable\n *\n * @dev Helper contract to implement initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n *\n * @author Aave, inspired by the OpenZeppelin Initializable contract\n */\nabstract contract VersionedInitializable {\n\t/**\n\t * @dev Indicates that the contract has been initialized.\n\t */\n\tuint256 private lastInitializedRevision = 0;\n\n\t/**\n\t * @dev Indicates that the contract is in the process of being initialized.\n\t */\n\tbool private initializing;\n\n\t/**\n\t * @dev Modifier to use in the initializer function of a contract.\n\t */\n\tmodifier initializer() {\n\t\tuint256 revision = getRevision();\n\t\trequire(\n\t\t\tinitializing || isConstructor() || revision > lastInitializedRevision,\n\t\t\t\"Contract instance has already been initialized\"\n\t\t);\n\n\t\tbool isTopLevelCall = !initializing;\n\t\tif (isTopLevelCall) {\n\t\t\tinitializing = true;\n\t\t\tlastInitializedRevision = revision;\n\t\t}\n\n\t\t_;\n\n\t\tif (isTopLevelCall) {\n\t\t\tinitializing = false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev returns the revision number of the contract\n\t * Needs to be defined in the inherited class as a constant.\n\t **/\n\tfunction getRevision() internal pure virtual returns (uint256);\n\n\t/**\n\t * @dev Returns true if and only if the function is running in the constructor\n\t **/\n\tfunction isConstructor() private view returns (bool) {\n\t\t// extcodesize checks the size of the code stored in an address, and\n\t\t// address returns the current address. Since the code is still not\n\t\t// deployed when running a constructor, any checks on its code size will\n\t\t// yield zero, making it an effective way to detect if a contract is\n\t\t// under construction or not.\n\t\tuint256 cs;\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tcs := extcodesize(address())\n\t\t}\n\t\treturn cs == 0;\n\t}\n\n\t// Reserved storage space to allow for layout changes in the future.\n\tuint256[50] private ______gap;\n}\n"
    },
    "contracts/lending/libraries/configuration/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n\tuint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n\tuint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n\tuint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n\tuint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n\tuint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n\n\t/// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n\tuint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n\tuint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n\tuint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n\tuint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\n\tuint256 constant IS_FROZEN_START_BIT_POSITION = 57;\n\tuint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n\tuint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n\tuint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n\n\tuint256 constant MAX_VALID_LTV = 65535;\n\tuint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n\tuint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n\tuint256 constant MAX_VALID_DECIMALS = 255;\n\tuint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\n\n\t/**\n\t * @dev Sets the Loan to Value of the reserve\n\t * @param self The reserve configuration\n\t * @param ltv the new ltv\n\t **/\n\tfunction setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\n\t\trequire(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\n\n\t\tself.data = (self.data & LTV_MASK) | ltv;\n\t}\n\n\t/**\n\t * @dev Gets the Loan to Value of the reserve\n\t * @param self The reserve configuration\n\t * @return The loan to value\n\t **/\n\tfunction getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn self.data & ~LTV_MASK;\n\t}\n\n\t/**\n\t * @dev Sets the liquidation threshold of the reserve\n\t * @param self The reserve configuration\n\t * @param threshold The new liquidation threshold\n\t **/\n\tfunction setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) internal pure {\n\t\trequire(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\n\n\t\tself.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the liquidation threshold of the reserve\n\t * @param self The reserve configuration\n\t * @return The liquidation threshold\n\t **/\n\tfunction getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n\t}\n\n\t/**\n\t * @dev Sets the liquidation bonus of the reserve\n\t * @param self The reserve configuration\n\t * @param bonus The new liquidation bonus\n\t **/\n\tfunction setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) internal pure {\n\t\trequire(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\n\n\t\tself.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the liquidation bonus of the reserve\n\t * @param self The reserve configuration\n\t * @return The liquidation bonus\n\t **/\n\tfunction getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\n\t}\n\n\t/**\n\t * @dev Sets the decimals of the underlying asset of the reserve\n\t * @param self The reserve configuration\n\t * @param decimals The decimals\n\t **/\n\tfunction setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) internal pure {\n\t\trequire(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\n\n\t\tself.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the decimals of the underlying asset of the reserve\n\t * @param self The reserve configuration\n\t * @return The decimals of the asset\n\t **/\n\tfunction getDecimals(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n\t}\n\n\t/**\n\t * @dev Sets the active state of the reserve\n\t * @param self The reserve configuration\n\t * @param active The active state\n\t **/\n\tfunction setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\n\t\tself.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the active state of the reserve\n\t * @param self The reserve configuration\n\t * @return The active state\n\t **/\n\tfunction getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\n\t\treturn (self.data & ~ACTIVE_MASK) != 0;\n\t}\n\n\t/**\n\t * @dev Sets the frozen state of the reserve\n\t * @param self The reserve configuration\n\t * @param frozen The frozen state\n\t **/\n\tfunction setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\n\t\tself.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the frozen state of the reserve\n\t * @param self The reserve configuration\n\t * @return The frozen state\n\t **/\n\tfunction getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\n\t\treturn (self.data & ~FROZEN_MASK) != 0;\n\t}\n\n\t/**\n\t * @dev Enables or disables borrowing on the reserve\n\t * @param self The reserve configuration\n\t * @param enabled True if the borrowing needs to be enabled, false otherwise\n\t **/\n\tfunction setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\n\t\tself.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the borrowing state of the reserve\n\t * @param self The reserve configuration\n\t * @return The borrowing state\n\t **/\n\tfunction getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\n\t\treturn (self.data & ~BORROWING_MASK) != 0;\n\t}\n\n\t/**\n\t * @dev Enables or disables stable rate borrowing on the reserve\n\t * @param self The reserve configuration\n\t * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n\t **/\n\tfunction setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\n\t\tself.data =\n\t\t\t(self.data & STABLE_BORROWING_MASK) |\n\t\t\t(uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the stable rate borrowing state of the reserve\n\t * @param self The reserve configuration\n\t * @return The stable rate borrowing state\n\t **/\n\tfunction getStableRateBorrowingEnabled(\n\t\tDataTypes.ReserveConfigurationMap storage self\n\t) internal view returns (bool) {\n\t\treturn (self.data & ~STABLE_BORROWING_MASK) != 0;\n\t}\n\n\t/**\n\t * @dev Sets the reserve factor of the reserve\n\t * @param self The reserve configuration\n\t * @param reserveFactor The reserve factor\n\t **/\n\tfunction setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) internal pure {\n\t\trequire(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\n\n\t\tself.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n\t}\n\n\t/**\n\t * @dev Gets the reserve factor of the reserve\n\t * @param self The reserve configuration\n\t * @return The reserve factor\n\t **/\n\tfunction getReserveFactor(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\n\t\treturn (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n\t}\n\n\t/**\n\t * @dev Gets the configuration flags of the reserve\n\t * @param self The reserve configuration\n\t * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\n\t **/\n\tfunction getFlags(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool, bool, bool, bool) {\n\t\tuint256 dataLocal = self.data;\n\n\t\treturn (\n\t\t\t(dataLocal & ~ACTIVE_MASK) != 0,\n\t\t\t(dataLocal & ~FROZEN_MASK) != 0,\n\t\t\t(dataLocal & ~BORROWING_MASK) != 0,\n\t\t\t(dataLocal & ~STABLE_BORROWING_MASK) != 0\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the configuration paramters of the reserve\n\t * @param self The reserve configuration\n\t * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\n\t **/\n\tfunction getParams(\n\t\tDataTypes.ReserveConfigurationMap storage self\n\t) internal view returns (uint256, uint256, uint256, uint256, uint256) {\n\t\tuint256 dataLocal = self.data;\n\n\t\treturn (\n\t\t\tdataLocal & ~LTV_MASK,\n\t\t\t(dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n\t\t\t(dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n\t\t\t(dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n\t\t\t(dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the configuration paramters of the reserve from a memory object\n\t * @param self The reserve configuration\n\t * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\n\t **/\n\tfunction getParamsMemory(\n\t\tDataTypes.ReserveConfigurationMap memory self\n\t) internal pure returns (uint256, uint256, uint256, uint256, uint256) {\n\t\treturn (\n\t\t\tself.data & ~LTV_MASK,\n\t\t\t(self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n\t\t\t(self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n\t\t\t(self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n\t\t\t(self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the configuration flags of the reserve from a memory object\n\t * @param self The reserve configuration\n\t * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\n\t **/\n\tfunction getFlagsMemory(\n\t\tDataTypes.ReserveConfigurationMap memory self\n\t) internal pure returns (bool, bool, bool, bool) {\n\t\treturn (\n\t\t\t(self.data & ~ACTIVE_MASK) != 0,\n\t\t\t(self.data & ~FROZEN_MASK) != 0,\n\t\t\t(self.data & ~BORROWING_MASK) != 0,\n\t\t\t(self.data & ~STABLE_BORROWING_MASK) != 0\n\t\t);\n\t}\n}\n"
    },
    "contracts/lending/libraries/configuration/UserConfiguration.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title UserConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the user configuration\n */\nlibrary UserConfiguration {\n\tuint256 internal constant BORROWING_MASK = 0x5555555555555555555555555555555555555555555555555555555555555555;\n\n\t/**\n\t * @dev Sets if the user is borrowing the reserve identified by reserveIndex\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @param borrowing True if the user is borrowing the reserve, false otherwise\n\t **/\n\tfunction setBorrowing(DataTypes.UserConfigurationMap storage self, uint256 reserveIndex, bool borrowing) internal {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\tself.data = (self.data & ~(1 << (reserveIndex * 2))) | (uint256(borrowing ? 1 : 0) << (reserveIndex * 2));\n\t}\n\n\t/**\n\t * @dev Sets if the user is using as collateral the reserve identified by reserveIndex\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise\n\t **/\n\tfunction setUsingAsCollateral(\n\t\tDataTypes.UserConfigurationMap storage self,\n\t\tuint256 reserveIndex,\n\t\tbool usingAsCollateral\n\t) internal {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\tself.data =\n\t\t\t(self.data & ~(1 << (reserveIndex * 2 + 1))) |\n\t\t\t(uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1));\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has been using the reserve for borrowing or as collateral\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\n\t **/\n\tfunction isUsingAsCollateralOrBorrowing(\n\t\tDataTypes.UserConfigurationMap memory self,\n\t\tuint256 reserveIndex\n\t) internal pure returns (bool) {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\treturn (self.data >> (reserveIndex * 2)) & 3 != 0;\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has been using the reserve for borrowing\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @return True if the user has been using a reserve for borrowing, false otherwise\n\t **/\n\tfunction isBorrowing(\n\t\tDataTypes.UserConfigurationMap memory self,\n\t\tuint256 reserveIndex\n\t) internal pure returns (bool) {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\treturn (self.data >> (reserveIndex * 2)) & 1 != 0;\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has been using the reserve as collateral\n\t * @param self The configuration object\n\t * @param reserveIndex The index of the reserve in the bitmap\n\t * @return True if the user has been using a reserve as collateral, false otherwise\n\t **/\n\tfunction isUsingAsCollateral(\n\t\tDataTypes.UserConfigurationMap memory self,\n\t\tuint256 reserveIndex\n\t) internal pure returns (bool) {\n\t\trequire(reserveIndex < 128, Errors.UL_INVALID_INDEX);\n\t\treturn (self.data >> (reserveIndex * 2 + 1)) & 1 != 0;\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has been borrowing from any reserve\n\t * @param self The configuration object\n\t * @return True if the user has been borrowing any reserve, false otherwise\n\t **/\n\tfunction isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n\t\treturn self.data & BORROWING_MASK != 0;\n\t}\n\n\t/**\n\t * @dev Used to validate if a user has not been using any reserve\n\t * @param self The configuration object\n\t * @return True if the user has been borrowing any reserve, false otherwise\n\t **/\n\tfunction isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\n\t\treturn self.data == 0;\n\t}\n}\n"
    },
    "contracts/lending/libraries/helpers/Errors.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n * @dev Error messages prefix glossary:\n *  - VL = ValidationLogic\n *  - MATH = Math libraries\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\n *  - AT = AToken\n *  - SDT = StableDebtToken\n *  - VDT = VariableDebtToken\n *  - LP = LendingPool\n *  - LPAPR = LendingPoolAddressesProviderRegistry\n *  - LPC = LendingPoolConfiguration\n *  - RL = ReserveLogic\n *  - LPCM = LendingPoolCollateralManager\n *  - P = Pausable\n */\nlibrary Errors {\n    //common errors\n    string public constant CALLER_NOT_POOL_ADMIN = \"33\"; // 'The caller must be the pool admin'\n    string public constant BORROW_ALLOWANCE_NOT_ENOUGH = \"59\"; // User borrows on behalf, but allowance are too small\n\n    //contract specific errors\n    string public constant VL_INVALID_AMOUNT = \"1\"; // 'Amount must be greater than 0'\n    string public constant VL_NO_ACTIVE_RESERVE = \"2\"; // 'Action requires an active reserve'\n    string public constant VL_RESERVE_FROZEN = \"3\"; // 'Action cannot be performed because the reserve is frozen'\n    string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = \"4\"; // 'The current liquidity is not enough'\n    string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = \"5\"; // 'User cannot withdraw more than the available balance'\n    string public constant VL_TRANSFER_NOT_ALLOWED = \"6\"; // 'Transfer cannot be allowed.'\n    string public constant VL_BORROWING_NOT_ENABLED = \"7\"; // 'Borrowing is not enabled'\n    string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = \"8\"; // 'Invalid interest rate mode selected'\n    string public constant VL_COLLATERAL_BALANCE_IS_0 = \"9\"; // 'The collateral balance is 0'\n    string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD =\n        \"10\"; // 'Health factor is lesser than the liquidation threshold'\n    string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = \"11\"; // 'There is not enough collateral to cover a new borrow'\n    string public constant VL_STABLE_BORROWING_NOT_ENABLED = \"12\"; // stable borrowing not enabled\n    string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = \"13\"; // collateral is (mostly) the same currency that is being borrowed\n    string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \"14\"; // 'The requested amount is greater than the max loan size in stable rate mode\n    string public constant VL_NO_DEBT_OF_SELECTED_TYPE = \"15\"; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\n    string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \"16\"; // 'To repay on behalf of an user an explicit amount to repay is needed'\n    string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = \"17\"; // 'User does not have a stable rate loan in progress on this reserve'\n    string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = \"18\"; // 'User does not have a variable rate loan in progress on this reserve'\n    string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = \"19\"; // 'The underlying balance needs to be greater than 0'\n    string public constant VL_DEPOSIT_ALREADY_IN_USE = \"20\"; // 'User deposit is already being used as collateral'\n    string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = \"21\"; // 'User does not have any stable rate loan for this reserve'\n    string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \"22\"; // 'Interest rate rebalance conditions were not met'\n    string public constant LP_LIQUIDATION_CALL_FAILED = \"23\"; // 'Liquidation call failed'\n    string public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = \"24\"; // 'There is not enough liquidity available to borrow'\n    string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = \"25\"; // 'The requested amount is too small for a FlashLoan.'\n    string public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = \"26\"; // 'The actual balance of the protocol is inconsistent'\n    string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = \"27\"; // 'The caller of the function is not the lending pool configurator'\n    string public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = \"28\";\n    string public constant CT_CALLER_MUST_BE_LENDING_POOL = \"29\"; // 'The caller of this function must be a lending pool'\n    string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = \"30\"; // 'User cannot give allowance to himself'\n    string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = \"31\"; // 'Transferred amount needs to be greater than zero'\n    string public constant RL_RESERVE_ALREADY_INITIALIZED = \"32\"; // 'Reserve has already been initialized'\n    string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = \"34\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = \"35\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = \"36\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = \"37\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS =\n        \"38\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS =\n        \"39\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = \"40\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant LPC_INVALID_CONFIGURATION = \"75\"; // 'Invalid risk parameters for the reserve'\n    string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = \"76\"; // 'The caller must be the emergency admin'\n    string public constant LPAPR_PROVIDER_NOT_REGISTERED = \"41\"; // 'Provider is not registered'\n    string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \"42\"; // 'Health factor is not below the threshold'\n    string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = \"43\"; // 'The collateral chosen cannot be liquidated'\n    string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \"44\"; // 'User did not borrow the specified currency'\n    string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = \"45\"; // \"There isn't enough liquidity available to liquidate\"\n    string public constant LPCM_NO_ERRORS = \"46\"; // 'No errors'\n    string public constant LP_INVALID_FLASHLOAN_MODE = \"47\"; //Invalid flashloan mode selected\n    string public constant MATH_MULTIPLICATION_OVERFLOW = \"48\";\n    string public constant MATH_ADDITION_OVERFLOW = \"49\";\n    string public constant MATH_DIVISION_BY_ZERO = \"50\";\n    string public constant RL_LIQUIDITY_INDEX_OVERFLOW = \"51\"; //  Liquidity index overflows uint128\n    string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = \"52\"; //  Variable borrow index overflows uint128\n    string public constant RL_LIQUIDITY_RATE_OVERFLOW = \"53\"; //  Liquidity rate overflows uint128\n    string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = \"54\"; //  Variable borrow rate overflows uint128\n    string public constant RL_STABLE_BORROW_RATE_OVERFLOW = \"55\"; //  Stable borrow rate overflows uint128\n    string public constant CT_INVALID_MINT_AMOUNT = \"56\"; //invalid amount to mint\n    string public constant LP_FAILED_REPAY_WITH_COLLATERAL = \"57\";\n    string public constant CT_INVALID_BURN_AMOUNT = \"58\"; //invalid amount to burn\n    string public constant LP_FAILED_COLLATERAL_SWAP = \"60\";\n    string public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = \"61\";\n    string public constant LP_REENTRANCY_NOT_ALLOWED = \"62\";\n    string public constant LP_CALLER_MUST_BE_AN_ATOKEN = \"63\";\n    string public constant LP_IS_PAUSED = \"64\"; // 'Pool is paused'\n    string public constant LP_NO_MORE_RESERVES_ALLOWED = \"65\";\n    string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = \"66\";\n    string public constant RC_INVALID_LTV = \"67\";\n    string public constant RC_INVALID_LIQ_THRESHOLD = \"68\";\n    string public constant RC_INVALID_LIQ_BONUS = \"69\";\n    string public constant RC_INVALID_DECIMALS = \"70\";\n    string public constant RC_INVALID_RESERVE_FACTOR = \"71\";\n    string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = \"72\";\n    string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = \"73\";\n    string public constant LP_INCONSISTENT_PARAMS_LENGTH = \"74\";\n    string public constant UL_INVALID_INDEX = \"77\";\n    string public constant LP_NOT_CONTRACT = \"78\";\n    string public constant SDT_STABLE_DEBT_OVERFLOW = \"79\";\n    string public constant SDT_BURN_EXCEEDS_BALANCE = \"80\";\n\n    enum CollateralManagerErrors {\n        NO_ERROR,\n        NO_COLLATERAL_AVAILABLE,\n        COLLATERAL_CANNOT_BE_LIQUIDATED,\n        CURRRENCY_NOT_BORROWED,\n        HEALTH_FACTOR_ABOVE_THRESHOLD,\n        NOT_ENOUGH_LIQUIDITY,\n        NO_ACTIVE_RESERVE,\n        HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\n        INVALID_EQUAL_ASSETS_TO_SWAP,\n        FROZEN_RESERVE\n    }\n}\n"
    },
    "contracts/lending/libraries/helpers/Helpers.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title Helpers library\n * @author Aave\n */\nlibrary Helpers {\n\t/**\n\t * @dev Fetches the user current stable and variable debt balances\n\t * @param user The user address\n\t * @param reserve The reserve data object\n\t * @return The stable and variable debt balance\n\t **/\n\tfunction getUserCurrentDebt(\n\t\taddress user,\n\t\tDataTypes.ReserveData storage reserve\n\t) internal view returns (uint256, uint256) {\n\t\treturn (\n\t\t\tIERC20(reserve.stableDebtTokenAddress).balanceOf(user),\n\t\t\tIERC20(reserve.variableDebtTokenAddress).balanceOf(user)\n\t\t);\n\t}\n\n\tfunction getUserCurrentDebtMemory(\n\t\taddress user,\n\t\tDataTypes.ReserveData memory reserve\n\t) internal view returns (uint256, uint256) {\n\t\treturn (\n\t\t\tIERC20(reserve.stableDebtTokenAddress).balanceOf(user),\n\t\t\tIERC20(reserve.variableDebtTokenAddress).balanceOf(user)\n\t\t);\n\t}\n}\n"
    },
    "contracts/lending/libraries/logic/GenericLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {IPriceOracleGetter} from \"../../../interfaces/IPriceOracleGetter.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title GenericLogic library\n * @author Aave\n * @title Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tuint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\n\n\tstruct balanceDecreaseAllowedLocalVars {\n\t\tuint256 decimals;\n\t\tuint256 liquidationThreshold;\n\t\tuint256 totalCollateralInETH;\n\t\tuint256 totalDebtInETH;\n\t\tuint256 avgLiquidationThreshold;\n\t\tuint256 amountToDecreaseInETH;\n\t\tuint256 collateralBalanceAfterDecrease;\n\t\tuint256 liquidationThresholdAfterDecrease;\n\t\tuint256 healthFactorAfterDecrease;\n\t\tbool reserveUsageAsCollateralEnabled;\n\t}\n\n\t/**\n\t * @dev Checks if a specific balance decrease is allowed\n\t * (i.e. doesn't bring the user borrow position health factor under HEALTH_FACTOR_LIQUIDATION_THRESHOLD)\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param user The address of the user\n\t * @param amount The amount to decrease\n\t * @param reservesData The data of all the reserves\n\t * @param userConfig The user configuration\n\t * @param reserves The list of all the active reserves\n\t * @param oracle The address of the oracle contract\n\t * @return true if the decrease of the balance is allowed\n\t **/\n\tfunction balanceDecreaseAllowed(\n\t\taddress asset,\n\t\taddress user,\n\t\tuint256 amount,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap calldata userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) external view returns (bool) {\n\t\tif (!userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral(reservesData[asset].id)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tbalanceDecreaseAllowedLocalVars memory vars;\n\n\t\t(, vars.liquidationThreshold, , vars.decimals, ) = reservesData[asset].configuration.getParams();\n\n\t\tif (vars.liquidationThreshold == 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\t(vars.totalCollateralInETH, vars.totalDebtInETH, , vars.avgLiquidationThreshold, ) = calculateUserAccountData(\n\t\t\tuser,\n\t\t\treservesData,\n\t\t\tuserConfig,\n\t\t\treserves,\n\t\t\treservesCount,\n\t\t\toracle\n\t\t);\n\n\t\tif (vars.totalDebtInETH == 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tvars.amountToDecreaseInETH = IPriceOracleGetter(oracle).getAssetPrice(asset).mul(amount).div(\n\t\t\t10 ** vars.decimals\n\t\t);\n\n\t\tvars.collateralBalanceAfterDecrease = vars.totalCollateralInETH.sub(vars.amountToDecreaseInETH);\n\n\t\t//if there is a borrow, there can't be 0 collateral\n\t\tif (vars.collateralBalanceAfterDecrease == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvars.liquidationThresholdAfterDecrease = vars\n\t\t\t.totalCollateralInETH\n\t\t\t.mul(vars.avgLiquidationThreshold)\n\t\t\t.sub(vars.amountToDecreaseInETH.mul(vars.liquidationThreshold))\n\t\t\t.div(vars.collateralBalanceAfterDecrease);\n\n\t\tuint256 healthFactorAfterDecrease = calculateHealthFactorFromBalances(\n\t\t\tvars.collateralBalanceAfterDecrease,\n\t\t\tvars.totalDebtInETH,\n\t\t\tvars.liquidationThresholdAfterDecrease\n\t\t);\n\n\t\treturn healthFactorAfterDecrease >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\n\t}\n\n\tstruct CalculateUserAccountDataVars {\n\t\tuint256 reserveUnitPrice;\n\t\tuint256 tokenUnit;\n\t\tuint256 compoundedLiquidityBalance;\n\t\tuint256 compoundedBorrowBalance;\n\t\tuint256 decimals;\n\t\tuint256 ltv;\n\t\tuint256 liquidationThreshold;\n\t\tuint256 i;\n\t\tuint256 healthFactor;\n\t\tuint256 totalCollateralInETH;\n\t\tuint256 totalDebtInETH;\n\t\tuint256 avgLtv;\n\t\tuint256 avgLiquidationThreshold;\n\t\tuint256 reservesLength;\n\t\tbool healthFactorBelowThreshold;\n\t\taddress currentReserveAddress;\n\t\tbool usageAsCollateralEnabled;\n\t\tbool userUsesReserveAsCollateral;\n\t}\n\n\t/**\n\t * @dev Calculates the user data across the reserves.\n\t * this includes the total liquidity/collateral/borrow balances in ETH,\n\t * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\n\t * @param user The address of the user\n\t * @param reservesData Data of all the reserves\n\t * @param userConfig The configuration of the user\n\t * @param reserves The list of the available reserves\n\t * @param oracle The price oracle address\n\t * @return The total collateral and total debt of the user in ETH, the avg ltv, liquidation threshold and the HF\n\t **/\n\tfunction calculateUserAccountData(\n\t\taddress user,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap memory userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) internal view returns (uint256, uint256, uint256, uint256, uint256) {\n\t\tCalculateUserAccountDataVars memory vars;\n\n\t\tif (userConfig.isEmpty()) {\n\t\t\treturn (0, 0, 0, 0, type(uint256).max);\n\t\t}\n\t\tfor (vars.i = 0; vars.i < reservesCount; vars.i++) {\n\t\t\tif (!userConfig.isUsingAsCollateralOrBorrowing(vars.i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvars.currentReserveAddress = reserves[vars.i];\n\t\t\tDataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress];\n\n\t\t\t(vars.ltv, vars.liquidationThreshold, , vars.decimals, ) = currentReserve.configuration.getParams();\n\n\t\t\tvars.tokenUnit = 10 ** vars.decimals;\n\t\t\tvars.reserveUnitPrice = IPriceOracleGetter(oracle).getAssetPrice(vars.currentReserveAddress);\n\n\t\t\tif (vars.liquidationThreshold != 0 && userConfig.isUsingAsCollateral(vars.i)) {\n\t\t\t\tvars.compoundedLiquidityBalance = IERC20(currentReserve.aTokenAddress).balanceOf(user);\n\n\t\t\t\tuint256 liquidityBalanceETH = vars.reserveUnitPrice.mul(vars.compoundedLiquidityBalance).div(\n\t\t\t\t\tvars.tokenUnit\n\t\t\t\t);\n\n\t\t\t\tvars.totalCollateralInETH = vars.totalCollateralInETH.add(liquidityBalanceETH);\n\n\t\t\t\tvars.avgLtv = vars.avgLtv.add(liquidityBalanceETH.mul(vars.ltv));\n\t\t\t\tvars.avgLiquidationThreshold = vars.avgLiquidationThreshold.add(\n\t\t\t\t\tliquidityBalanceETH.mul(vars.liquidationThreshold)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (userConfig.isBorrowing(vars.i)) {\n\t\t\t\tvars.compoundedBorrowBalance = IERC20(currentReserve.stableDebtTokenAddress).balanceOf(user);\n\t\t\t\tvars.compoundedBorrowBalance = vars.compoundedBorrowBalance.add(\n\t\t\t\t\tIERC20(currentReserve.variableDebtTokenAddress).balanceOf(user)\n\t\t\t\t);\n\n\t\t\t\tvars.totalDebtInETH = vars.totalDebtInETH.add(\n\t\t\t\t\tvars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tvars.avgLtv = vars.totalCollateralInETH > 0 ? vars.avgLtv.div(vars.totalCollateralInETH) : 0;\n\t\tvars.avgLiquidationThreshold = vars.totalCollateralInETH > 0\n\t\t\t? vars.avgLiquidationThreshold.div(vars.totalCollateralInETH)\n\t\t\t: 0;\n\n\t\tvars.healthFactor = calculateHealthFactorFromBalances(\n\t\t\tvars.totalCollateralInETH,\n\t\t\tvars.totalDebtInETH,\n\t\t\tvars.avgLiquidationThreshold\n\t\t);\n\t\treturn (\n\t\t\tvars.totalCollateralInETH,\n\t\t\tvars.totalDebtInETH,\n\t\t\tvars.avgLtv,\n\t\t\tvars.avgLiquidationThreshold,\n\t\t\tvars.healthFactor\n\t\t);\n\t}\n\n\t/**\n\t * @dev Calculates the health factor from the corresponding balances\n\t * @param totalCollateralInETH The total collateral in ETH\n\t * @param totalDebtInETH The total debt in ETH\n\t * @param liquidationThreshold The avg liquidation threshold\n\t * @return The health factor calculated from the balances provided\n\t **/\n\tfunction calculateHealthFactorFromBalances(\n\t\tuint256 totalCollateralInETH,\n\t\tuint256 totalDebtInETH,\n\t\tuint256 liquidationThreshold\n\t) internal pure returns (uint256) {\n\t\tif (totalDebtInETH == 0) return type(uint256).max;\n\n\t\treturn (totalCollateralInETH.percentMul(liquidationThreshold)).wadDiv(totalDebtInETH);\n\t}\n\n\t/**\n\t * @dev Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\n\t * average Loan To Value\n\t * @param totalCollateralInETH The total collateral in ETH\n\t * @param totalDebtInETH The total borrow balance\n\t * @param ltv The average loan to value\n\t * @return the amount available to borrow in ETH for the user\n\t **/\n\n\tfunction calculateAvailableBorrowsETH(\n\t\tuint256 totalCollateralInETH,\n\t\tuint256 totalDebtInETH,\n\t\tuint256 ltv\n\t) internal pure returns (uint256) {\n\t\tuint256 availableBorrowsETH = totalCollateralInETH.percentMul(ltv);\n\n\t\tif (availableBorrowsETH < totalDebtInETH) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tavailableBorrowsETH = availableBorrowsETH.sub(totalDebtInETH);\n\t\treturn availableBorrowsETH;\n\t}\n}\n"
    },
    "contracts/lending/libraries/logic/ReserveLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IAToken} from \"../../../interfaces/IAToken.sol\";\nimport {IStableDebtToken} from \"../../../interfaces/IStableDebtToken.sol\";\nimport {IVariableDebtToken} from \"../../../interfaces/IVariableDebtToken.sol\";\nimport {IReserveInterestRateStrategy} from \"../../../interfaces/IReserveInterestRateStrategy.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {MathUtils} from \"../math/MathUtils.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements the logic to update the reserves state\n */\nlibrary ReserveLogic {\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t/**\n\t * @dev Emitted when the state of a reserve is updated\n\t * @param asset The address of the underlying asset of the reserve\n\t * @param liquidityRate The new liquidity rate\n\t * @param stableBorrowRate The new stable borrow rate\n\t * @param variableBorrowRate The new variable borrow rate\n\t * @param liquidityIndex The new liquidity index\n\t * @param variableBorrowIndex The new variable borrow index\n\t **/\n\tevent ReserveDataUpdated(\n\t\taddress indexed asset,\n\t\tuint256 liquidityRate,\n\t\tuint256 stableBorrowRate,\n\t\tuint256 variableBorrowRate,\n\t\tuint256 liquidityIndex,\n\t\tuint256 variableBorrowIndex\n\t);\n\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n\t/**\n\t * @dev Returns the ongoing normalized income for the reserve\n\t * A value of 1e27 means there is no income. As time passes, the income is accrued\n\t * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\n\t * @param reserve The reserve object\n\t * @return the normalized income. expressed in ray\n\t **/\n\tfunction getNormalizedIncome(DataTypes.ReserveData storage reserve) internal view returns (uint256) {\n\t\tuint40 timestamp = reserve.lastUpdateTimestamp;\n\n\t\t//solium-disable-next-line\n\t\tif (timestamp == uint40(block.timestamp)) {\n\t\t\t//if the index was updated in the same block, no need to perform any calculation\n\t\t\treturn reserve.liquidityIndex;\n\t\t}\n\n\t\tuint256 cumulated = MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(\n\t\t\treserve.liquidityIndex\n\t\t);\n\n\t\treturn cumulated;\n\t}\n\n\t/**\n\t * @dev Returns the ongoing normalized variable debt for the reserve\n\t * A value of 1e27 means there is no debt. As time passes, the income is accrued\n\t * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\n\t * @param reserve The reserve object\n\t * @return The normalized variable debt. expressed in ray\n\t **/\n\tfunction getNormalizedDebt(DataTypes.ReserveData storage reserve) internal view returns (uint256) {\n\t\tuint40 timestamp = reserve.lastUpdateTimestamp;\n\n\t\t//solium-disable-next-line\n\t\tif (timestamp == uint40(block.timestamp)) {\n\t\t\t//if the index was updated in the same block, no need to perform any calculation\n\t\t\treturn reserve.variableBorrowIndex;\n\t\t}\n\n\t\tuint256 cumulated = MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\n\t\t\treserve.variableBorrowIndex\n\t\t);\n\n\t\treturn cumulated;\n\t}\n\n\t/**\n\t * @dev Updates the liquidity cumulative index and the variable borrow index.\n\t * @param reserve the reserve object\n\t **/\n\tfunction updateState(DataTypes.ReserveData storage reserve) internal {\n\t\tuint256 scaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply();\n\t\tuint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\n\t\tuint256 previousLiquidityIndex = reserve.liquidityIndex;\n\t\tuint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\n\n\t\t(uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) = _updateIndexes(\n\t\t\treserve,\n\t\t\tscaledVariableDebt,\n\t\t\tpreviousLiquidityIndex,\n\t\t\tpreviousVariableBorrowIndex,\n\t\t\tlastUpdatedTimestamp\n\t\t);\n\n\t\t_mintToTreasury(\n\t\t\treserve,\n\t\t\tscaledVariableDebt,\n\t\t\tpreviousVariableBorrowIndex,\n\t\t\tnewLiquidityIndex,\n\t\t\tnewVariableBorrowIndex,\n\t\t\tlastUpdatedTimestamp\n\t\t);\n\t}\n\n\t/**\n\t * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\n\t * the flashloan fee to the reserve, and spread it between all the depositors\n\t * @param reserve The reserve object\n\t * @param totalLiquidity The total liquidity available in the reserve\n\t * @param amount The amount to accomulate\n\t **/\n\tfunction cumulateToLiquidityIndex(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tuint256 totalLiquidity,\n\t\tuint256 amount\n\t) internal {\n\t\tuint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());\n\n\t\tuint256 result = amountToLiquidityRatio.add(WadRayMath.ray());\n\n\t\tresult = result.rayMul(reserve.liquidityIndex);\n\t\trequire(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\n\n\t\treserve.liquidityIndex = uint128(result);\n\t}\n\n\t/**\n\t * @dev Initializes a reserve\n\t * @param reserve The reserve object\n\t * @param aTokenAddress The address of the overlying atoken contract\n\t * @param interestRateStrategyAddress The address of the interest rate strategy contract\n\t **/\n\tfunction init(\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress aTokenAddress,\n\t\taddress stableDebtTokenAddress,\n\t\taddress variableDebtTokenAddress,\n\t\taddress interestRateStrategyAddress\n\t) external {\n\t\trequire(reserve.aTokenAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\n\n\t\treserve.liquidityIndex = uint128(WadRayMath.ray());\n\t\treserve.variableBorrowIndex = uint128(WadRayMath.ray());\n\t\treserve.aTokenAddress = aTokenAddress;\n\t\treserve.stableDebtTokenAddress = stableDebtTokenAddress;\n\t\treserve.variableDebtTokenAddress = variableDebtTokenAddress;\n\t\treserve.interestRateStrategyAddress = interestRateStrategyAddress;\n\t}\n\n\tstruct UpdateInterestRatesLocalVars {\n\t\taddress stableDebtTokenAddress;\n\t\tuint256 availableLiquidity;\n\t\tuint256 totalStableDebt;\n\t\tuint256 newLiquidityRate;\n\t\tuint256 newStableRate;\n\t\tuint256 newVariableRate;\n\t\tuint256 avgStableRate;\n\t\tuint256 totalVariableDebt;\n\t}\n\n\t/**\n\t * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\n\t * @param reserve The address of the reserve to be updated\n\t * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the previous action\n\t * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\n\t **/\n\tfunction updateInterestRates(\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress reserveAddress,\n\t\taddress aTokenAddress,\n\t\tuint256 liquidityAdded,\n\t\tuint256 liquidityTaken\n\t) internal {\n\t\tUpdateInterestRatesLocalVars memory vars;\n\n\t\tvars.stableDebtTokenAddress = reserve.stableDebtTokenAddress;\n\n\t\t(vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress)\n\t\t\t.getTotalSupplyAndAvgRate();\n\n\t\t//calculates the total variable debt locally using the scaled total supply instead\n\t\t//of totalSupply(), as it's noticeably cheaper. Also, the index has been\n\t\t//updated by the previous updateState() call\n\t\tvars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply().rayMul(\n\t\t\treserve.variableBorrowIndex\n\t\t);\n\n\t\t(vars.newLiquidityRate, vars.newStableRate, vars.newVariableRate) = IReserveInterestRateStrategy(\n\t\t\treserve.interestRateStrategyAddress\n\t\t).calculateInterestRates(\n\t\t\t\treserveAddress,\n\t\t\t\taTokenAddress,\n\t\t\t\tliquidityAdded,\n\t\t\t\tliquidityTaken,\n\t\t\t\tvars.totalStableDebt,\n\t\t\t\tvars.totalVariableDebt,\n\t\t\t\tvars.avgStableRate,\n\t\t\t\treserve.configuration.getReserveFactor()\n\t\t\t);\n\t\trequire(vars.newLiquidityRate <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);\n\t\trequire(vars.newStableRate <= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW);\n\t\trequire(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);\n\n\t\treserve.currentLiquidityRate = uint128(vars.newLiquidityRate);\n\t\treserve.currentStableBorrowRate = uint128(vars.newStableRate);\n\t\treserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\n\n\t\temit ReserveDataUpdated(\n\t\t\treserveAddress,\n\t\t\tvars.newLiquidityRate,\n\t\t\tvars.newStableRate,\n\t\t\tvars.newVariableRate,\n\t\t\treserve.liquidityIndex,\n\t\t\treserve.variableBorrowIndex\n\t\t);\n\t}\n\n\tstruct MintToTreasuryLocalVars {\n\t\tuint256 currentStableDebt;\n\t\tuint256 principalStableDebt;\n\t\tuint256 previousStableDebt;\n\t\tuint256 currentVariableDebt;\n\t\tuint256 previousVariableDebt;\n\t\tuint256 avgStableRate;\n\t\tuint256 cumulatedStableInterest;\n\t\tuint256 totalDebtAccrued;\n\t\tuint256 amountToMint;\n\t\tuint256 reserveFactor;\n\t\tuint40 stableSupplyUpdatedTimestamp;\n\t}\n\n\t/**\n\t * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\n\t * specific asset.\n\t * @param reserve The reserve reserve to be updated\n\t * @param scaledVariableDebt The current scaled total variable debt\n\t * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\n\t * @param newLiquidityIndex The new liquidity index\n\t * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\n\t **/\n\tfunction _mintToTreasury(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tuint256 scaledVariableDebt,\n\t\tuint256 previousVariableBorrowIndex,\n\t\tuint256 newLiquidityIndex,\n\t\tuint256 newVariableBorrowIndex,\n\t\tuint40 timestamp\n\t) internal {\n\t\tMintToTreasuryLocalVars memory vars;\n\n\t\tvars.reserveFactor = reserve.configuration.getReserveFactor();\n\n\t\tif (vars.reserveFactor == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t//fetching the principal, total stable debt and the avg stable rate\n\t\t(\n\t\t\tvars.principalStableDebt,\n\t\t\tvars.currentStableDebt,\n\t\t\tvars.avgStableRate,\n\t\t\tvars.stableSupplyUpdatedTimestamp\n\t\t) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData();\n\n\t\t//calculate the last principal variable debt\n\t\tvars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);\n\n\t\t//calculate the new total supply after accumulation of the index\n\t\tvars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);\n\n\t\t//calculate the stable debt until the last timestamp update\n\t\tvars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\n\t\t\tvars.avgStableRate,\n\t\t\tvars.stableSupplyUpdatedTimestamp,\n\t\t\ttimestamp\n\t\t);\n\n\t\tvars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest);\n\n\t\t//debt accrued is the sum of the current debt minus the sum of the debt at the last update\n\t\tvars.totalDebtAccrued = vars.currentVariableDebt.add(vars.currentStableDebt).sub(vars.previousVariableDebt).sub(\n\t\t\tvars.previousStableDebt\n\t\t);\n\n\t\tvars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\n\n\t\tif (vars.amountToMint != 0) {\n\t\t\tIAToken(reserve.aTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Updates the reserve indexes and the timestamp of the update\n\t * @param reserve The reserve reserve to be updated\n\t * @param scaledVariableDebt The scaled variable debt\n\t * @param liquidityIndex The last stored liquidity index\n\t * @param variableBorrowIndex The last stored variable borrow index\n\t **/\n\tfunction _updateIndexes(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tuint256 scaledVariableDebt,\n\t\tuint256 liquidityIndex,\n\t\tuint256 variableBorrowIndex,\n\t\tuint40 timestamp\n\t) internal returns (uint256, uint256) {\n\t\tuint256 currentLiquidityRate = reserve.currentLiquidityRate;\n\n\t\tuint256 newLiquidityIndex = liquidityIndex;\n\t\tuint256 newVariableBorrowIndex = variableBorrowIndex;\n\n\t\t//only cumulating if there is any income being produced\n\t\tif (currentLiquidityRate > 0) {\n\t\t\tuint256 cumulatedLiquidityInterest = MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp);\n\t\t\tnewLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex);\n\t\t\trequire(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\n\n\t\t\treserve.liquidityIndex = uint128(newLiquidityIndex);\n\n\t\t\t//as the liquidity rate might come only from stable rate loans, we need to ensure\n\t\t\t//that there is actual variable debt before accumulating\n\t\t\tif (scaledVariableDebt != 0) {\n\t\t\t\tuint256 cumulatedVariableBorrowInterest = MathUtils.calculateCompoundedInterest(\n\t\t\t\t\treserve.currentVariableBorrowRate,\n\t\t\t\t\ttimestamp\n\t\t\t\t);\n\t\t\t\tnewVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\n\t\t\t\trequire(newVariableBorrowIndex <= type(uint128).max, Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW);\n\t\t\t\treserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\n\t\t\t}\n\t\t}\n\n\t\t//solium-disable-next-line\n\t\treserve.lastUpdateTimestamp = uint40(block.timestamp);\n\t\treturn (newLiquidityIndex, newVariableBorrowIndex);\n\t}\n}\n"
    },
    "contracts/lending/libraries/logic/ValidationLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {GenericLogic} from \"./GenericLogic.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {Errors} from \"../helpers/Errors.sol\";\nimport {Helpers} from \"../helpers/Helpers.sol\";\nimport {IReserveInterestRateStrategy} from \"../../../interfaces/IReserveInterestRateStrategy.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n\tusing ReserveLogic for DataTypes.ReserveData;\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\tusing PercentageMath for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tuint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\n\tuint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\n\n\t/**\n\t * @dev Validates a deposit action\n\t * @param reserve The reserve object on which the user is depositing\n\t * @param amount The amount to be deposited\n\t */\n\tfunction validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n\t\t(bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n\t\trequire(amount != 0, Errors.VL_INVALID_AMOUNT);\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\t\trequire(!isFrozen, Errors.VL_RESERVE_FROZEN);\n\t}\n\n\t/**\n\t * @dev Validates a withdraw action\n\t * @param reserveAddress The address of the reserve\n\t * @param amount The amount to be withdrawn\n\t * @param userBalance The balance of the user\n\t * @param reservesData The reserves state\n\t * @param userConfig The user configuration\n\t * @param reserves The addresses of the reserves\n\t * @param reservesCount The number of reserves\n\t * @param oracle The price oracle\n\t */\n\tfunction validateWithdraw(\n\t\taddress reserveAddress,\n\t\tuint256 amount,\n\t\tuint256 userBalance,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) external view {\n\t\trequire(amount != 0, Errors.VL_INVALID_AMOUNT);\n\t\trequire(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n\t\t(bool isActive, , , ) = reservesData[reserveAddress].configuration.getFlags();\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n\t\trequire(\n\t\t\tGenericLogic.balanceDecreaseAllowed(\n\t\t\t\treserveAddress,\n\t\t\t\tmsg.sender,\n\t\t\t\tamount,\n\t\t\t\treservesData,\n\t\t\t\tuserConfig,\n\t\t\t\treserves,\n\t\t\t\treservesCount,\n\t\t\t\toracle\n\t\t\t),\n\t\t\tErrors.VL_TRANSFER_NOT_ALLOWED\n\t\t);\n\t}\n\n\tstruct ValidateBorrowLocalVars {\n\t\tuint256 currentLtv;\n\t\tuint256 currentLiquidationThreshold;\n\t\tuint256 amountOfCollateralNeededETH;\n\t\tuint256 userCollateralBalanceETH;\n\t\tuint256 userBorrowBalanceETH;\n\t\tuint256 availableLiquidity;\n\t\tuint256 healthFactor;\n\t\tbool isActive;\n\t\tbool isFrozen;\n\t\tbool borrowingEnabled;\n\t\tbool stableRateBorrowingEnabled;\n\t}\n\n\t/**\n\t * @dev Validates a borrow action\n\t * @param asset The address of the asset to borrow\n\t * @param reserve The reserve state from which the user is borrowing\n\t * @param userAddress The address of the user\n\t * @param amount The amount to be borrowed\n\t * @param amountInETH The amount to be borrowed, in ETH\n\t * @param interestRateMode The interest rate mode at which the user is borrowing\n\t * @param maxStableLoanPercent The max amount of the liquidity that can be borrowed at stable rate, in percentage\n\t * @param reservesData The state of all the reserves\n\t * @param userConfig The state of the user for the specific reserve\n\t * @param reserves The addresses of all the active reserves\n\t * @param oracle The price oracle\n\t */\n\n\tfunction validateBorrow(\n\t\taddress asset,\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress userAddress,\n\t\tuint256 amount,\n\t\tuint256 amountInETH,\n\t\tuint256 interestRateMode,\n\t\tuint256 maxStableLoanPercent,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) external view {\n\t\tValidateBorrowLocalVars memory vars;\n\n\t\t(vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserve\n\t\t\t.configuration\n\t\t\t.getFlags();\n\n\t\trequire(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\t\trequire(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n\t\trequire(amount != 0, Errors.VL_INVALID_AMOUNT);\n\n\t\trequire(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n\n\t\t//validate interest rate mode\n\t\trequire(\n\t\t\tuint256(DataTypes.InterestRateMode.VARIABLE) == interestRateMode ||\n\t\t\t\tuint256(DataTypes.InterestRateMode.STABLE) == interestRateMode,\n\t\t\tErrors.VL_INVALID_INTEREST_RATE_MODE_SELECTED\n\t\t);\n\n\t\t(\n\t\t\tvars.userCollateralBalanceETH,\n\t\t\tvars.userBorrowBalanceETH,\n\t\t\tvars.currentLtv,\n\t\t\tvars.currentLiquidationThreshold,\n\t\t\tvars.healthFactor\n\t\t) = GenericLogic.calculateUserAccountData(\n\t\t\tuserAddress,\n\t\t\treservesData,\n\t\t\tuserConfig,\n\t\t\treserves,\n\t\t\treservesCount,\n\t\t\toracle\n\t\t);\n\n\t\trequire(vars.userCollateralBalanceETH > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n\n\t\trequire(\n\t\t\tvars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n\t\t\tErrors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n\t\t);\n\n\t\t//add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n\t\tvars.amountOfCollateralNeededETH = vars.userBorrowBalanceETH.add(amountInETH).percentDiv(vars.currentLtv); //LTV is calculated in percentage\n\n\t\trequire(\n\t\t\tvars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\n\t\t\tErrors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW\n\t\t);\n\n\t\t/**\n\t\t * Following conditions need to be met if the user is borrowing at a stable rate:\n\t\t * 1. Reserve must be enabled for stable rate borrowing\n\t\t * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n\t\t *    they are borrowing, to prevent abuses.\n\t\t * 3. Users will be able to borrow only a portion of the total available liquidity\n\t\t **/\n\n\t\tif (interestRateMode == uint256(DataTypes.InterestRateMode.STABLE)) {\n\t\t\t//check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n\n\t\t\trequire(vars.stableRateBorrowingEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\n\n\t\t\trequire(\n\t\t\t\t!userConfig.isUsingAsCollateral(reserve.id) ||\n\t\t\t\t\treserve.configuration.getLtv() == 0 ||\n\t\t\t\t\tamount > IERC20(reserve.aTokenAddress).balanceOf(userAddress),\n\t\t\t\tErrors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\n\t\t\t);\n\n\t\t\tvars.availableLiquidity = IERC20(asset).balanceOf(reserve.aTokenAddress);\n\n\t\t\t//calculate the max available loan size in stable rate mode as a percentage of the\n\t\t\t//available liquidity\n\t\t\tuint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent);\n\n\t\t\trequire(amount <= maxLoanSizeStable, Errors.VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Validates a repay action\n\t * @param reserve The reserve state from which the user is repaying\n\t * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n\t * @param onBehalfOf The address of the user msg.sender is repaying for\n\t * @param stableDebt The borrow balance of the user\n\t * @param variableDebt The borrow balance of the user\n\t */\n\tfunction validateRepay(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tuint256 amountSent,\n\t\tDataTypes.InterestRateMode rateMode,\n\t\taddress onBehalfOf,\n\t\tuint256 stableDebt,\n\t\tuint256 variableDebt\n\t) external view {\n\t\tbool isActive = reserve.configuration.getActive();\n\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n\t\trequire(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n\t\trequire(\n\t\t\t(stableDebt > 0 && DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE) ||\n\t\t\t\t(variableDebt > 0 && DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.VARIABLE),\n\t\t\tErrors.VL_NO_DEBT_OF_SELECTED_TYPE\n\t\t);\n\n\t\trequire(\n\t\t\tamountSent != type(uint256).max || msg.sender == onBehalfOf,\n\t\t\tErrors.VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n\t\t);\n\t}\n\n\t/**\n\t * @dev Validates a swap of borrow rate mode.\n\t * @param reserve The reserve state on which the user is swapping the rate\n\t * @param userConfig The user reserves configuration\n\t * @param stableDebt The stable debt of the user\n\t * @param variableDebt The variable debt of the user\n\t * @param currentRateMode The rate mode of the borrow\n\t */\n\tfunction validateSwapRateMode(\n\t\tDataTypes.ReserveData storage reserve,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tuint256 stableDebt,\n\t\tuint256 variableDebt,\n\t\tDataTypes.InterestRateMode currentRateMode\n\t) external view {\n\t\t(bool isActive, bool isFrozen, , bool stableRateEnabled) = reserve.configuration.getFlags();\n\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\t\trequire(!isFrozen, Errors.VL_RESERVE_FROZEN);\n\n\t\tif (currentRateMode == DataTypes.InterestRateMode.STABLE) {\n\t\t\trequire(stableDebt > 0, Errors.VL_NO_STABLE_RATE_LOAN_IN_RESERVE);\n\t\t} else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\n\t\t\trequire(variableDebt > 0, Errors.VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE);\n\t\t\t/**\n\t\t\t * user wants to swap to stable, before swapping we need to ensure that\n\t\t\t * 1. stable borrow rate is enabled on the reserve\n\t\t\t * 2. user is not trying to abuse the reserve by depositing\n\t\t\t * more collateral than he is borrowing, artificially lowering\n\t\t\t * the interest rate, borrowing at variable, and switching to stable\n\t\t\t **/\n\t\t\trequire(stableRateEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\n\n\t\t\trequire(\n\t\t\t\t!userConfig.isUsingAsCollateral(reserve.id) ||\n\t\t\t\t\treserve.configuration.getLtv() == 0 ||\n\t\t\t\t\tstableDebt.add(variableDebt) > IERC20(reserve.aTokenAddress).balanceOf(msg.sender),\n\t\t\t\tErrors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\n\t\t\t);\n\t\t} else {\n\t\t\trevert(Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Validates a stable borrow rate rebalance action\n\t * @param reserve The reserve state on which the user is getting rebalanced\n\t * @param reserveAddress The address of the reserve\n\t * @param stableDebtToken The stable debt token instance\n\t * @param variableDebtToken The variable debt token instance\n\t * @param aTokenAddress The address of the aToken contract\n\t */\n\tfunction validateRebalanceStableBorrowRate(\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress reserveAddress,\n\t\tIERC20 stableDebtToken,\n\t\tIERC20 variableDebtToken,\n\t\taddress aTokenAddress\n\t) external view {\n\t\t(bool isActive, , , ) = reserve.configuration.getFlags();\n\n\t\trequire(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n\t\t//if the usage ratio is below 95%, no rebalances are needed\n\t\tuint256 totalDebt = stableDebtToken.totalSupply().add(variableDebtToken.totalSupply()).wadToRay();\n\t\tuint256 availableLiquidity = IERC20(reserveAddress).balanceOf(aTokenAddress).wadToRay();\n\t\tuint256 usageRatio = totalDebt == 0 ? 0 : totalDebt.rayDiv(availableLiquidity.add(totalDebt));\n\n\t\t//if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage,\n\t\t//then we allow rebalancing of the stable rate positions.\n\n\t\tuint256 currentLiquidityRate = reserve.currentLiquidityRate;\n\t\tuint256 maxVariableBorrowRate = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n\t\t\t.getMaxVariableBorrowRate();\n\n\t\trequire(\n\t\t\tusageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD &&\n\t\t\t\tcurrentLiquidityRate <= maxVariableBorrowRate.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\n\t\t\tErrors.LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n\t\t);\n\t}\n\n\t/**\n\t * @dev Validates the action of setting an asset as collateral\n\t * @param reserve The state of the reserve that the user is enabling or disabling as collateral\n\t * @param reserveAddress The address of the reserve\n\t * @param reservesData The data of all the reserves\n\t * @param userConfig The state of the user for the specific reserve\n\t * @param reserves The addresses of all the active reserves\n\t * @param oracle The price oracle\n\t */\n\tfunction validateSetUseReserveAsCollateral(\n\t\tDataTypes.ReserveData storage reserve,\n\t\taddress reserveAddress,\n\t\tbool useAsCollateral,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) external view {\n\t\tuint256 underlyingBalance = IERC20(reserve.aTokenAddress).balanceOf(msg.sender);\n\n\t\trequire(underlyingBalance > 0, Errors.VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0);\n\n\t\trequire(\n\t\t\tuseAsCollateral ||\n\t\t\t\tGenericLogic.balanceDecreaseAllowed(\n\t\t\t\t\treserveAddress,\n\t\t\t\t\tmsg.sender,\n\t\t\t\t\tunderlyingBalance,\n\t\t\t\t\treservesData,\n\t\t\t\t\tuserConfig,\n\t\t\t\t\treserves,\n\t\t\t\t\treservesCount,\n\t\t\t\t\toracle\n\t\t\t\t),\n\t\t\tErrors.VL_DEPOSIT_ALREADY_IN_USE\n\t\t);\n\t}\n\n\t/**\n\t * @dev Validates a flashloan action\n\t * @param assets The assets being flashborrowed\n\t * @param amounts The amounts for each asset being borrowed\n\t **/\n\tfunction validateFlashloan(address[] memory assets, uint256[] memory amounts) internal pure {\n\t\trequire(assets.length == amounts.length, Errors.VL_INCONSISTENT_FLASHLOAN_PARAMS);\n\t}\n\n\t/**\n\t * @dev Validates the liquidation action\n\t * @param collateralReserve The reserve data of the collateral\n\t * @param principalReserve The reserve data of the principal\n\t * @param userConfig The user configuration\n\t * @param userHealthFactor The user's health factor\n\t * @param userStableDebt Total stable debt balance of the user\n\t * @param userVariableDebt Total variable debt balance of the user\n\t **/\n\tfunction validateLiquidationCall(\n\t\tDataTypes.ReserveData storage collateralReserve,\n\t\tDataTypes.ReserveData storage principalReserve,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tuint256 userHealthFactor,\n\t\tuint256 userStableDebt,\n\t\tuint256 userVariableDebt\n\t) internal view returns (uint256, string memory) {\n\t\tif (!collateralReserve.configuration.getActive() || !principalReserve.configuration.getActive()) {\n\t\t\treturn (uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE), Errors.VL_NO_ACTIVE_RESERVE);\n\t\t}\n\n\t\tif (userHealthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD) {\n\t\t\treturn (\n\t\t\t\tuint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\n\t\t\t\tErrors.LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n\t\t\t);\n\t\t}\n\n\t\tbool isCollateralEnabled = collateralReserve.configuration.getLiquidationThreshold() > 0 &&\n\t\t\tuserConfig.isUsingAsCollateral(collateralReserve.id);\n\n\t\t//if collateral isn't enabled as collateral by user, it cannot be liquidated\n\t\tif (!isCollateralEnabled) {\n\t\t\treturn (\n\t\t\t\tuint256(Errors.CollateralManagerErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\n\t\t\t\tErrors.LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED\n\t\t\t);\n\t\t}\n\n\t\tif (userStableDebt == 0 && userVariableDebt == 0) {\n\t\t\treturn (\n\t\t\t\tuint256(Errors.CollateralManagerErrors.CURRRENCY_NOT_BORROWED),\n\t\t\t\tErrors.LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\n\t\t\t);\n\t\t}\n\n\t\treturn (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\n\t}\n\n\t/**\n\t * @dev Validates an aToken transfer\n\t * @param from The user from which the aTokens are being transferred\n\t * @param reservesData The state of all the reserves\n\t * @param userConfig The state of the user for the specific reserve\n\t * @param reserves The addresses of all the active reserves\n\t * @param oracle The price oracle\n\t */\n\tfunction validateTransfer(\n\t\taddress from,\n\t\tmapping(address => DataTypes.ReserveData) storage reservesData,\n\t\tDataTypes.UserConfigurationMap storage userConfig,\n\t\tmapping(uint256 => address) storage reserves,\n\t\tuint256 reservesCount,\n\t\taddress oracle\n\t) internal view {\n\t\t(, , , , uint256 healthFactor) = GenericLogic.calculateUserAccountData(\n\t\t\tfrom,\n\t\t\treservesData,\n\t\t\tuserConfig,\n\t\t\treserves,\n\t\t\treservesCount,\n\t\t\toracle\n\t\t);\n\n\t\trequire(healthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD, Errors.VL_TRANSFER_NOT_ALLOWED);\n\t}\n}\n"
    },
    "contracts/lending/libraries/math/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {WadRayMath} from \"./WadRayMath.sol\";\n\nlibrary MathUtils {\n\tusing SafeMath for uint256;\n\tusing WadRayMath for uint256;\n\n\t/// @dev Ignoring leap years\n\tuint256 internal constant SECONDS_PER_YEAR = 365 days;\n\n\t/**\n\t * @dev Function to calculate the interest accumulated using a linear interest rate formula\n\t * @param rate The interest rate, in ray\n\t * @param lastUpdateTimestamp The timestamp of the last update of the interest\n\t * @return The interest rate linearly accumulated during the timeDelta, in ray\n\t **/\n\n\tfunction calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\n\t\t//solium-disable-next-line\n\t\tuint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp));\n\n\t\treturn (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());\n\t}\n\n\t/**\n\t * @dev Function to calculate the interest using a compounded interest rate formula\n\t * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n\t *\n\t *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n\t *\n\t * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\n\t * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\n\t *\n\t * @param rate The interest rate, in ray\n\t * @param lastUpdateTimestamp The timestamp of the last update of the interest\n\t * @return The interest rate compounded during the timeDelta, in ray\n\t **/\n\tfunction calculateCompoundedInterest(\n\t\tuint256 rate,\n\t\tuint40 lastUpdateTimestamp,\n\t\tuint256 currentTimestamp\n\t) internal pure returns (uint256) {\n\t\t//solium-disable-next-line\n\t\tuint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));\n\n\t\tif (exp == 0) {\n\t\t\treturn WadRayMath.ray();\n\t\t}\n\n\t\tuint256 expMinusOne = exp - 1;\n\n\t\tuint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n\n\t\tuint256 ratePerSecond = rate / SECONDS_PER_YEAR;\n\n\t\tuint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\n\t\tuint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\n\n\t\tuint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;\n\t\tuint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6;\n\n\t\treturn WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm);\n\t}\n\n\t/**\n\t * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\n\t * @param rate The interest rate (in ray)\n\t * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\n\t **/\n\tfunction calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\n\t\treturn calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\n\t}\n}\n"
    },
    "contracts/lending/libraries/math/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Errors} from \"../helpers/Errors.sol\";\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded half up\n **/\n\nlibrary PercentageMath {\n\tuint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\n\tuint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\n\n\t/**\n\t * @dev Executes a percentage multiplication\n\t * @param value The value of which the percentage needs to be calculated\n\t * @param percentage The percentage of the value to be calculated\n\t * @return The percentage of value\n\t **/\n\tfunction percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\n\t\tif (value == 0 || percentage == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trequire(value <= (type(uint256).max - HALF_PERCENT) / percentage, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\n\t}\n\n\t/**\n\t * @dev Executes a percentage division\n\t * @param value The value of which the percentage needs to be calculated\n\t * @param percentage The percentage of the value to be calculated\n\t * @return The value divided the percentage\n\t **/\n\tfunction percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\n\t\trequire(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\n\t\tuint256 halfPercentage = percentage / 2;\n\n\t\trequire(value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\n\t}\n}\n"
    },
    "contracts/lending/libraries/math/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Errors} from \"../helpers/Errors.sol\";\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n **/\n\nlibrary WadRayMath {\n\tuint256 internal constant WAD = 1e18;\n\tuint256 internal constant halfWAD = WAD / 2;\n\n\tuint256 internal constant RAY = 1e27;\n\tuint256 internal constant halfRAY = RAY / 2;\n\n\tuint256 internal constant WAD_RAY_RATIO = 1e9;\n\n\t/**\n\t * @return One ray, 1e27\n\t **/\n\tfunction ray() internal pure returns (uint256) {\n\t\treturn RAY;\n\t}\n\n\t/**\n\t * @return One wad, 1e18\n\t **/\n\n\tfunction wad() internal pure returns (uint256) {\n\t\treturn WAD;\n\t}\n\n\t/**\n\t * @return Half ray, 1e27/2\n\t **/\n\tfunction halfRay() internal pure returns (uint256) {\n\t\treturn halfRAY;\n\t}\n\n\t/**\n\t * @return Half ray, 1e18/2\n\t **/\n\tfunction halfWad() internal pure returns (uint256) {\n\t\treturn halfWAD;\n\t}\n\n\t/**\n\t * @dev Multiplies two wad, rounding half up to the nearest wad\n\t * @param a Wad\n\t * @param b Wad\n\t * @return The result of a*b, in wad\n\t **/\n\tfunction wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0 || b == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trequire(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (a * b + halfWAD) / WAD;\n\t}\n\n\t/**\n\t * @dev Divides two wad, rounding half up to the nearest wad\n\t * @param a Wad\n\t * @param b Wad\n\t * @return The result of a/b, in wad\n\t **/\n\tfunction wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n\t\tuint256 halfB = b / 2;\n\n\t\trequire(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (a * WAD + halfB) / b;\n\t}\n\n\t/**\n\t * @dev Multiplies two ray, rounding half up to the nearest ray\n\t * @param a Ray\n\t * @param b Ray\n\t * @return The result of a*b, in ray\n\t **/\n\tfunction rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0 || b == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trequire(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (a * b + halfRAY) / RAY;\n\t}\n\n\t/**\n\t * @dev Divides two ray, rounding half up to the nearest ray\n\t * @param a Ray\n\t * @param b Ray\n\t * @return The result of a/b, in ray\n\t **/\n\tfunction rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n\t\tuint256 halfB = b / 2;\n\n\t\trequire(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n\t\treturn (a * RAY + halfB) / b;\n\t}\n\n\t/**\n\t * @dev Casts ray down to wad\n\t * @param a Ray\n\t * @return a casted to wad, rounded half up to the nearest wad\n\t **/\n\tfunction rayToWad(uint256 a) internal pure returns (uint256) {\n\t\tuint256 halfRatio = WAD_RAY_RATIO / 2;\n\t\tuint256 result = halfRatio + a;\n\t\trequire(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\n\n\t\treturn result / WAD_RAY_RATIO;\n\t}\n\n\t/**\n\t * @dev Converts wad up to ray\n\t * @param a Wad\n\t * @return a converted in ray\n\t **/\n\tfunction wadToRay(uint256 a) internal pure returns (uint256) {\n\t\tuint256 result = a * WAD_RAY_RATIO;\n\t\trequire(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\t\treturn result;\n\t}\n}\n"
    },
    "contracts/lending/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nlibrary DataTypes {\n\t// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n\tstruct ReserveData {\n\t\t//stores the reserve configuration\n\t\tReserveConfigurationMap configuration;\n\t\t//the liquidity index. Expressed in ray\n\t\tuint128 liquidityIndex;\n\t\t//variable borrow index. Expressed in ray\n\t\tuint128 variableBorrowIndex;\n\t\t//the current supply rate. Expressed in ray\n\t\tuint128 currentLiquidityRate;\n\t\t//the current variable borrow rate. Expressed in ray\n\t\tuint128 currentVariableBorrowRate;\n\t\t//the current stable borrow rate. Expressed in ray\n\t\tuint128 currentStableBorrowRate;\n\t\tuint40 lastUpdateTimestamp;\n\t\t//tokens addresses\n\t\taddress aTokenAddress;\n\t\taddress stableDebtTokenAddress;\n\t\taddress variableDebtTokenAddress;\n\t\t//address of the interest rate strategy\n\t\taddress interestRateStrategyAddress;\n\t\t//the id of the reserve. Represents the position in the list of the active reserves\n\t\tuint8 id;\n\t}\n\n\tstruct ReserveConfigurationMap {\n\t\t//bit 0-15: LTV\n\t\t//bit 16-31: Liq. threshold\n\t\t//bit 32-47: Liq. bonus\n\t\t//bit 48-55: Decimals\n\t\t//bit 56: Reserve is active\n\t\t//bit 57: reserve is frozen\n\t\t//bit 58: borrowing is enabled\n\t\t//bit 59: stable rate borrowing enabled\n\t\t//bit 60-63: reserved\n\t\t//bit 64-79: reserve factor\n\t\tuint256 data;\n\t}\n\n\tstruct UserConfigurationMap {\n\t\tuint256 data;\n\t}\n\n\tenum InterestRateMode {\n\t\tNONE,\n\t\tSTABLE,\n\t\tVARIABLE\n\t}\n}\n"
    },
    "contracts/lending/StableAndVariableTokensHelper.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {StableDebtToken} from \"./tokenization/StableDebtToken.sol\";\nimport {VariableDebtToken} from \"./tokenization/VariableDebtToken.sol\";\nimport {LendingRateOracle} from \"../test/oracle/LendingRateOracle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract StableAndVariableTokensHelper is Ownable {\n\taddress payable private pool;\n\taddress private addressesProvider;\n\tevent deployedContracts(address stableToken, address variableToken);\n\n\tconstructor(address payable _pool, address _addressesProvider) {\n\t\tpool = _pool;\n\t\taddressesProvider = _addressesProvider;\n\t}\n\n\tfunction initDeployment(address[] calldata tokens, string[] calldata symbols) external onlyOwner {\n\t\trequire(tokens.length == symbols.length, \"Arrays not same length\");\n\t\trequire(pool != address(0), \"Pool can not be zero address\");\n\t\tfor (uint256 i = 0; i < tokens.length; i++) {\n\t\t\temit deployedContracts(address(new StableDebtToken()), address(new VariableDebtToken()));\n\t\t}\n\t}\n\n\tfunction setOracleBorrowRates(\n\t\taddress[] calldata assets,\n\t\tuint256[] calldata rates,\n\t\taddress oracle\n\t) external onlyOwner {\n\t\trequire(assets.length == rates.length, \"Arrays not same length\");\n\n\t\tfor (uint256 i = 0; i < assets.length; i++) {\n\t\t\t// LendingRateOracle owner must be this contract\n\t\t\tLendingRateOracle(oracle).setMarketBorrowRate(assets[i], rates[i]);\n\t\t}\n\t}\n\n\tfunction setOracleOwnership(address oracle, address admin) external onlyOwner {\n\t\trequire(admin != address(0), \"owner can not be zero\");\n\t\trequire(LendingRateOracle(oracle).owner() == address(this), \"helper is not owner\");\n\t\tLendingRateOracle(oracle).transferOwnership(admin);\n\t}\n}\n"
    },
    "contracts/lending/tokenization/AToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IAToken} from \"../../interfaces/IAToken.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {VersionedInitializable} from \"../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {IncentivizedERC20} from \"./IncentivizedERC20.sol\";\nimport {IAaveIncentivesController} from \"../../interfaces/IAaveIncentivesController.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IMiddleFeeDistribution} from \"../../interfaces/IMiddleFeeDistribution.sol\";\n\n/**\n * @title Aave ERC20 AToken\n * @dev Implementation of the interest bearing token for the Aave protocol\n * @author Aave\n */\ncontract AToken is VersionedInitializable, IncentivizedERC20(\"ATOKEN_IMPL\", \"ATOKEN_IMPL\", 0), IAToken {\n\tusing WadRayMath for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;                                      \n\n\tbytes public constant EIP712_REVISION = bytes(\"1\");\n\tbytes32 internal constant EIP712_DOMAIN =\n\t\tkeccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\tbytes32 public constant PERMIT_TYPEHASH =\n\t\tkeccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n\tuint256 public constant ATOKEN_REVISION = 0x1;\n\n\t/// @dev owner => next valid nonce to submit with permit()\n\tmapping(address => uint256) public _nonces;\n\n\tbytes32 public DOMAIN_SEPARATOR;\n\n\taddress internal _treasury;\n\tIAaveIncentivesController internal _incentivesController;\n\n\tmodifier onlyLendingPool() {\n\t\trequire(_msgSender() == address(_pool), Errors.CT_CALLER_MUST_BE_LENDING_POOL);\n\t\t_;\n\t}\n\n\tfunction getRevision() internal pure virtual override returns (uint256) {\n\t\treturn ATOKEN_REVISION;\n\t}\n\n\t/**\n\t * @dev Initializes the aToken\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n\t * @param aTokenName The name of the aToken\n\t * @param aTokenSymbol The symbol of the aToken\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress treasury,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 aTokenDecimals,\n\t\tstring calldata aTokenName,\n\t\tstring calldata aTokenSymbol,\n\t\tbytes calldata params\n\t) external override initializer {\n\t\tuint256 chainId;\n\n\t\t//solium-disable-next-line\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\n\t\tDOMAIN_SEPARATOR = keccak256(\n\t\t\tabi.encode(EIP712_DOMAIN, keccak256(bytes(aTokenName)), keccak256(EIP712_REVISION), chainId, address(this))\n\t\t);\n\n\t\t_setName(aTokenName);\n\t\t_setSymbol(aTokenSymbol);\n\t\t_setDecimals(aTokenDecimals);\n\n\t\t_pool = pool;\n\t\t_treasury = treasury;\n\t\t_underlyingAsset = underlyingAsset;\n\t\t_incentivesController = incentivesController;\n\n\t\temit Initialized(\n\t\t\tunderlyingAsset,\n\t\t\taddress(pool),\n\t\t\ttreasury,\n\t\t\taddress(incentivesController),\n\t\t\taTokenDecimals,\n\t\t\taTokenName,\n\t\t\taTokenSymbol,\n\t\t\tparams\n\t\t);\n\t}\n\n\t/**\n\t * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n\t * - Only callable by the LendingPool, as extra state updates there need to be managed\n\t * @param user The owner of the aTokens, getting them burned\n\t * @param receiverOfUnderlying The address that will receive the underlying\n\t * @param amount The amount being burned\n\t * @param index The new liquidity index of the reserve\n\t **/\n\tfunction burn(\n\t\taddress user,\n\t\taddress receiverOfUnderlying,\n\t\tuint256 amount,\n\t\tuint256 index\n\t) external override onlyLendingPool {\n\t\tuint256 amountScaled = amount.rayDiv(index);\n\t\trequire(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n\t\t_burn(user, amountScaled);\n\n\t\tIERC20(_underlyingAsset).safeTransfer(receiverOfUnderlying, amount);\n\n\t\temit Transfer(user, address(0), amount);\n\t\temit Burn(user, receiverOfUnderlying, amount, index);\n\t}\n\n\t/**\n\t * @dev Mints `amount` aTokens to `user`\n\t * - Only callable by the LendingPool, as extra state updates there need to be managed\n\t * @param user The address receiving the minted tokens\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t * @return `true` if the the previous balance of the user was 0\n\t */\n\tfunction mint(address user, uint256 amount, uint256 index) external override onlyLendingPool returns (bool) {\n\t\tuint256 previousBalance = super.balanceOf(user);\n\n\t\tuint256 amountScaled = amount.rayDiv(index);\n\t\trequire(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n\t\t_mint(user, amountScaled);\n\n\t\temit Transfer(address(0), user, amount);\n\t\temit Mint(user, amount, index);\n\n\t\treturn previousBalance == 0;\n\t}\n\n\t/**\n\t * @dev Mints aTokens to the reserve treasury\n\t * - Only callable by the LendingPool\n\t * @param amount The amount of tokens getting minted\n\t * @param index The new liquidity index of the reserve\n\t */\n\tfunction mintToTreasury(uint256 amount, uint256 index) external override onlyLendingPool {\n\t\tif (amount == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\taddress treasury = _treasury;\n\n\t\t// Compared to the normal mint, we don't check for rounding errors.\n\t\t// The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n\t\t// In that case, the treasury will experience a (very small) loss, but it\n\t\t// wont cause potentially valid transactions to fail.\n\t\t_mint(treasury, amount.rayDiv(index));\n\n\t\temit Transfer(address(0), treasury, amount);\n\t\temit Mint(treasury, amount, index);\n\t}\n\n\t/**\n\t * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n\t * - Only callable by the LendingPool\n\t * @param from The address getting liquidated, current owner of the aTokens\n\t * @param to The recipient\n\t * @param value The amount of tokens getting transferred\n\t **/\n\tfunction transferOnLiquidation(address from, address to, uint256 value) external override onlyLendingPool {\n\t\t// Being a normal transfer, the Transfer() and BalanceTransfer() are emitted\n\t\t// so no need to emit a specific event here\n\t\t_transfer(from, to, value, false);\n\n\t\temit Transfer(from, to, value);\n\t}\n\n\t/**\n\t * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n\t * @param user The user whose balance is calculated\n\t * @return The balance of the user\n\t **/\n\tfunction balanceOf(address user) public view override(IncentivizedERC20, IERC20) returns (uint256) {\n\t\treturn super.balanceOf(user).rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset));\n\t}\n\n\t/**\n\t * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n\t * updated stored balance divided by the reserve's liquidity index at the moment of the update\n\t * @param user The user whose balance is calculated\n\t * @return The scaled balance of the user\n\t **/\n\tfunction scaledBalanceOf(address user) external view override returns (uint256) {\n\t\treturn super.balanceOf(user);\n\t}\n\n\t/**\n\t * @dev Returns the scaled balance of the user and the scaled total supply.\n\t * @param user The address of the user\n\t * @return The scaled balance of the user\n\t * @return The scaled balance and the scaled total supply\n\t **/\n\tfunction getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n\t\treturn (super.balanceOf(user), super.totalSupply());\n\t}\n\n\t/**\n\t * @dev calculates the total supply of the specific aToken\n\t * since the balance of every single user increases over time, the total supply\n\t * does that too.\n\t * @return the current total supply\n\t **/\n\tfunction totalSupply() public view override(IncentivizedERC20, IERC20) returns (uint256) {\n\t\tuint256 currentSupplyScaled = super.totalSupply();\n\n\t\tif (currentSupplyScaled == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn currentSupplyScaled.rayMul(_pool.getReserveNormalizedIncome(_underlyingAsset));\n\t}\n\n\t/**\n\t * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n\t * @return the scaled total supply\n\t **/\n\tfunction scaledTotalSupply() public view virtual override returns (uint256) {\n\t\treturn super.totalSupply();\n\t}\n\n\t/**\n\t * @dev Returns the address of the Aave treasury, receiving the fees on this aToken\n\t **/\n\tfunction RESERVE_TREASURY_ADDRESS() public view returns (address) {\n\t\treturn _treasury;\n\t}\n\n\t/**\n\t * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t **/\n\tfunction UNDERLYING_ASSET_ADDRESS() public view override returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\t/**\n\t * @dev Returns the address of the lending pool where this aToken is used\n\t **/\n\tfunction POOL() public view returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n\n\t/**\n\t * @dev For internal usage in the logic of the parent contract IncentivizedERC20\n\t **/\n\tfunction _getIncentivesController() internal view override returns (IAaveIncentivesController) {\n\t\treturn _incentivesController;\n\t}\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view override returns (IAaveIncentivesController) {\n\t\treturn _getIncentivesController();\n\t}\n\n\t/**\n\t * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n\t * assets in borrow(), withdraw() and flashLoan()\n\t * @param target The recipient of the aTokens\n\t * @param amount The amount getting transferred\n\t * @return The amount transferred\n\t **/\n\tfunction transferUnderlyingTo(address target, uint256 amount) external override onlyLendingPool returns (uint256) {\n\t\tIERC20(_underlyingAsset).safeTransfer(target, amount);\n\t\treturn amount;\n\t}\n\n\t/**\n\t * @dev Invoked to execute actions on the aToken side after a repayment.\n\t * @param user The user executing the repayment\n\t * @param amount The amount getting repaid\n\t **/\n\tfunction handleRepayment(address user, uint256 amount) external override onlyLendingPool {}\n\n\t/**\n\t * @dev implements the permit function as for\n\t * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n\t * @param owner The owner of the funds\n\t * @param spender The spender\n\t * @param value The amount\n\t * @param deadline The deadline timestamp, type(uint256).max for max deadline\n\t * @param v Signature param\n\t * @param s Signature param\n\t * @param r Signature param\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(owner != address(0), \"INVALID_OWNER\");\n\t\t//solium-disable-next-line\n\t\trequire(block.timestamp <= deadline, \"INVALID_EXPIRATION\");\n\t\tuint256 currentValidNonce = _nonces[owner];\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"\\x19\\x01\",\n\t\t\t\tDOMAIN_SEPARATOR,\n\t\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\n\t\t\t)\n\t\t);\n\t\trequire(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n\t\t_nonces[owner] = currentValidNonce.add(1);\n\t\t_approve(owner, spender, value);\n\t}\n\n\t/**\n\t * @dev Transfers the aTokens between two users. Validates the transfer\n\t * (ie checks for valid HF after the transfer) if required\n\t * @param from The source address\n\t * @param to The destination address\n\t * @param amount The amount getting transferred\n\t * @param validate `true` if the transfer needs to be validated\n\t **/\n\tfunction _transfer(address from, address to, uint256 amount, bool validate) internal {\n\t\taddress underlyingAsset = _underlyingAsset;\n\t\tILendingPool pool = _pool;\n\n\t\tuint256 index = pool.getReserveNormalizedIncome(underlyingAsset);\n\n\t\tuint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n\t\tuint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n\n\t\tsuper._transfer(from, to, amount.rayDiv(index));\n\n\t\tif (validate) {\n\t\t\tpool.finalizeTransfer(underlyingAsset, from, to, amount, fromBalanceBefore, toBalanceBefore);\n\t\t}\n\n\t\temit BalanceTransfer(from, to, amount, index);\n\t}\n\n\t/**\n\t * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n\t * @param from The source address\n\t * @param to The destination address\n\t * @param amount The amount getting transferred\n\t **/\n\tfunction _transfer(address from, address to, uint256 amount) internal override {\n\t\t_transfer(from, to, amount, true);\n\t}\n}\n"
    },
    "contracts/lending/tokenization/base/DebtTokenBase.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {ILendingPool} from \"../../../interfaces/ILendingPool.sol\";\nimport {ICreditDelegationToken} from \"../../../interfaces/ICreditDelegationToken.sol\";\nimport {VersionedInitializable} from \"../../libraries/aave-upgradeability/VersionedInitializable.sol\";\nimport {IncentivizedERC20} from \"../IncentivizedERC20.sol\";\nimport {Errors} from \"../../libraries/helpers/Errors.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title DebtTokenBase\n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToken\n * @author Aave\n */\n\nabstract contract DebtTokenBase is\n\tIncentivizedERC20(\"DEBTTOKEN_IMPL\", \"DEBTTOKEN_IMPL\", 0),\n\tVersionedInitializable,\n\tICreditDelegationToken\n{\n\tusing SafeMath for uint256;\n\n\tmapping(address => mapping(address => uint256)) internal _borrowAllowances;\n\n\t/**\n\t * @dev Only lending pool can call functions marked by this modifier\n\t **/\n\tmodifier onlyLendingPool() {\n\t\trequire(_msgSender() == address(_getLendingPool()), Errors.CT_CALLER_MUST_BE_LENDING_POOL);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev delegates borrowing power to a user on the specific debt token\n\t * @param delegatee the address receiving the delegated borrowing power\n\t * @param amount the maximum amount being delegated. Delegation will still\n\t * respect the liquidation constraints (even if delegated, a delegatee cannot\n\t * force a delegator HF to go below 1)\n\t **/\n\tfunction approveDelegation(address delegatee, uint256 amount) external override {\n\t\t_borrowAllowances[_msgSender()][delegatee] = amount;\n\t\temit BorrowAllowanceDelegated(_msgSender(), delegatee, _getUnderlyingAssetAddress(), amount);\n\t}\n\n\t/**\n\t * @dev returns the borrow allowance of the user\n\t * @param fromUser The user to giving allowance\n\t * @param toUser The user to give allowance to\n\t * @return the current allowance of toUser\n\t **/\n\tfunction borrowAllowance(address fromUser, address toUser) external view override returns (uint256) {\n\t\treturn _borrowAllowances[fromUser][toUser];\n\t}\n\n\t/**\n\t * @dev Being non transferrable, the debt token does not implement any of the\n\t * standard ERC20 functions for transfer and allowance.\n\t **/\n\tfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\t\trecipient;\n\t\tamount;\n\t\trevert(\"TRANSFER_NOT_SUPPORTED\");\n\t}\n\n\tfunction allowance(address owner, address spender) public view virtual override returns (uint256) {\n\t\towner;\n\t\tspender;\n\t\trevert(\"ALLOWANCE_NOT_SUPPORTED\");\n\t}\n\n\tfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\n\t\tspender;\n\t\tamount;\n\t\trevert(\"APPROVAL_NOT_SUPPORTED\");\n\t}\n\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n\t\tsender;\n\t\trecipient;\n\t\tamount;\n\t\trevert(\"TRANSFER_NOT_SUPPORTED\");\n\t}\n\n\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual override returns (bool) {\n\t\tspender;\n\t\taddedValue;\n\t\trevert(\"ALLOWANCE_NOT_SUPPORTED\");\n\t}\n\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual override returns (bool) {\n\t\tspender;\n\t\tsubtractedValue;\n\t\trevert(\"ALLOWANCE_NOT_SUPPORTED\");\n\t}\n\n\tfunction _decreaseBorrowAllowance(address delegator, address delegatee, uint256 amount) internal {\n\t\tuint256 newAllowance = _borrowAllowances[delegator][delegatee].sub(amount, Errors.BORROW_ALLOWANCE_NOT_ENOUGH);\n\n\t\t_borrowAllowances[delegator][delegatee] = newAllowance;\n\n\t\temit BorrowAllowanceDelegated(delegator, delegatee, _getUnderlyingAssetAddress(), newAllowance);\n\t}\n\n\tfunction _getUnderlyingAssetAddress() internal view virtual returns (address);\n\n\tfunction _getLendingPool() internal view virtual returns (ILendingPool);\n}\n"
    },
    "contracts/lending/tokenization/IncentivizedERC20.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {Context} from \"../../dependencies/openzeppelin/contracts/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IAaveIncentivesController} from \"../../interfaces/IAaveIncentivesController.sol\";\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {IPriceOracle} from \"../../interfaces/IPriceOracle.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\n\n/**\n * @title ERC20\n * @notice Basic ERC20 implementation\n * @author Aave, inspired by the Openzeppelin ERC20 implementation\n **/\nabstract contract IncentivizedERC20 is Context, IERC20, IERC20Metadata {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) internal _balances;\n\n\tmapping(address => mapping(address => uint256)) private _allowances;\n\tuint256 internal _totalSupply;\n\tstring private _name;\n\tstring private _symbol;\n\tuint8 private _decimals;\n\n\tILendingPool internal _pool;\n\taddress internal _underlyingAsset;\n\n\tconstructor(string memory name_, string memory symbol_, uint8 decimals_) {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\t\t_decimals = decimals_;\n\t}\n\n\t/**\n\t * @return The name of the token\n\t **/\n\tfunction name() public view override returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * @return The symbol of the token\n\t **/\n\tfunction symbol() public view override returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * @return The decimals of the token\n\t **/\n\tfunction decimals() public view override returns (uint8) {\n\t\treturn _decimals;\n\t}\n\n\t/**\n\t * @return The total supply of the token\n\t **/\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/**\n\t * @return The balance of the token\n\t **/\n\tfunction balanceOf(address account) public view virtual override returns (uint256) {\n\t\treturn _balances[account];\n\t}\n\n\t/**\n\t * @return Abstract function implemented by the child aToken/debtToken.\n\t * Done this way in order to not break compatibility with previous versions of aTokens/debtTokens\n\t **/\n\tfunction _getIncentivesController() internal view virtual returns (IAaveIncentivesController);\n\n\t/**\n\t * @dev Executes a transfer of tokens from _msgSender() to recipient\n\t * @param recipient The recipient of the tokens\n\t * @param amount The amount of tokens being transferred\n\t * @return `true` if the transfer succeeds, `false` otherwise\n\t **/\n\tfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\t\t_transfer(_msgSender(), recipient, amount);\n\t\temit Transfer(_msgSender(), recipient, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Returns the allowance of spender on the tokens owned by owner\n\t * @param owner The owner of the tokens\n\t * @param spender The user allowed to spend the owner's tokens\n\t * @return The amount of owner's tokens spender is allowed to spend\n\t **/\n\tfunction allowance(address owner, address spender) public view virtual override returns (uint256) {\n\t\treturn _allowances[owner][spender];\n\t}\n\n\t/**\n\t * @dev Allows `spender` to spend the tokens owned by _msgSender()\n\t * @param spender The user allowed to spend _msgSender() tokens\n\t * @return `true`\n\t **/\n\tfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\n\t\t_approve(_msgSender(), spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Executes a transfer of token from sender to recipient, if _msgSender() is allowed to do so\n\t * @param sender The owner of the tokens\n\t * @param recipient The recipient of the tokens\n\t * @param amount The amount of tokens being transferred\n\t * @return `true` if the transfer succeeds, `false` otherwise\n\t **/\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\t\t_approve(\n\t\t\tsender,\n\t\t\t_msgSender(),\n\t\t\t_allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n\t\t);\n\t\temit Transfer(sender, recipient, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Increases the allowance of spender to spend _msgSender() tokens\n\t * @param spender The user allowed to spend on behalf of _msgSender()\n\t * @param addedValue The amount being added to the allowance\n\t * @return `true`\n\t **/\n\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decreases the allowance of spender to spend _msgSender() tokens\n\t * @param spender The user allowed to spend on behalf of _msgSender()\n\t * @param subtractedValue The amount being subtracted to the allowance\n\t * @return `true`\n\t **/\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n\t\t_approve(\n\t\t\t_msgSender(),\n\t\t\tspender,\n\t\t\t_allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n\t\t);\n\t\treturn true;\n\t}\n\n\tfunction _transfer(address sender, address recipient, uint256 amount) internal virtual {\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(sender, recipient, amount);\n\n\t\tuint256 senderBalance = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t// uint256 currentTotalSupply = _totalSupply;\n\t\t\t_getIncentivesController().handleActionBefore(sender);\n\t\t\tif (sender != recipient) {\n\t\t\t\t_getIncentivesController().handleActionBefore(recipient);\n\t\t\t}\n\t\t}\n\n\t\t_balances[sender] = senderBalance;\n\t\tuint256 recipientBalance = _balances[recipient].add(amount);\n\t\t_balances[recipient] = recipientBalance;\n\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\tuint256 currentTotalSupply = _totalSupply;\n\t\t\t_getIncentivesController().handleActionAfter(sender, _balances[sender], currentTotalSupply);\n\t\t\tif (sender != recipient) {\n\t\t\t\t_getIncentivesController().handleActionAfter(recipient, _balances[recipient], currentTotalSupply);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _mint(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\n\n\t\t_beforeTokenTransfer(address(0), account, amount);\n\n\t\tuint256 currentTotalSupply = _totalSupply.add(amount);\n\t\tuint256 accountBalance = _balances[account].add(amount);\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t_getIncentivesController().handleActionBefore(account);\n\t\t}\n\t\t_totalSupply = currentTotalSupply;\n\t\t_balances[account] = accountBalance;\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t_getIncentivesController().handleActionAfter(account, accountBalance, currentTotalSupply);\n\t\t}\n\t}\n\n\tfunction _burn(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\n\n\t\t_beforeTokenTransfer(account, address(0), amount);\n\n\t\tuint256 currentTotalSupply = _totalSupply.sub(amount);\n\t\tuint256 accountBalance = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t_getIncentivesController().handleActionBefore(account);\n\t\t}\n\n\t\t_totalSupply = currentTotalSupply;\n\t\t_balances[account] = accountBalance;\n\n\t\tif (address(_getIncentivesController()) != address(0)) {\n\t\t\t_getIncentivesController().handleActionAfter(account, accountBalance, currentTotalSupply);\n\t\t}\n\t}\n\n\tfunction _approve(address owner, address spender, uint256 amount) internal virtual {\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\n\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\tfunction _setName(string memory newName) internal {\n\t\t_name = newName;\n\t}\n\n\tfunction _setSymbol(string memory newSymbol) internal {\n\t\t_symbol = newSymbol;\n\t}\n\n\tfunction _setDecimals(uint8 newDecimals) internal {\n\t\t_decimals = newDecimals;\n\t}\n\n\tfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n\tfunction getAssetPrice() external view returns (uint256) {\n\t\tILendingPoolAddressesProvider provider = _pool.getAddressesProvider();\n\t\taddress oracle = provider.getPriceOracle();\n\t\treturn IPriceOracle(oracle).getAssetPrice(_underlyingAsset);\n\t}\n}\n"
    },
    "contracts/lending/tokenization/StableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {DebtTokenBase} from \"./base/DebtTokenBase.sol\";\nimport {MathUtils} from \"../libraries/math/MathUtils.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {IStableDebtToken} from \"../../interfaces/IStableDebtToken.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IAaveIncentivesController} from \"../../interfaces/IAaveIncentivesController.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title StableDebtToken\n * @notice Implements a stable debt token to track the borrowing positions of users\n * at stable rate mode\n * @author Aave\n **/\ncontract StableDebtToken is IStableDebtToken, DebtTokenBase {\n\tusing WadRayMath for uint256;\n\tusing SafeMath for uint256;\n\n\tuint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n\tuint256 internal _avgStableRate;\n\tmapping(address => uint40) internal _timestamps;\n\tmapping(address => uint256) internal _usersStableRate;\n\tuint40 internal _totalSupplyTimestamp;\n\n\tIAaveIncentivesController internal _incentivesController;\n\n\t/**\n\t * @dev Initializes the debt token.\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n\t * @param debtTokenName The name of the token\n\t * @param debtTokenSymbol The symbol of the token\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 debtTokenDecimals,\n\t\tstring memory debtTokenName,\n\t\tstring memory debtTokenSymbol,\n\t\tbytes calldata params\n\t) public override initializer {\n\t\t_setName(debtTokenName);\n\t\t_setSymbol(debtTokenSymbol);\n\t\t_setDecimals(debtTokenDecimals);\n\n\t\t_pool = pool;\n\t\t_underlyingAsset = underlyingAsset;\n\t\t_incentivesController = incentivesController;\n\n\t\temit Initialized(\n\t\t\tunderlyingAsset,\n\t\t\taddress(pool),\n\t\t\taddress(incentivesController),\n\t\t\tdebtTokenDecimals,\n\t\t\tdebtTokenName,\n\t\t\tdebtTokenSymbol,\n\t\t\tparams\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the revision of the stable debt token implementation\n\t * @return The debt token implementation revision\n\t **/\n\tfunction getRevision() internal pure virtual override returns (uint256) {\n\t\treturn DEBT_TOKEN_REVISION;\n\t}\n\n\t/**\n\t * @dev Returns the average stable rate across all the stable rate debt\n\t * @return the average stable rate\n\t **/\n\tfunction getAverageStableRate() external view virtual override returns (uint256) {\n\t\treturn _avgStableRate;\n\t}\n\n\t/**\n\t * @dev Returns the timestamp of the last user action\n\t * @return The last update timestamp\n\t **/\n\tfunction getUserLastUpdated(address user) external view virtual override returns (uint40) {\n\t\treturn _timestamps[user];\n\t}\n\n\t/**\n\t * @dev Returns the stable rate of the user\n\t * @param user The address of the user\n\t * @return The stable rate of user\n\t **/\n\tfunction getUserStableRate(address user) external view virtual override returns (uint256) {\n\t\treturn _usersStableRate[user];\n\t}\n\n\t/**\n\t * @dev Calculates the current user debt balance\n\t * @return The accumulated debt of the user\n\t **/\n\tfunction balanceOf(address account) public view virtual override returns (uint256) {\n\t\tuint256 accountBalance = super.balanceOf(account);\n\t\tuint256 stableRate = _usersStableRate[account];\n\t\tif (accountBalance == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);\n\t\treturn accountBalance.rayMul(cumulatedInterest);\n\t}\n\n\tstruct MintLocalVars {\n\t\tuint256 previousSupply;\n\t\tuint256 nextSupply;\n\t\tuint256 amountInRay;\n\t\tuint256 newStableRate;\n\t\tuint256 currentAvgStableRate;\n\t}\n\n\t/**\n\t * @dev Mints debt token to the `onBehalfOf` address.\n\t * -  Only callable by the LendingPool\n\t * - The resulting rate is the weighted average between the rate of the new debt\n\t * and the rate of the previous debt\n\t * @param user The address receiving the borrowed underlying, being the delegatee in case\n\t * of credit delegate, or same as `onBehalfOf` otherwise\n\t * @param onBehalfOf The address receiving the debt tokens\n\t * @param amount The amount of debt tokens to mint\n\t * @param rate The rate of the debt being minted\n\t **/\n\tfunction mint(\n\t\taddress user,\n\t\taddress onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 rate\n\t) external override onlyLendingPool returns (bool) {\n\t\tMintLocalVars memory vars;\n\n\t\tif (user != onBehalfOf) {\n\t\t\t_decreaseBorrowAllowance(onBehalfOf, user, amount);\n\t\t}\n\n\t\t(, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);\n\n\t\tvars.previousSupply = totalSupply();\n\t\tvars.currentAvgStableRate = _avgStableRate;\n\t\tvars.nextSupply = _totalSupply = vars.previousSupply.add(amount);\n\n\t\tvars.amountInRay = amount.wadToRay();\n\n\t\tvars.newStableRate = _usersStableRate[onBehalfOf]\n\t\t\t.rayMul(currentBalance.wadToRay())\n\t\t\t.add(vars.amountInRay.rayMul(rate))\n\t\t\t.rayDiv(currentBalance.add(amount).wadToRay());\n\n\t\trequire(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);\n\t\t_usersStableRate[onBehalfOf] = vars.newStableRate;\n\n\t\t//solium-disable-next-line\n\t\t_totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);\n\n\t\t// Calculates the updated average stable rate\n\t\tvars.currentAvgStableRate = _avgStableRate = vars\n\t\t\t.currentAvgStableRate\n\t\t\t.rayMul(vars.previousSupply.wadToRay())\n\t\t\t.add(rate.rayMul(vars.amountInRay))\n\t\t\t.rayDiv(vars.nextSupply.wadToRay());\n\n\t\t_mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);\n\n\t\temit Transfer(address(0), onBehalfOf, amount);\n\n\t\temit Mint(\n\t\t\tuser,\n\t\t\tonBehalfOf,\n\t\t\tamount,\n\t\t\tcurrentBalance,\n\t\t\tbalanceIncrease,\n\t\t\tvars.newStableRate,\n\t\t\tvars.currentAvgStableRate,\n\t\t\tvars.nextSupply\n\t\t);\n\n\t\treturn currentBalance == 0;\n\t}\n\n\t/**\n\t * @dev Burns debt of `user`\n\t * @param user The address of the user getting his debt burned\n\t * @param amount The amount of debt tokens getting burned\n\t **/\n\tfunction burn(address user, uint256 amount) external override onlyLendingPool {\n\t\t(, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);\n\n\t\tuint256 previousSupply = totalSupply();\n\t\tuint256 newAvgStableRate = 0;\n\t\tuint256 nextSupply = 0;\n\t\tuint256 userStableRate = _usersStableRate[user];\n\n\t\t// Since the total supply and each single user debt accrue separately,\n\t\t// there might be accumulation errors so that the last borrower repaying\n\t\t// mght actually try to repay more than the available debt supply.\n\t\t// In this case we simply set the total supply and the avg stable rate to 0\n\t\tif (previousSupply <= amount) {\n\t\t\t_avgStableRate = 0;\n\t\t\t_totalSupply = 0;\n\t\t} else {\n\t\t\tnextSupply = _totalSupply = previousSupply.sub(amount);\n\t\t\tuint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());\n\t\t\tuint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\n\n\t\t\t// For the same reason described above, when the last user is repaying it might\n\t\t\t// happen that user rate * user balance > avg rate * total supply. In that case,\n\t\t\t// we simply set the avg rate to 0\n\t\t\tif (secondTerm >= firstTerm) {\n\t\t\t\tnewAvgStableRate = _avgStableRate = _totalSupply = 0;\n\t\t\t} else {\n\t\t\t\tnewAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());\n\t\t\t}\n\t\t}\n\n\t\tif (amount == currentBalance) {\n\t\t\t_usersStableRate[user] = 0;\n\t\t\t_timestamps[user] = 0;\n\t\t} else {\n\t\t\t//solium-disable-next-line\n\t\t\t_timestamps[user] = uint40(block.timestamp);\n\t\t}\n\t\t//solium-disable-next-line\n\t\t_totalSupplyTimestamp = uint40(block.timestamp);\n\n\t\tif (balanceIncrease > amount) {\n\t\t\tuint256 amountToMint = balanceIncrease.sub(amount);\n\t\t\t_mint(user, amountToMint, previousSupply);\n\t\t\temit Mint(\n\t\t\t\tuser,\n\t\t\t\tuser,\n\t\t\t\tamountToMint,\n\t\t\t\tcurrentBalance,\n\t\t\t\tbalanceIncrease,\n\t\t\t\tuserStableRate,\n\t\t\t\tnewAvgStableRate,\n\t\t\t\tnextSupply\n\t\t\t);\n\t\t} else {\n\t\t\tuint256 amountToBurn = amount.sub(balanceIncrease);\n\t\t\t_burn(user, amountToBurn, previousSupply);\n\t\t\temit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);\n\t\t}\n\n\t\temit Transfer(user, address(0), amount);\n\t}\n\n\t/**\n\t * @dev Calculates the increase in balance since the last user interaction\n\t * @param user The address of the user for which the interest is being accumulated\n\t * @return The previous principal balance, the new principal balance and the balance increase\n\t **/\n\tfunction _calculateBalanceIncrease(address user) internal view returns (uint256, uint256, uint256) {\n\t\tuint256 previousPrincipalBalance = super.balanceOf(user);\n\n\t\tif (previousPrincipalBalance == 0) {\n\t\t\treturn (0, 0, 0);\n\t\t}\n\n\t\t// Calculation of the accrued interest since the last accumulation\n\t\tuint256 balanceIncrease = balanceOf(user).sub(previousPrincipalBalance);\n\n\t\treturn (previousPrincipalBalance, previousPrincipalBalance.add(balanceIncrease), balanceIncrease);\n\t}\n\n\t/**\n\t * @dev Returns the principal and total supply, the average borrow rate and the last supply update timestamp\n\t **/\n\tfunction getSupplyData() public view override returns (uint256, uint256, uint256, uint40) {\n\t\tuint256 avgRate = _avgStableRate;\n\t\treturn (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp);\n\t}\n\n\t/**\n\t * @dev Returns the the total supply and the average stable rate\n\t **/\n\tfunction getTotalSupplyAndAvgRate() public view override returns (uint256, uint256) {\n\t\tuint256 avgRate = _avgStableRate;\n\t\treturn (_calcTotalSupply(avgRate), avgRate);\n\t}\n\n\t/**\n\t * @dev Returns the total supply\n\t **/\n\tfunction totalSupply() public view override returns (uint256) {\n\t\treturn _calcTotalSupply(_avgStableRate);\n\t}\n\n\t/**\n\t * @dev Returns the timestamp at which the total supply was updated\n\t **/\n\tfunction getTotalSupplyLastUpdated() public view override returns (uint40) {\n\t\treturn _totalSupplyTimestamp;\n\t}\n\n\t/**\n\t * @dev Returns the principal debt balance of the user from\n\t * @param user The user's address\n\t * @return The debt balance of the user since the last burn/mint action\n\t **/\n\tfunction principalBalanceOf(address user) external view virtual override returns (uint256) {\n\t\treturn super.balanceOf(user);\n\t}\n\n\t/**\n\t * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t **/\n\tfunction UNDERLYING_ASSET_ADDRESS() public view returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\t/**\n\t * @dev Returns the address of the lending pool where this aToken is used\n\t **/\n\tfunction POOL() public view returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view override returns (IAaveIncentivesController) {\n\t\treturn _getIncentivesController();\n\t}\n\n\t/**\n\t * @dev For internal usage in the logic of the parent contracts\n\t **/\n\tfunction _getIncentivesController() internal view override returns (IAaveIncentivesController) {\n\t\treturn _incentivesController;\n\t}\n\n\t/**\n\t * @dev For internal usage in the logic of the parent contracts\n\t **/\n\tfunction _getUnderlyingAssetAddress() internal view override returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\t/**\n\t * @dev For internal usage in the logic of the parent contracts\n\t **/\n\tfunction _getLendingPool() internal view override returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n\n\t/**\n\t * @dev Calculates the total supply\n\t * @param avgRate The average rate at which the total supply increases\n\t * @return The debt balance of the user since the last burn/mint action\n\t **/\n\tfunction _calcTotalSupply(uint256 avgRate) internal view virtual returns (uint256) {\n\t\tuint256 principalSupply = super.totalSupply();\n\n\t\tif (principalSupply == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 cumulatedInterest = MathUtils.calculateCompoundedInterest(avgRate, _totalSupplyTimestamp);\n\n\t\treturn principalSupply.rayMul(cumulatedInterest);\n\t}\n\n\t/**\n\t * @dev Mints stable debt tokens to an user\n\t * @param account The account receiving the debt tokens\n\t * @param amount The amount being minted\n\t * @param oldTotalSupply the total supply before the minting event\n\t **/\n\tfunction _mint(address account, uint256 amount, uint256 oldTotalSupply) internal {\n\t\tuint256 oldAccountBalance = _balances[account];\n\t\tif (address(_incentivesController) != address(0)) {\n\t\t\t_incentivesController.handleActionBefore(account);\n\t\t}\n\t\t_balances[account] = oldAccountBalance.add(amount);\n\t\tif (address(_incentivesController) != address(0)) {\n\t\t\t_incentivesController.handleActionAfter(account, oldAccountBalance, oldTotalSupply);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Burns stable debt tokens of an user\n\t * @param account The user getting his debt burned\n\t * @param amount The amount being burned\n\t * @param oldTotalSupply The total supply before the burning event\n\t **/\n\tfunction _burn(address account, uint256 amount, uint256 oldTotalSupply) internal {\n\t\tuint256 oldAccountBalance = _balances[account];\n\t\tif (address(_incentivesController) != address(0)) {\n\t\t\t_incentivesController.handleActionBefore(account);\n\t\t}\n\t\t_balances[account] = oldAccountBalance.sub(amount, Errors.SDT_BURN_EXCEEDS_BALANCE);\n\t\tif (address(_incentivesController) != address(0)) {\n\t\t\t_incentivesController.handleActionAfter(account, oldAccountBalance, oldTotalSupply);\n\t\t}\n\t}\n}\n"
    },
    "contracts/lending/tokenization/VariableDebtToken.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\nimport {IVariableDebtToken} from \"../../interfaces/IVariableDebtToken.sol\";\nimport {WadRayMath} from \"../libraries/math/WadRayMath.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\nimport {DebtTokenBase} from \"./base/DebtTokenBase.sol\";\nimport {ILendingPool} from \"../../interfaces/ILendingPool.sol\";\nimport {IAaveIncentivesController} from \"../../interfaces/IAaveIncentivesController.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title VariableDebtToken\n * @notice Implements a variable debt token to track the borrowing positions of users\n * at variable rate mode\n * @author Aave\n **/\ncontract VariableDebtToken is DebtTokenBase, IVariableDebtToken {\n\tusing WadRayMath for uint256;\n\tusing SafeMath for uint256;\n\n\tuint256 public constant DEBT_TOKEN_REVISION = 0x1;\n\n\tIAaveIncentivesController internal _incentivesController;\n\n\t/**\n\t * @dev Initializes the debt token.\n\t * @param pool The address of the lending pool where this aToken will be used\n\t * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t * @param incentivesController The smart contract managing potential incentives distribution\n\t * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\n\t * @param debtTokenName The name of the token\n\t * @param debtTokenSymbol The symbol of the token\n\t */\n\tfunction initialize(\n\t\tILendingPool pool,\n\t\taddress underlyingAsset,\n\t\tIAaveIncentivesController incentivesController,\n\t\tuint8 debtTokenDecimals,\n\t\tstring memory debtTokenName,\n\t\tstring memory debtTokenSymbol,\n\t\tbytes calldata params\n\t) public override initializer {\n\t\t_setName(debtTokenName);\n\t\t_setSymbol(debtTokenSymbol);\n\t\t_setDecimals(debtTokenDecimals);\n\n\t\t_pool = pool;\n\t\t_underlyingAsset = underlyingAsset;\n\t\t_incentivesController = incentivesController;\n\n\t\temit Initialized(\n\t\t\tunderlyingAsset,\n\t\t\taddress(pool),\n\t\t\taddress(incentivesController),\n\t\t\tdebtTokenDecimals,\n\t\t\tdebtTokenName,\n\t\t\tdebtTokenSymbol,\n\t\t\tparams\n\t\t);\n\t}\n\n\t/**\n\t * @dev Gets the revision of the stable debt token implementation\n\t * @return The debt token implementation revision\n\t **/\n\tfunction getRevision() internal pure virtual override returns (uint256) {\n\t\treturn DEBT_TOKEN_REVISION;\n\t}\n\n\t/**\n\t * @dev Calculates the accumulated debt balance of the user\n\t * @return The debt balance of the user\n\t **/\n\tfunction balanceOf(address user) public view virtual override returns (uint256) {\n\t\tuint256 scaledBalance = super.balanceOf(user);\n\n\t\tif (scaledBalance == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn scaledBalance.rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset));\n\t}\n\n\t/**\n\t * @dev Mints debt token to the `onBehalfOf` address\n\t * -  Only callable by the LendingPool\n\t * @param user The address receiving the borrowed underlying, being the delegatee in case\n\t * of credit delegate, or same as `onBehalfOf` otherwise\n\t * @param onBehalfOf The address receiving the debt tokens\n\t * @param amount The amount of debt being minted\n\t * @param index The variable debt index of the reserve\n\t * @return `true` if the the previous balance of the user is 0\n\t **/\n\tfunction mint(\n\t\taddress user,\n\t\taddress onBehalfOf,\n\t\tuint256 amount,\n\t\tuint256 index\n\t) external override onlyLendingPool returns (bool) {\n\t\tif (user != onBehalfOf) {\n\t\t\t_decreaseBorrowAllowance(onBehalfOf, user, amount);\n\t\t}\n\n\t\tuint256 previousBalance = super.balanceOf(onBehalfOf);\n\t\tuint256 amountScaled = amount.rayDiv(index);\n\t\trequire(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n\n\t\t_mint(onBehalfOf, amountScaled);\n\n\t\temit Transfer(address(0), onBehalfOf, amount);\n\t\temit Mint(user, onBehalfOf, amount, index);\n\n\t\treturn previousBalance == 0;\n\t}\n\n\t/**\n\t * @dev Burns user variable debt\n\t * - Only callable by the LendingPool\n\t * @param user The user whose debt is getting burned\n\t * @param amount The amount getting burned\n\t * @param index The variable debt index of the reserve\n\t **/\n\tfunction burn(address user, uint256 amount, uint256 index) external override onlyLendingPool {\n\t\tuint256 amountScaled = amount.rayDiv(index);\n\t\trequire(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n\n\t\t_burn(user, amountScaled);\n\n\t\temit Transfer(user, address(0), amount);\n\t\temit Burn(user, amount, index);\n\t}\n\n\t/**\n\t * @dev Returns the principal debt balance of the user from\n\t * @return The debt balance of the user since the last burn/mint action\n\t **/\n\tfunction scaledBalanceOf(address user) public view virtual override returns (uint256) {\n\t\treturn super.balanceOf(user);\n\t}\n\n\t/**\n\t * @dev Returns the total supply of the variable debt token. Represents the total debt accrued by the users\n\t * @return The total supply\n\t **/\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn super.totalSupply().rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset));\n\t}\n\n\t/**\n\t * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n\t * @return the scaled total supply\n\t **/\n\tfunction scaledTotalSupply() public view virtual override returns (uint256) {\n\t\treturn super.totalSupply();\n\t}\n\n\t/**\n\t * @dev Returns the principal balance of the user and principal total supply.\n\t * @param user The address of the user\n\t * @return The principal balance of the user\n\t * @return The principal total supply\n\t **/\n\tfunction getScaledUserBalanceAndSupply(address user) external view override returns (uint256, uint256) {\n\t\treturn (super.balanceOf(user), super.totalSupply());\n\t}\n\n\t/**\n\t * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n\t **/\n\tfunction UNDERLYING_ASSET_ADDRESS() public view returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\t/**\n\t * @dev Returns the address of the incentives controller contract\n\t **/\n\tfunction getIncentivesController() external view override returns (IAaveIncentivesController) {\n\t\treturn _getIncentivesController();\n\t}\n\n\t/**\n\t * @dev Returns the address of the lending pool where this aToken is used\n\t **/\n\tfunction POOL() public view returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n\n\tfunction _getIncentivesController() internal view override returns (IAaveIncentivesController) {\n\t\treturn _incentivesController;\n\t}\n\n\tfunction _getUnderlyingAssetAddress() internal view override returns (address) {\n\t\treturn _underlyingAsset;\n\t}\n\n\tfunction _getLendingPool() internal view override returns (ILendingPool) {\n\t\treturn _pool;\n\t}\n}\n"
    },
    "contracts/lending/UiPoolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ILendingPoolAddressesProvider} from \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {IAaveIncentivesController} from \"../interfaces/IAaveIncentivesController.sol\";\nimport {IUiPoolDataProvider} from \"../interfaces/IUiPoolDataProvider.sol\";\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IAToken} from \"../interfaces/IAToken.sol\";\nimport {IVariableDebtToken} from \"../interfaces/IVariableDebtToken.sol\";\nimport {IStableDebtToken} from \"../interfaces/IStableDebtToken.sol\";\nimport {WadRayMath} from \"./libraries/math/WadRayMath.sol\";\nimport {ReserveConfiguration} from \"./libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"./libraries/configuration/UserConfiguration.sol\";\nimport {DataTypes} from \"./libraries/types/DataTypes.sol\";\nimport {DefaultReserveInterestRateStrategy} from \"./lendingpool/DefaultReserveInterestRateStrategy.sol\";\n\ncontract UiPoolDataProvider is IUiPoolDataProvider {\n\tusing WadRayMath for uint256;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\taddress public constant MOCK_USD_ADDRESS = 0x10F7Fc1F91Ba351f9C629c5947AD69bD03C05b96;\n\tIAaveIncentivesController public immutable incentivesController;\n\tIPriceOracleGetter public immutable oracle;\n\n\tconstructor(IAaveIncentivesController _incentivesController, IPriceOracleGetter _oracle) {\n\t\tincentivesController = _incentivesController;\n\t\toracle = _oracle;\n\t}\n\n\tfunction getInterestRateStrategySlopes(\n\t\tDefaultReserveInterestRateStrategy interestRateStrategy\n\t) internal view returns (uint256, uint256, uint256, uint256) {\n\t\treturn (\n\t\t\tinterestRateStrategy.variableRateSlope1(),\n\t\t\tinterestRateStrategy.variableRateSlope2(),\n\t\t\tinterestRateStrategy.stableRateSlope1(),\n\t\t\tinterestRateStrategy.stableRateSlope2()\n\t\t);\n\t}\n\n\tfunction getReservesData(\n\t\tILendingPoolAddressesProvider provider,\n\t\taddress user\n\t)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (AggregatedReserveData[] memory, UserReserveData[] memory, uint256, IncentivesControllerData memory)\n\t{\n\t\tILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n\t\taddress[] memory reserves = lendingPool.getReservesList();\n\t\tDataTypes.UserConfigurationMap memory userConfig = lendingPool.getUserConfiguration(user);\n\n\t\tAggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length);\n\t\tUserReserveData[] memory userReservesData = new UserReserveData[](user != address(0) ? reserves.length : 0);\n\n\t\tfor (uint256 i = 0; i < reserves.length; i++) {\n\t\t\tAggregatedReserveData memory reserveData = reservesData[i];\n\t\t\treserveData.underlyingAsset = reserves[i];\n\n\t\t\t// reserve current state\n\t\t\tDataTypes.ReserveData memory baseData = lendingPool.getReserveData(reserveData.underlyingAsset);\n\t\t\treserveData.liquidityIndex = baseData.liquidityIndex;\n\t\t\treserveData.variableBorrowIndex = baseData.variableBorrowIndex;\n\t\t\treserveData.liquidityRate = baseData.currentLiquidityRate;\n\t\t\treserveData.variableBorrowRate = baseData.currentVariableBorrowRate;\n\t\t\treserveData.stableBorrowRate = baseData.currentStableBorrowRate;\n\t\t\treserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp;\n\t\t\treserveData.aTokenAddress = baseData.aTokenAddress;\n\t\t\treserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress;\n\t\t\treserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress;\n\t\t\treserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress;\n\t\t\treserveData.priceInEth = oracle.getAssetPrice(reserveData.underlyingAsset);\n\n\t\t\treserveData.availableLiquidity = IERC20Metadata(reserveData.underlyingAsset).balanceOf(\n\t\t\t\treserveData.aTokenAddress\n\t\t\t);\n\t\t\t(\n\t\t\t\treserveData.totalPrincipalStableDebt,\n\t\t\t\t,\n\t\t\t\treserveData.averageStableRate,\n\t\t\t\treserveData.stableDebtLastUpdateTimestamp\n\t\t\t) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData();\n\t\t\treserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\n\t\t\t\t.scaledTotalSupply();\n\n\t\t\t// reserve configuration\n\n\t\t\t// we're getting this info from the aToken, because some of assets can be not compliant with ETC20Detailed\n\t\t\treserveData.symbol = IERC20Metadata(reserveData.aTokenAddress).symbol();\n\t\t\treserveData.name = \"\";\n\n\t\t\t(\n\t\t\t\treserveData.baseLTVasCollateral,\n\t\t\t\treserveData.reserveLiquidationThreshold,\n\t\t\t\treserveData.reserveLiquidationBonus,\n\t\t\t\treserveData.decimals,\n\t\t\t\treserveData.reserveFactor\n\t\t\t) = baseData.configuration.getParamsMemory();\n\t\t\t(\n\t\t\t\treserveData.isActive,\n\t\t\t\treserveData.isFrozen,\n\t\t\t\treserveData.borrowingEnabled,\n\t\t\t\treserveData.stableBorrowRateEnabled\n\t\t\t) = baseData.configuration.getFlagsMemory();\n\t\t\treserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0;\n\t\t\t(\n\t\t\t\treserveData.variableRateSlope1,\n\t\t\t\treserveData.variableRateSlope2,\n\t\t\t\treserveData.stableRateSlope1,\n\t\t\t\treserveData.stableRateSlope2\n\t\t\t) = getInterestRateStrategySlopes(\n\t\t\t\tDefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\n\t\t\t);\n\n\t\t\t// incentives\n\t\t\tif (address(0) != address(incentivesController)) {\n\t\t\t\t(\n\t\t\t\t\treserveData.aTokenIncentivesIndex,\n\t\t\t\t\treserveData.aEmissionPerSecond,\n\t\t\t\t\treserveData.aIncentivesLastUpdateTimestamp\n\t\t\t\t) = incentivesController.getAssetData(reserveData.aTokenAddress);\n\n\t\t\t\t(\n\t\t\t\t\treserveData.sTokenIncentivesIndex,\n\t\t\t\t\treserveData.sEmissionPerSecond,\n\t\t\t\t\treserveData.sIncentivesLastUpdateTimestamp\n\t\t\t\t) = incentivesController.getAssetData(reserveData.stableDebtTokenAddress);\n\n\t\t\t\t(\n\t\t\t\t\treserveData.vTokenIncentivesIndex,\n\t\t\t\t\treserveData.vEmissionPerSecond,\n\t\t\t\t\treserveData.vIncentivesLastUpdateTimestamp\n\t\t\t\t) = incentivesController.getAssetData(reserveData.variableDebtTokenAddress);\n\t\t\t}\n\n\t\t\tif (user != address(0)) {\n\t\t\t\t// incentives\n\t\t\t\tif (address(0) != address(incentivesController)) {\n\t\t\t\t\tuserReservesData[i].aTokenincentivesUserIndex = incentivesController.getUserAssetData(\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\treserveData.aTokenAddress\n\t\t\t\t\t);\n\t\t\t\t\tuserReservesData[i].vTokenincentivesUserIndex = incentivesController.getUserAssetData(\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\treserveData.variableDebtTokenAddress\n\t\t\t\t\t);\n\t\t\t\t\tuserReservesData[i].sTokenincentivesUserIndex = incentivesController.getUserAssetData(\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\treserveData.stableDebtTokenAddress\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// user reserve data\n\t\t\t\tuserReservesData[i].underlyingAsset = reserveData.underlyingAsset;\n\t\t\t\tuserReservesData[i].scaledATokenBalance = IAToken(reserveData.aTokenAddress).scaledBalanceOf(user);\n\t\t\t\tuserReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i);\n\n\t\t\t\tif (userConfig.isBorrowing(i)) {\n\t\t\t\t\tuserReservesData[i].scaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\n\t\t\t\t\t\t.scaledBalanceOf(user);\n\t\t\t\t\tuserReservesData[i].principalStableDebt = IStableDebtToken(reserveData.stableDebtTokenAddress)\n\t\t\t\t\t\t.principalBalanceOf(user);\n\t\t\t\t\tif (userReservesData[i].principalStableDebt != 0) {\n\t\t\t\t\t\tuserReservesData[i].stableBorrowRate = IStableDebtToken(reserveData.stableDebtTokenAddress)\n\t\t\t\t\t\t\t.getUserStableRate(user);\n\t\t\t\t\t\tuserReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken(\n\t\t\t\t\t\t\treserveData.stableDebtTokenAddress\n\t\t\t\t\t\t).getUserLastUpdated(user);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tIncentivesControllerData memory incentivesControllerData;\n\n\t\tif (address(0) != address(incentivesController)) {\n\t\t\tif (user != address(0)) {\n\t\t\t\tincentivesControllerData.userUnclaimedRewards = incentivesController.getUserUnclaimedRewards(user);\n\t\t\t}\n\t\t\tincentivesControllerData.emissionEndTimestamp = incentivesController.DISTRIBUTION_END();\n\t\t}\n\n\t\treturn (reservesData, userReservesData, 10 ** 8, incentivesControllerData);\n\t}\n}\n"
    },
    "contracts/lending/UiPoolDataProviderV2V3.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IUiPoolDataProviderV3} from '../interfaces/IUiPoolDataProviderV3.sol';\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\nimport {IAaveOracle} from '../interfaces/IAaveOracle.sol';\nimport {IAToken} from '../interfaces/IAToken.sol';\nimport {IVariableDebtToken} from '../interfaces/IVariableDebtToken.sol';\nimport {IStableDebtToken} from '../interfaces/IStableDebtToken.sol';\nimport {WadRayMath} from './libraries/math/WadRayMath.sol';\nimport {ReserveConfiguration} from './libraries/configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from './libraries/configuration/UserConfiguration.sol';\nimport {DataTypes} from './libraries/types/DataTypes.sol';\nimport {IChainlinkAggregator} from '../interfaces/IChainlinkAggregator.sol';\nimport {DefaultReserveInterestRateStrategy} from './lendingpool/DefaultReserveInterestRateStrategy.sol';\nimport {IERC20DetailedBytes} from '../interfaces/IERC20DetailedBytes.sol';\n\ncontract UiPoolDataProviderV2V3 is IUiPoolDataProviderV3 {\n  using WadRayMath for uint256;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  IChainlinkAggregator public immutable networkBaseTokenPriceInUsdProxyAggregator;\n  IChainlinkAggregator public immutable marketReferenceCurrencyPriceInUsdProxyAggregator;\n  uint256 public constant ETH_CURRENCY_UNIT = 1 ether;\n  address public constant MKRAddress = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n\n  constructor(\n    IChainlinkAggregator _networkBaseTokenPriceInUsdProxyAggregator,\n    IChainlinkAggregator _marketReferenceCurrencyPriceInUsdProxyAggregator\n  ) {\n    networkBaseTokenPriceInUsdProxyAggregator = _networkBaseTokenPriceInUsdProxyAggregator;\n    marketReferenceCurrencyPriceInUsdProxyAggregator = _marketReferenceCurrencyPriceInUsdProxyAggregator;\n  }\n\n  function getInterestRateStrategySlopes(DefaultReserveInterestRateStrategy interestRateStrategy)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return (\n      interestRateStrategy.variableRateSlope1(),\n      interestRateStrategy.variableRateSlope2(),\n      interestRateStrategy.stableRateSlope1(),\n      interestRateStrategy.stableRateSlope2()\n    );\n  }\n\n  function getReservesList(ILendingPoolAddressesProvider provider)\n    public\n    view\n    override\n    returns (address[] memory)\n  {\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n    return lendingPool.getReservesList();\n  }\n\n  function getReservesData(ILendingPoolAddressesProvider provider)\n    public\n    view\n    override\n    returns (AggregatedReserveData[] memory, BaseCurrencyInfo memory)\n  {\n    IAaveOracle oracle = IAaveOracle(provider.getPriceOracle());\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n    address[] memory reserves = lendingPool.getReservesList();\n    AggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length);\n\n    for (uint256 i = 0; i < reserves.length; i++) {\n      AggregatedReserveData memory reserveData = reservesData[i];\n      reserveData.underlyingAsset = reserves[i];\n\n      // reserve current state\n      DataTypes.ReserveData memory baseData = lendingPool.getReserveData(\n        reserveData.underlyingAsset\n      );\n      reserveData.liquidityIndex = baseData.liquidityIndex;\n      reserveData.variableBorrowIndex = baseData.variableBorrowIndex;\n      reserveData.liquidityRate = baseData.currentLiquidityRate;\n      reserveData.variableBorrowRate = baseData.currentVariableBorrowRate;\n      reserveData.stableBorrowRate = baseData.currentStableBorrowRate;\n      reserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp;\n      reserveData.aTokenAddress = baseData.aTokenAddress;\n      reserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress;\n      reserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress;\n      reserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress;\n      reserveData.priceInMarketReferenceCurrency = oracle.getAssetPrice(\n        reserveData.underlyingAsset\n      );\n\n      reserveData.availableLiquidity = IERC20Detailed(reserveData.underlyingAsset).balanceOf(\n        reserveData.aTokenAddress\n      );\n      (\n        reserveData.totalPrincipalStableDebt,\n        ,\n        reserveData.averageStableRate,\n        reserveData.stableDebtLastUpdateTimestamp\n      ) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData();\n      reserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress)\n        .scaledTotalSupply();\n\n      if (address(reserveData.underlyingAsset) == address(MKRAddress)) {\n        bytes32 symbol = IERC20DetailedBytes(reserveData.underlyingAsset).symbol();\n        reserveData.symbol = bytes32ToString(symbol);\n      } else {\n        reserveData.symbol = IERC20Detailed(reserveData.underlyingAsset).symbol();\n      }\n\n      (\n        reserveData.baseLTVasCollateral,\n        reserveData.reserveLiquidationThreshold,\n        reserveData.reserveLiquidationBonus,\n        reserveData.decimals,\n        reserveData.reserveFactor\n      ) = baseData.configuration.getParamsMemory();\n      (\n        reserveData.isActive,\n        reserveData.isFrozen,\n        reserveData.borrowingEnabled,\n        reserveData.stableBorrowRateEnabled\n      ) = baseData.configuration.getFlagsMemory();\n      reserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0;\n      (\n        reserveData.variableRateSlope1,\n        reserveData.variableRateSlope2,\n        reserveData.stableRateSlope1,\n        reserveData.stableRateSlope2\n      ) = getInterestRateStrategySlopes(\n        DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\n      );\n    }\n\n    BaseCurrencyInfo memory baseCurrencyInfo;\n    baseCurrencyInfo.networkBaseTokenPriceInUsd = networkBaseTokenPriceInUsdProxyAggregator\n      .latestAnswer();\n    baseCurrencyInfo.networkBaseTokenPriceDecimals = networkBaseTokenPriceInUsdProxyAggregator\n      .decimals();\n\n    try oracle.BASE_CURRENCY_UNIT() returns (uint256 baseCurrencyUnit) {\n      if (ETH_CURRENCY_UNIT == baseCurrencyUnit) {\n        baseCurrencyInfo.marketReferenceCurrencyUnit = ETH_CURRENCY_UNIT;\n        baseCurrencyInfo\n        .marketReferenceCurrencyPriceInUsd = marketReferenceCurrencyPriceInUsdProxyAggregator\n        .latestAnswer();\n      } else {\n        baseCurrencyInfo.marketReferenceCurrencyUnit = baseCurrencyUnit;\n        baseCurrencyInfo.marketReferenceCurrencyPriceInUsd = int256(baseCurrencyUnit);\n      }\n    } catch (\n      bytes memory /*lowLevelData*/\n    ) {\n      baseCurrencyInfo.marketReferenceCurrencyUnit = ETH_CURRENCY_UNIT;\n      baseCurrencyInfo\n        .marketReferenceCurrencyPriceInUsd = marketReferenceCurrencyPriceInUsdProxyAggregator\n        .latestAnswer();\n    }\n\n    return (reservesData, baseCurrencyInfo);\n  }\n\n  function getUserReservesData(ILendingPoolAddressesProvider provider, address user)\n    external\n    view\n    override\n    returns (UserReserveData[] memory, uint8)\n  {\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\n    address[] memory reserves = lendingPool.getReservesList();\n    DataTypes.UserConfigurationMap memory userConfig = lendingPool.getUserConfiguration(user);\n\n    UserReserveData[] memory userReservesData = new UserReserveData[](\n      user != address(0) ? reserves.length : 0\n    );\n\n    for (uint256 i = 0; i < reserves.length; i++) {\n      DataTypes.ReserveData memory baseData = lendingPool.getReserveData(reserves[i]);\n\n      // user reserve data\n      userReservesData[i].underlyingAsset = reserves[i];\n      userReservesData[i].scaledATokenBalance = IAToken(baseData.aTokenAddress).scaledBalanceOf(\n        user\n      );\n      userReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i);\n\n      if (userConfig.isBorrowing(i)) {\n        userReservesData[i].scaledVariableDebt = IVariableDebtToken(\n          baseData.variableDebtTokenAddress\n        ).scaledBalanceOf(user);\n        userReservesData[i].principalStableDebt = IStableDebtToken(baseData.stableDebtTokenAddress)\n          .principalBalanceOf(user);\n        if (userReservesData[i].principalStableDebt != 0) {\n          userReservesData[i].stableBorrowRate = IStableDebtToken(baseData.stableDebtTokenAddress)\n            .getUserStableRate(user);\n          userReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken(\n            baseData.stableDebtTokenAddress\n          ).getUserLastUpdated(user);\n        }\n      }\n    }\n\n    // Return 0 to be compatible with v3 userEmodeCategoryId return\n    return (userReservesData, 0);\n  }\n\n  function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n    uint8 i = 0;\n    while (i < 32 && _bytes32[i] != 0) {\n      i++;\n    }\n    bytes memory bytesArray = new bytes(i);\n    for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n      bytesArray[i] = _bytes32[i];\n    }\n    return string(bytesArray);\n  }\n}"
    },
    "contracts/lending/WalletBalanceProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILendingPoolAddressesProvider} from \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReserveConfiguration} from \"./libraries/configuration/ReserveConfiguration.sol\";\nimport {DataTypes} from \"./libraries/types/DataTypes.sol\";\n\n/**\n * @title WalletBalanceProvider contract\n * @author Aave, influenced by https://github.com/wbobeirne/eth-balance-checker/blob/master/contracts/BalanceChecker.sol\n * @notice Implements a logic of getting multiple tokens balance for one user address\n * @dev NOTE: THIS CONTRACT IS NOT USED WITHIN THE AAVE PROTOCOL. It's an accessory contract used to reduce the number of calls\n * towards the blockchain from the Aave backend.\n **/\ncontract WalletBalanceProvider {\n\tusing Address for address payable;\n\tusing Address for address;\n\tusing SafeERC20 for IERC20;\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n\taddress constant MOCK_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\t/**\n    @dev Fallback function, don't accept any ETH\n    **/\n\treceive() external payable {\n\t\t//only contracts can send ETH to the core\n\t\trequire(msg.sender.isContract(), \"22\");\n\t}\n\n\t/**\n    @dev Check the token balance of a wallet in a token contract\n\n    Returns the balance of the token for user. Avoids possible errors:\n      - return 0 on non-contract address\n    **/\n\tfunction balanceOf(address user, address token) public view returns (uint256) {\n\t\tif (token == MOCK_ETH_ADDRESS) {\n\t\t\treturn user.balance; // ETH balance\n\t\t\t// check if token is actually a contract\n\t\t} else if (token.isContract()) {\n\t\t\treturn IERC20(token).balanceOf(user);\n\t\t}\n\t\trevert(\"INVALID_TOKEN\");\n\t}\n\n\t/**\n\t * @notice Fetches, for a list of _users and _tokens (ETH included with mock address), the balances\n\t * @param users The list of users\n\t * @param tokens The list of tokens\n\t * @return And array with the concatenation of, for each user, his/her balances\n\t **/\n\tfunction batchBalanceOf(\n\t\taddress[] calldata users,\n\t\taddress[] calldata tokens\n\t) external view returns (uint256[] memory) {\n\t\tuint256[] memory balances = new uint256[](users.length * tokens.length);\n\n\t\tfor (uint256 i = 0; i < users.length; i++) {\n\t\t\tfor (uint256 j = 0; j < tokens.length; j++) {\n\t\t\t\tbalances[i * tokens.length + j] = balanceOf(users[i], tokens[j]);\n\t\t\t}\n\t\t}\n\n\t\treturn balances;\n\t}\n\n\t/**\n    @dev provides balances of user wallet for all reserves available on the pool\n    */\n\tfunction getUserWalletBalances(\n\t\taddress provider,\n\t\taddress user\n\t) external view returns (address[] memory, uint256[] memory) {\n\t\tILendingPool pool = ILendingPool(ILendingPoolAddressesProvider(provider).getLendingPool());\n\n\t\taddress[] memory reserves = pool.getReservesList();\n\t\taddress[] memory reservesWithEth = new address[](reserves.length + 1);\n\t\tfor (uint256 i = 0; i < reserves.length; i++) {\n\t\t\treservesWithEth[i] = reserves[i];\n\t\t}\n\t\treservesWithEth[reserves.length] = MOCK_ETH_ADDRESS;\n\n\t\tuint256[] memory balances = new uint256[](reservesWithEth.length);\n\n\t\tfor (uint256 j = 0; j < reserves.length; j++) {\n\t\t\tDataTypes.ReserveConfigurationMap memory configuration = pool.getConfiguration(reservesWithEth[j]);\n\n\t\t\t(bool isActive, , , ) = configuration.getFlagsMemory();\n\n\t\t\tif (!isActive) {\n\t\t\t\tbalances[j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbalances[j] = balanceOf(user, reservesWithEth[j]);\n\t\t}\n\t\tbalances[reserves.length] = balanceOf(user, MOCK_ETH_ADDRESS);\n\n\t\treturn (reservesWithEth, balances);\n\t}\n}\n"
    },
    "contracts/lending/WETHGateway.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ILendingPool} from \"../interfaces/ILendingPool.sol\";\nimport {IAToken} from \"../interfaces/IAToken.sol\";\nimport {ReserveConfiguration} from \"./libraries/configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"./libraries/configuration/UserConfiguration.sol\";\nimport {Helpers} from \"./libraries/helpers/Helpers.sol\";\nimport {DataTypes} from \"./libraries/types/DataTypes.sol\";\n\ncontract WETHGateway is IWETHGateway, Ownable {\n\tusing ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\tusing UserConfiguration for DataTypes.UserConfigurationMap;\n\n\tIWETH internal immutable WETH;\n\n\t/**\n\t * @dev Sets the WETH address and the LendingPoolAddressesProvider address. Infinite approves lending pool.\n\t * @param weth Address of the Wrapped Ether contract\n\t **/\n\tconstructor(address weth) {\n\t\tWETH = IWETH(weth);\n\t}\n\n\tfunction authorizeLendingPool(address lendingPool) external onlyOwner {\n\t\tWETH.approve(lendingPool, type(uint256).max);\n\t}\n\n\t/**\n\t * @dev deposits WETH into the reserve, using native ETH. A corresponding amount of the overlying asset (aTokens)\n\t * is minted.\n\t * @param lendingPool address of the targeted underlying lending pool\n\t * @param onBehalfOf address of the user who will receive the aTokens representing the deposit\n\t * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\n\t **/\n\tfunction depositETH(address lendingPool, address onBehalfOf, uint16 referralCode) external payable override {\n\t\tWETH.deposit{value: msg.value}();\n\t\tILendingPool(lendingPool).deposit(address(WETH), msg.value, onBehalfOf, referralCode);\n\t}\n\n\tfunction depositETHWithAutoDLP(address lendingPool, address onBehalfOf, uint16 referralCode) external payable {\n\t\tWETH.deposit{value: msg.value}();\n\t\tILendingPool(lendingPool).depositWithAutoDLP(address(WETH), msg.value, onBehalfOf, referralCode);\n\t}\n\n\t/**\n\t * @dev withdraws the WETH _reserves of msg.sender.\n\t * @param lendingPool address of the targeted underlying lending pool\n\t * @param amount amount of aWETH to withdraw and receive native ETH\n\t * @param to address of the user who will receive native ETH\n\t */\n\tfunction withdrawETH(address lendingPool, uint256 amount, address to) external override {\n\t\tIAToken aWETH = IAToken(ILendingPool(lendingPool).getReserveData(address(WETH)).aTokenAddress);\n\t\tuint256 userBalance = aWETH.balanceOf(msg.sender);\n\t\tuint256 amountToWithdraw = amount;\n\n\t\t// if amount is equal to uint(-1), the user wants to redeem everything\n\t\tif (amount == type(uint256).max) {\n\t\t\tamountToWithdraw = userBalance;\n\t\t}\n\t\taWETH.transferFrom(msg.sender, address(this), amountToWithdraw);\n\t\tILendingPool(lendingPool).withdraw(address(WETH), amountToWithdraw, address(this));\n\t\tWETH.withdraw(amountToWithdraw);\n\t\t_safeTransferETH(to, amountToWithdraw);\n\t}\n\n\t/**\n\t * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n\t * @param lendingPool address of the targeted underlying lending pool\n\t * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n\t * @param rateMode the rate mode to repay\n\t * @param onBehalfOf the address for which msg.sender is repaying\n\t */\n\tfunction repayETH(\n\t\taddress lendingPool,\n\t\tuint256 amount,\n\t\tuint256 rateMode,\n\t\taddress onBehalfOf\n\t) external payable override {\n\t\t(uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebtMemory(\n\t\t\tonBehalfOf,\n\t\t\tILendingPool(lendingPool).getReserveData(address(WETH))\n\t\t);\n\n\t\tuint256 paybackAmount = DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE\n\t\t\t? stableDebt\n\t\t\t: variableDebt;\n\n\t\tif (amount < paybackAmount) {\n\t\t\tpaybackAmount = amount;\n\t\t}\n\t\trequire(msg.value >= paybackAmount, \"msg.value is less than repayment amount\");\n\t\tWETH.deposit{value: paybackAmount}();\n\t\tILendingPool(lendingPool).repay(address(WETH), msg.value, rateMode, onBehalfOf);\n\n\t\t// refund remaining dust eth\n\t\tif (msg.value > paybackAmount) _safeTransferETH(msg.sender, msg.value - paybackAmount);\n\t}\n\n\t/**\n\t * @dev borrow WETH, unwraps to ETH and send both the ETH and DebtTokens to msg.sender, via `approveDelegation` and onBehalf argument in `LendingPool.borrow`.\n\t * @param lendingPool address of the targeted underlying lending pool\n\t * @param amount the amount of ETH to borrow\n\t * @param interesRateMode the interest rate mode\n\t * @param referralCode integrators are assigned a referral code and can potentially receive rewards\n\t */\n\tfunction borrowETH(\n\t\taddress lendingPool,\n\t\tuint256 amount,\n\t\tuint256 interesRateMode,\n\t\tuint16 referralCode\n\t) external override {\n\t\tILendingPool(lendingPool).borrow(address(WETH), amount, interesRateMode, referralCode, msg.sender);\n\t\tWETH.withdraw(amount);\n\t\t_safeTransferETH(msg.sender, amount);\n\t}\n\n\t/**\n\t * @dev transfer ETH to an address, revert if it fails.\n\t * @param to recipient of the transfer\n\t * @param value the amount to send\n\t */\n\tfunction _safeTransferETH(address to, uint256 value) internal {\n\t\t(bool success, ) = to.call{value: value}(new bytes(0));\n\t\trequire(success, \"ETH_TRANSFER_FAILED\");\n\t}\n\n\t/**\n\t * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n\t * direct transfers to the contract address.\n\t * @param token token to transfer\n\t * @param to recipient of the transfer\n\t * @param amount amount to send\n\t */\n\tfunction emergencyTokenTransfer(address token, address to, uint256 amount) external onlyOwner {\n\t\tIERC20(token).transfer(to, amount);\n\t}\n\n\t/**\n\t * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\n\t * due selfdestructs or transfer ether to pre-computated contract address before deployment.\n\t * @param to recipient of the transfer\n\t * @param amount amount to send\n\t */\n\tfunction emergencyEtherTransfer(address to, uint256 amount) external onlyOwner {\n\t\t_safeTransferETH(to, amount);\n\t}\n\n\t/**\n\t * @dev Get WETH address used by WETHGateway\n\t */\n\tfunction getWETHAddress() external view returns (address) {\n\t\treturn address(WETH);\n\t}\n\n\t/**\n\t * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n\t */\n\treceive() external payable {\n\t\trequire(msg.sender == address(WETH), \"Receive not allowed\");\n\t}\n\n\t/**\n\t * @dev Revert fallback calls\n\t */\n\tfallback() external payable {\n\t\trevert(\"Fallback not allowed\");\n\t}\n}\n"
    },
    "contracts/Lock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            \"Unlock time should be in the future\"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\n\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\n        require(msg.sender == owner, \"You aren't the owner\");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n"
    },
    "contracts/radiant/accessories/Compounder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../../interfaces/IAaveOracle.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/ILockZap.sol\";\nimport \"../../interfaces/IPriceProvider.sol\";\nimport \"../../interfaces/IFeeDistribution.sol\";\nimport \"../../interfaces/IERC20DetailedBytes.sol\";\nimport \"../../interfaces/IMintableToken.sol\";\nimport \"../../interfaces/IBountyManager.sol\";\n\ncontract Compounder is OwnableUpgradeable, PausableUpgradeable {\n\tusing SafeERC20 for IERC20;\n\n\tstruct RewardData {\n\t\taddress token;\n\t\tuint256 amount;\n\t}\n\n\tevent RewardBaseTokensUpdated(address[] _tokens);\n\n\tevent RoutesUpdated(address _token, address[] _routes);\n\n\tuint256 public constant PERCENT_DIVISOR = 10000;\n\tuint256 public compoundFee;\n\tuint256 public slippageLimit;\n\n\tIMintableToken public rdntToken;\n\taddress public baseToken; //token that rdnt is paired with in LP\n\taddress public addressProvider;\n\taddress public priceProvider;\n\taddress[] public rewardBaseTokens;\n\taddress[] public wethToRadiant;\n\taddress public uniRouter;\n\taddress public multiFeeDistribution;\n\taddress public lockZap;\n\taddress public bountyManager;\n\tmapping(address => uint256) public lastAutocompound;\n\tmapping(address => address[]) public rewardToBaseRoute;\n\n\tfunction initialize(\n\t\taddress _uniRouter,\n\t\taddress _mfd,\n\t\taddress _baseToken,\n\t\taddress _addressProvider,\n\t\taddress _lockZap,\n\t\tuint256 _compoundFee,\n\t\tuint256 _slippageLimit\n\t) public initializer {\n\t\trequire(_uniRouter != address(0), \"0x0 address\");\n\t\trequire(_mfd != address(0), \"0x0 address\");\n\t\trequire(_baseToken != address(0), \"0x0 address\");\n\t\trequire(_addressProvider != address(0), \"0x0 address\");\n\t\trequire(_lockZap != address(0), \"0x0 address\");\n\t\trequire(_compoundFee > 0 && _compoundFee <= 2000, \"Invalid compound fee\");\n\t\trequire(_slippageLimit >= 8000 && _slippageLimit < PERCENT_DIVISOR, \"Invalid slippage limit\");\n\n\t\tuniRouter = _uniRouter;\n\t\tmultiFeeDistribution = _mfd;\n\t\tbaseToken = _baseToken;\n\t\taddressProvider = _addressProvider;\n\t\tlockZap = _lockZap;\n\t\trdntToken = IMultiFeeDistribution(multiFeeDistribution).rdntToken();\n\t\tpriceProvider = IMultiFeeDistribution(multiFeeDistribution).getPriceProvider();\n\t\twethToRadiant = [baseToken, address(rdntToken)];\n\t\tcompoundFee = _compoundFee;\n\t\tslippageLimit = _slippageLimit;\n\t\t__Ownable_init();\n\t\t__Pausable_init();\n\t}\n\n\tfunction pause() public onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction unpause() public onlyOwner {\n\t\t_unpause();\n\t}\n\n\tfunction addRewardBaseTokens(address[] memory _tokens) external onlyOwner {\n\t\trewardBaseTokens = _tokens;\n\t\temit RewardBaseTokensUpdated(_tokens);\n\t}\n\n\tfunction setRoutes(address _token, address[] memory _routes) external onlyOwner {\n\t\trewardToBaseRoute[_token] = _routes;\n\t\temit RoutesUpdated(_token, _routes);\n\t}\n\n\tfunction setBountyManager(address _manager) external onlyOwner {\n\t\trequire(_manager != address(0), \"bountyManager is 0 address\");\n\t\tbountyManager = _manager;\n\t}\n\n\tfunction setCompoundFee(uint256 _compoundFee) external onlyOwner {\n\t\trequire(_compoundFee > 0 && _compoundFee <= 2000, \"Invalid compound fee\");\n\t\tcompoundFee = _compoundFee;\n\t}\n\n\tfunction setSlippageLimit(uint256 _slippageLimit) external onlyOwner {\n\t\trequire(_slippageLimit >= 8000 && _slippageLimit < PERCENT_DIVISOR, \"Invalid slippage limit\");\n\t\tslippageLimit = _slippageLimit;\n\t}\n\n\tfunction _claimAndSwapToBase(address _user) internal returns (uint256) {\n\t\tIMultiFeeDistribution mfd = IMultiFeeDistribution(multiFeeDistribution);\n\t\tmfd.claimFromConverter(_user);\n\t\tILendingPool lendingPool = ILendingPool(ILendingPoolAddressesProvider(addressProvider).getLendingPool());\n\n\t\tfor (uint256 i = 0; i < rewardBaseTokens.length; i++) {\n\t\t\tuint256 balance = IERC20(rewardBaseTokens[i]).balanceOf(address(this));\n\t\t\tif (balance == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taddress underlying = IAToken(rewardBaseTokens[i]).UNDERLYING_ASSET_ADDRESS();\n\t\t\tuint256 amount = lendingPool.withdraw(underlying, type(uint256).max, address(this));\n\n\t\t\tif (underlying != baseToken) {\n\t\t\t\tIERC20(underlying).safeApprove(uniRouter, amount);\n\t\t\t\ttry\n\t\t\t\t\tIUniswapV2Router02(uniRouter).swapExactTokensForTokens(\n\t\t\t\t\t\tamount,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\trewardToBaseRoute[underlying],\n\t\t\t\t\t\taddress(this),\n\t\t\t\t\t\tblock.timestamp + 600\n\t\t\t\t\t)\n\t\t\t\t{} catch {}\n\t\t\t}\n\t\t}\n\t\treturn IERC20(baseToken).balanceOf(address(this));\n\t}\n\n\tfunction _convertBaseToLPandStake(address _user) internal returns (uint256 liquidity) {\n\t\tuint256 baseBal = IERC20(baseToken).balanceOf(address(this));\n\t\tif (baseBal != 0) {\n\t\t\tIERC20(baseToken).safeApprove(lockZap, baseBal);\n\t\t\tliquidity = ILockZap(lockZap).zapOnBehalf(false, baseBal, 0, _user);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compound user's rewards\n\t * @dev Can be auto compound or manual compound\n\t * @param _user user address\n\t * @param _execute whether to execute txn, or just quote (expected amount out for bounty executor)\n\t */\n\tfunction claimCompound(address _user, bool _execute) public returns (uint256 fee) {\n\t\tif (paused()) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tbool isAutoCompound = _user != msg.sender;\n\n\t\t(address[] memory tokens, uint256[] memory amts) = viewPendingRewards(_user);\n\t\tuint256 noSlippagePendingEth = _quoteSwapWithOracles(tokens, amts, baseToken);\n\n\t\tif (isAutoCompound) {\n\t\t\trequire(msg.sender == bountyManager, \"!bountymanager\");\n\t\t\tbool eligible = isEligibleForAutoCompound(_user, noSlippagePendingEth);\n\t\t\tif (!eligible) {\n\t\t\t\tif (_execute) {\n\t\t\t\t\trevert(\"not eligible for autocompound\");\n\t\t\t\t} else {\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\trequire(isEligibleForCompound(noSlippagePendingEth), \"min stake amt not met\");\n\t\t}\n\n\t\tif (!_execute) {\n\t\t\tuint256 pendingInRdnt = _wethToRdnt(noSlippagePendingEth, _execute);\n\t\t\tfee = (pendingInRdnt * compoundFee) / PERCENT_DIVISOR;\n\t\t\treturn fee;\n\t\t}\n\n\t\tuint256 actualWethAfterSwap = _claimAndSwapToBase(_user);\n\t\trequire((PERCENT_DIVISOR * actualWethAfterSwap) / noSlippagePendingEth >= slippageLimit, \"too much slippage\");\n\n\t\tif (isAutoCompound) {\n\t\t\tfee = _wethToRdnt(((actualWethAfterSwap * compoundFee) / PERCENT_DIVISOR), _execute);\n\t\t}\n\n\t\t_convertBaseToLPandStake(_user);\n\n\t\tif (isAutoCompound) {\n\t\t\trdntToken.approve(bountyManager, fee);\n\t\t\tlastAutocompound[_user] = block.timestamp;\n\t\t}\n\t}\n\n\tfunction selfCompound() external returns (uint256 fee) {\n\t\tfee = claimCompound(msg.sender, true);\n\t}\n\n\tfunction viewPendingRewards(address _user) public view returns (address[] memory tokens, uint256[] memory amts) {\n\t\tIFeeDistribution.RewardData[] memory pending = IMultiFeeDistribution(multiFeeDistribution).claimableRewards(\n\t\t\t_user\n\t\t);\n\t\ttokens = new address[](pending.length - 1);\n\t\tamts = new uint256[](pending.length - 1);\n\t\tuint256 index;\n\t\tfor (uint256 i = 0; i < pending.length; i++) {\n\t\t\tif (pending[i].token != address(rdntToken)) {\n\t\t\t\ttokens[index] = IAToken(pending[i].token).UNDERLYING_ASSET_ADDRESS();\n\t\t\t\tamts[index] = pending[i].amount;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _estimateTokensOut(address _in, address _out, uint256 _amtIn) internal view returns (uint256 tokensOut) {\n\t\tIAaveOracle oracle = IAaveOracle(ILendingPoolAddressesProvider(addressProvider).getPriceOracle());\n\t\tuint256 priceInAsset = oracle.getAssetPrice(_in); //USDC: 100000000\n\t\tuint256 priceOutAsset = oracle.getAssetPrice(_out); //WETH: 153359950000\n\t\tuint256 decimalsIn = IERC20DetailedBytes(_in).decimals();\n\t\tuint256 decimalsOut = IERC20DetailedBytes(_out).decimals();\n\t\ttokensOut = (_amtIn * priceInAsset * (10 ** decimalsOut)) / (priceOutAsset * (10 ** decimalsIn));\n\t}\n\n\tfunction _quoteSwapWithOracles(\n\t\taddress[] memory _in,\n\t\tuint256[] memory _amtsIn,\n\t\taddress _out\n\t) internal view returns (uint256 amtOut) {\n\t\trequire(_in.length == _amtsIn.length, \"length mismatch\");\n\t\tuint256 length = _in.length;\n\t\tfor (uint i = 0; i < length; i++) {\n\t\t\tamtOut += _estimateTokensOut(_in[i], _out, _amtsIn[i]);\n\t\t}\n\t}\n\n\tfunction _wethToRdnt(uint256 _wethIn, bool _execute) internal returns (uint256 rdntOut) {\n\t\tuint256 rdntPrice = IPriceProvider(priceProvider).getTokenPrice();\n\t\tif (_wethIn != 0) {\n\t\t\tif (_execute) {\n\t\t\t\tIERC20(baseToken).safeApprove(uniRouter, _wethIn);\n\t\t\t\tuint256[] memory amounts = IUniswapV2Router01(uniRouter).swapExactTokensForTokens(\n\t\t\t\t\t_wethIn,\n\t\t\t\t\t0,\n\t\t\t\t\twethToRadiant,\n\t\t\t\t\taddress(this),\n\t\t\t\t\tblock.timestamp + 600\n\t\t\t\t);\n\t\t\t\trdntOut = amounts[amounts.length - 1];\n\t\t\t} else {\n\t\t\t\tuint256[] memory amounts = IUniswapV2Router01(uniRouter).getAmountsOut(\n\t\t\t\t\t_wethIn, //amt in\n\t\t\t\t\twethToRadiant\n\t\t\t\t);\n\t\t\t\trdntOut = amounts[amounts.length - 1];\n\t\t\t}\n\t\t}\n\t\tuint256 ethValueOfRDNT = rdntPrice * rdntOut;\n\t\trequire(ethValueOfRDNT / 10 ** 8 >= (_wethIn * slippageLimit) / 10000, \"too much slippage\");\n\t}\n\n\tfunction autocompoundThreshold() public view returns (uint256 minStakeAmtEth) {\n\t\tIPriceProvider priceProv = IPriceProvider(priceProvider);\n\n\t\tuint256 minStakeLpAmt = IBountyManager(bountyManager).minDLPBalance();\n\t\tuint256 lpPriceEth = priceProv.getLpTokenPrice();\n\n\t\tminStakeAmtEth = (minStakeLpAmt * lpPriceEth) / (10 ** priceProv.decimals());\n\t}\n\n\tfunction isEligibleForAutoCompound(address _user, uint256 _pending) public view returns (bool) {\n\t\tbool delayComplete = true;\n\t\tif (lastAutocompound[_user] != 0) {\n\t\t\tdelayComplete = (block.timestamp - lastAutocompound[_user]) >= 1 days;\n\t\t}\n\t\treturn\n\t\t\tIMultiFeeDistribution(multiFeeDistribution).autocompoundEnabled(_user) &&\n\t\t\tisEligibleForCompound(_pending) &&\n\t\t\tdelayComplete;\n\t}\n\n\tfunction isEligibleForCompound(uint256 _pending) public view returns (bool eligible) {\n\t\teligible = _pending >= autocompoundThreshold();\n\t}\n\n\tfunction userEligibleForCompound(address _user) public view returns (bool eligible) {\n\t\t(address[] memory tokens, uint256[] memory amts) = viewPendingRewards(_user);\n\t\tuint256 pendingEth = _quoteSwapWithOracles(tokens, amts, baseToken);\n\t\teligible = pendingEth >= autocompoundThreshold();\n\t}\n\n\tfunction selfEligibleCompound() public view returns (bool eligible) {\n\t\t(address[] memory tokens, uint256[] memory amts) = viewPendingRewards(msg.sender);\n\t\tuint256 pendingEth = _quoteSwapWithOracles(tokens, amts, baseToken);\n\t\teligible = pendingEth >= autocompoundThreshold();\n\t}\n}\n"
    },
    "contracts/radiant/accessories/Leverager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/IEligibilityDataProvider.sol\";\nimport \"../../interfaces/IChainlinkAggregator.sol\";\nimport \"../../interfaces/IChefIncentivesController.sol\";\nimport \"../../interfaces/ILockZap.sol\";\nimport \"../../interfaces/IAaveOracle.sol\";\nimport \"../../interfaces/IWETH.sol\";\n\n/// @title Leverager Contract\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract Leverager is Ownable {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice Ratio Divisor\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t/// @notice Mock ETH address\n\taddress public constant API_ETH_MOCK_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\t/// @notice Lending Pool address\n\tILendingPool public lendingPool;\n\n\t/// @notice EligibilityDataProvider contract address\n\tIEligibilityDataProvider public eligibilityDataProvider;\n\n\t/// @notice LockZap contract address\n\tILockZap public lockZap;\n\n\t/// @notice ChefIncentivesController contract address\n\tIChefIncentivesController public cic;\n\n\t/// @notice Wrapped ETH contract address\n\tIWETH public weth;\n\n\t/// @notice Aave oracle address\n\tIAaveOracle public aaveOracle;\n\n\t/// @notice Fee ratio\n\tuint256 public feePercent;\n\n\t/// @notice Treasury address\n\taddress public treasury;\n\n\t/// @notice Emitted when fee ratio is updated\n\tevent FeePercentUpdated(uint256 _feePercent);\n\n\t/// @notice Emitted when treasury is updated\n\tevent TreasuryUpdated(address indexed _treasury);\n\n\t/**\n\t * @notice Constructor\n\t * @param _lendingPool Address of lending pool.\n\t * @param _rewardEligibleDataProvider EligibilityProvider address.\n\t * @param _aaveOracle address.\n\t * @param _lockZap address.\n\t * @param _weth WETH address.\n\t * @param _feePercent leveraging fee ratio.\n\t * @param _treasury address.\n\t */\n\tconstructor(\n\t\tILendingPool _lendingPool,\n\t\tIEligibilityDataProvider _rewardEligibleDataProvider,\n\t\tIAaveOracle _aaveOracle,\n\t\tILockZap _lockZap,\n\t\tIChefIncentivesController _cic,\n\t\tIWETH _weth,\n\t\tuint256 _feePercent,\n\t\taddress _treasury\n\t) {\n\t\trequire(address(_lendingPool) != (address(0)), \"Not a valid address\");\n\t\trequire(address(_rewardEligibleDataProvider) != (address(0)), \"Not a valid address\");\n\t\trequire(address(_aaveOracle) != (address(0)), \"Not a valid address\");\n\t\trequire(address(_lockZap) != (address(0)), \"Not a valid address\");\n\t\trequire(address(_cic) != (address(0)), \"Not a valid address\");\n\t\trequire(address(_weth) != (address(0)), \"Not a valid address\");\n\t\trequire(_treasury != address(0), \"Not a valid address\");\n\t\trequire(_feePercent <= 1e4, \"Invalid ratio\");\n\n\t\tlendingPool = _lendingPool;\n\t\teligibilityDataProvider = _rewardEligibleDataProvider;\n\t\tlockZap = _lockZap;\n\t\taaveOracle = _aaveOracle;\n\t\tcic = _cic;\n\t\tweth = _weth;\n\t\tfeePercent = _feePercent;\n\t\ttreasury = _treasury;\n\t}\n\n\t/**\n\t * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n\t */\n\treceive() external payable {\n\t\trequire(msg.sender == address(weth), \"Receive not allowed\");\n\t}\n\n\t/**\n\t * @dev Revert fallback calls\n\t */\n\tfallback() external payable {\n\t\trevert(\"Fallback not allowed\");\n\t}\n\n\t/**\n\t * @notice Sets fee ratio\n\t * @param _feePercent fee ratio.\n\t */\n\tfunction setFeePercent(uint256 _feePercent) external onlyOwner {\n\t\trequire(_feePercent <= 1e4, \"Invalid ratio\");\n\t\tfeePercent = _feePercent;\n\t\temit FeePercentUpdated(_feePercent);\n\t}\n\n\t/**\n\t * @notice Sets fee ratio\n\t * @param _treasury address\n\t */\n\tfunction setTreasury(address _treasury) external onlyOwner {\n\t\trequire(_treasury != address(0), \"treasury is 0 address\");\n\t\ttreasury = _treasury;\n\t\temit TreasuryUpdated(_treasury);\n\t}\n\n\t/**\n\t * @dev Returns the configuration of the reserve\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return The configuration of the reserve\n\t **/\n\tfunction getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory) {\n\t\treturn lendingPool.getConfiguration(asset);\n\t}\n\n\t/**\n\t * @dev Returns variable debt token address of asset\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return varaiableDebtToken address of the asset\n\t **/\n\tfunction getVDebtToken(address asset) public view returns (address) {\n\t\tDataTypes.ReserveData memory reserveData = lendingPool.getReserveData(asset);\n\t\treturn reserveData.variableDebtTokenAddress;\n\t}\n\n\t/**\n\t * @dev Returns loan to value\n\t * @param asset The address of the underlying asset of the reserve\n\t * @return ltv of the asset\n\t **/\n\tfunction ltv(address asset) public view returns (uint256) {\n\t\tDataTypes.ReserveConfigurationMap memory conf = lendingPool.getConfiguration(asset);\n\t\treturn conf.data % (2 ** 16);\n\t}\n\n\t/**\n\t * @dev Loop the deposit and borrow of an asset\n\t * @param asset for loop\n\t * @param amount for the initial deposit\n\t * @param interestRateMode stable or variable borrow mode\n\t * @param borrowRatio Ratio of tokens to borrow\n\t * @param loopCount Repeat count for loop\n\t * @param isBorrow true when the loop without deposit tokens\n\t **/\n\tfunction loop(\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 interestRateMode,\n\t\tuint256 borrowRatio,\n\t\tuint256 loopCount,\n\t\tbool isBorrow\n\t) external {\n\t\trequire(borrowRatio <= RATIO_DIVISOR, \"Invalid ratio\");\n\t\tuint16 referralCode = 0;\n\t\tuint256 fee;\n\t\tif (!isBorrow) {\n\t\t\tIERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\n\t\t\tfee = amount.mul(feePercent).div(RATIO_DIVISOR);\n\t\t\tIERC20(asset).safeTransfer(treasury, fee);\n\t\t\tamount = amount.sub(fee);\n\t\t}\n\t\tif (IERC20(asset).allowance(address(this), address(lendingPool)) == 0) {\n\t\t\tIERC20(asset).safeApprove(address(lendingPool), type(uint256).max);\n\t\t}\n\t\tif (IERC20(asset).allowance(address(this), address(treasury)) == 0) {\n\t\t\tIERC20(asset).safeApprove(treasury, type(uint256).max);\n\t\t}\n\n\t\tif (!isBorrow) {\n\t\t\tlendingPool.deposit(asset, amount, msg.sender, referralCode);\n\t\t}\n\n\t\tcic.setEligibilityExempt(msg.sender, true);\n\n\t\tfor (uint256 i = 0; i < loopCount; i += 1) {\n\t\t\tamount = amount.mul(borrowRatio).div(RATIO_DIVISOR);\n\t\t\tlendingPool.borrow(asset, amount, interestRateMode, referralCode, msg.sender);\n\n\t\t\tfee = amount.mul(feePercent).div(RATIO_DIVISOR);\n\t\t\tIERC20(asset).safeTransfer(treasury, fee);\n\t\t\tlendingPool.deposit(asset, amount.sub(fee), msg.sender, referralCode);\n\t\t}\n\n\t\tcic.setEligibilityExempt(msg.sender, false);\n\n\t\tzapWETHWithBorrow(wethToZap(msg.sender), msg.sender);\n\t}\n\n\t/**\n\t * @dev Loop the deposit and borrow of ETH\n\t * @param interestRateMode stable or variable borrow mode\n\t * @param borrowRatio Ratio of tokens to borrow\n\t * @param loopCount Repeat count for loop\n\t **/\n\tfunction loopETH(uint256 interestRateMode, uint256 borrowRatio, uint256 loopCount) external payable {\n\t\trequire(borrowRatio <= RATIO_DIVISOR, \"Invalid ratio\");\n\t\tuint16 referralCode = 0;\n\t\tuint256 amount = msg.value;\n\t\tif (IERC20(address(weth)).allowance(address(this), address(lendingPool)) == 0) {\n\t\t\tIERC20(address(weth)).safeApprove(address(lendingPool), type(uint256).max);\n\t\t}\n\t\tif (IERC20(address(weth)).allowance(address(this), address(treasury)) == 0) {\n\t\t\tIERC20(address(weth)).safeApprove(treasury, type(uint256).max);\n\t\t}\n\n\t\tuint256 fee = amount.mul(feePercent).div(RATIO_DIVISOR);\n\t\t_safeTransferETH(treasury, fee);\n\n\t\tamount = amount.sub(fee);\n\n\t\tweth.deposit{value: amount}();\n\t\tlendingPool.deposit(address(weth), amount, msg.sender, referralCode);\n\n\t\tfor (uint256 i = 0; i < loopCount; i += 1) {\n\t\t\tamount = amount.mul(borrowRatio).div(RATIO_DIVISOR);\n\t\t\tlendingPool.borrow(address(weth), amount, interestRateMode, referralCode, msg.sender);\n\t\t\tweth.withdraw(amount);\n\n\t\t\tfee = amount.mul(feePercent).div(RATIO_DIVISOR);\n\t\t\t_safeTransferETH(treasury, fee);\n\n\t\t\tweth.deposit{value: amount.sub(fee)}();\n\t\t\tlendingPool.deposit(address(weth), amount.sub(fee), msg.sender, referralCode);\n\t\t}\n\n\t\tzapWETHWithBorrow(wethToZap(msg.sender), msg.sender);\n\t}\n\n\t/**\n\t * @notice Return estimated zap WETH amount for eligbility after loop.\n\t * @param user for zap\n\t * @param asset src token\n\t * @param amount of `asset`\n\t * @param borrowRatio Single ratio of borrow\n\t * @param loopCount Repeat count for loop\n\t **/\n\tfunction wethToZapEstimation(\n\t\taddress user,\n\t\taddress asset,\n\t\tuint256 amount,\n\t\tuint256 borrowRatio,\n\t\tuint256 loopCount\n\t) external view returns (uint256) {\n\t\tif (asset == API_ETH_MOCK_ADDRESS) {\n\t\t\tasset = address(weth);\n\t\t}\n\t\tuint256 required = eligibilityDataProvider.requiredUsdValue(user);\n\t\tuint256 locked = eligibilityDataProvider.lockedUsdValue(user);\n\n\t\tuint256 fee = amount.mul(feePercent).div(RATIO_DIVISOR);\n\t\tamount = amount.sub(fee);\n\n\t\trequired = required.add(requiredLocked(asset, amount));\n\n\t\tfor (uint256 i = 0; i < loopCount; i += 1) {\n\t\t\tamount = amount.mul(borrowRatio).div(RATIO_DIVISOR);\n\t\t\tfee = amount.mul(feePercent).div(RATIO_DIVISOR);\n\t\t\trequired = required.add(requiredLocked(asset, amount.sub(fee)));\n\t\t}\n\n\t\tif (locked >= required) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tuint256 deltaUsdValue = required.sub(locked); //decimals === 8\n\t\t\tuint256 wethPrice = aaveOracle.getAssetPrice(address(weth));\n\t\t\tuint8 priceDecimal = IChainlinkAggregator(aaveOracle.getSourceOfAsset(address(weth))).decimals();\n\t\t\tuint256 wethAmount = deltaUsdValue.mul(10 ** 18).mul(10 ** priceDecimal).div(wethPrice).div(10 ** 8);\n\t\t\twethAmount = wethAmount.add(wethAmount.mul(6).div(100));\n\t\t\treturn wethAmount;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Return estimated zap WETH amount for eligbility.\n\t * @param user for zap\n\t **/\n\tfunction wethToZap(address user) public view returns (uint256) {\n\t\tuint256 required = eligibilityDataProvider.requiredUsdValue(user);\n\t\tuint256 locked = eligibilityDataProvider.lockedUsdValue(user);\n\t\tif (locked >= required) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tuint256 deltaUsdValue = required.sub(locked); //decimals === 8\n\t\t\tuint256 wethPrice = aaveOracle.getAssetPrice(address(weth));\n\t\t\tuint8 priceDecimal = IChainlinkAggregator(aaveOracle.getSourceOfAsset(address(weth))).decimals();\n\t\t\tuint256 wethAmount = deltaUsdValue.mul(10 ** 18).mul(10 ** priceDecimal).div(wethPrice).div(10 ** 8);\n\t\t\twethAmount = wethAmount.add(wethAmount.mul(6).div(100));\n\t\t\treturn wethAmount;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Zap WETH by borrowing.\n\t * @param amount to zap\n\t * @param borrower to zap\n\t * @return liquidity amount by zapping\n\t **/\n\tfunction zapWETHWithBorrow(uint256 amount, address borrower) public returns (uint256 liquidity) {\n\t\trequire(msg.sender == borrower || msg.sender == address(lendingPool), \"!borrower||lendingpool\");\n\n\t\tif (amount > 0) {\n\t\t\tuint16 referralCode = 0;\n\t\t\tlendingPool.borrow(address(weth), amount, 2, referralCode, borrower);\n\t\t\tif (IERC20(address(weth)).allowance(address(this), address(lockZap)) == 0) {\n\t\t\t\tIERC20(address(weth)).safeApprove(address(lockZap), type(uint256).max);\n\t\t\t}\n\t\t\tliquidity = lockZap.zapOnBehalf(false, amount, 0, borrower);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns required LP lock amount.\n\t * @param asset underlyig asset\n\t * @param amount of tokens\n\t **/\n\tfunction requiredLocked(address asset, uint256 amount) internal view returns (uint256) {\n\t\tuint256 assetPrice = aaveOracle.getAssetPrice(asset);\n\t\tuint8 assetDecimal = IERC20Metadata(asset).decimals();\n\t\tuint256 requiredVal = assetPrice\n\t\t\t.mul(amount)\n\t\t\t.div(10 ** assetDecimal)\n\t\t\t.mul(eligibilityDataProvider.requiredDepositRatio())\n\t\t\t.div(eligibilityDataProvider.RATIO_DIVISOR());\n\t\treturn requiredVal;\n\t}\n\n\t/**\n\t * @dev transfer ETH to an address, revert if it fails.\n\t * @param to recipient of the transfer\n\t * @param value the amount to send\n\t */\n\tfunction _safeTransferETH(address to, uint256 value) internal {\n\t\t(bool success, ) = to.call{value: value}(new bytes(0));\n\t\trequire(success, \"ETH_TRANSFER_FAILED\");\n\t}\n}\n"
    },
    "contracts/radiant/accessories/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.12;\npragma abicoder v2;\n\n/// @title Multicall - Aggregate results from multiple read-only function calls\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\ncontract Multicall {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        returnData = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n            require(success);\n            returnData[i] = ret;\n        }\n    }\n\n    // Helper functions\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        blockHash = blockhash(block.number - 1);\n    }\n\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n        difficulty = block.difficulty;\n    }\n\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n}\n"
    },
    "contracts/radiant/accessories/StargateBorrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../interfaces/IStargateRouter.sol\";\nimport \"../../interfaces/IRouterETH.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\n\n/*\n    Chain Ids\n        Ethereum: 101\n        BSC: 102\n        Avalanche: 106\n        Polygon: 109\n        Arbitrum: 110\n        Optimism: 111\n        Fantom: 112\n        Swimmer: 114\n        DFK: 115\n        Harmony: 116\n        Moonbeam: 126\n\n    Pool Ids\n        Ethereum\n            USDC: 1\n            USDT: 2\n            ETH: 13\n        BSC\n            USDT: 2\n            BUSD: 5\n        Avalanche\n            USDC: 1\n            USDT: 2\n        Polygon\n            USDC: 1\n            USDT: 2\n        Arbitrum\n            USDC: 1\n            USDT: 2\n            ETH: 13\n        Optimism\n            USDC: 1\n            ETH: 13\n        Fantom\n            USDC: 1\n */\n\n/// @title Borrow gate via stargate\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract StargateBorrow is OwnableUpgradeable {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice FEE ratio DIVISOR\n\tuint256 public constant FEE_PERCENT_DIVISOR = 10000;\n\n\t// ETH pool Id\n\tuint256 private constant POOL_ID_ETH = 13;\n\n\t// ETH address\n\taddress private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n\t/// @notice Stargate Router\n\tIStargateRouter public router;\n\n\t/// @notice Stargate Router ETH\n\tIRouterETH public routerETH;\n\n\t/// @notice Lending Pool address\n\tILendingPool public lendingPool;\n\n\t// Weth address\n\tIWETH internal weth;\n\n\t/// @notice asset => poolId; at the moment, pool IDs for USDC and USDT are the same accross all chains\n\tmapping(address => uint256) public poolIdPerChain;\n\n\t/// @notice DAO wallet\n\taddress public daoTreasury;\n\n\t/// @notice Cross chain borrow fee ratio\n\tuint256 public xChainBorrowFeePercent;\n\n\t/// @notice Emitted when DAO address is updated\n\tevent DAOTreasuryUpdated(address indexed _daoTreasury);\n\n\t/// @notice Emitted when fee info is updated\n\tevent XChainBorrowFeePercentUpdated(uint256 percent);\n\n\t/// @notice Emited when pool ids of assets are updated\n\tevent PoolIDsUpdated(address[] assets, uint256[] poolIDs);\n\n\t/**\n\t * @notice Constructor\n\t * @param _router Stargate Router address\n\t * @param _routerETH Stargate Router for ETH\n\t * @param _lendingPool Lending pool\n\t * @param _weth WETH address\n\t * @param _treasury Treasury address\n\t * @param _xChainBorrowFeePercent Cross chain borrow fee ratio\n\t */\n\tfunction initialize(\n\t\tIStargateRouter _router,\n\t\tIRouterETH _routerETH,\n\t\tILendingPool _lendingPool,\n\t\tIWETH _weth,\n\t\taddress _treasury,\n\t\tuint256 _xChainBorrowFeePercent\n\t) public initializer {\n\t\trequire(address(_router) != (address(0)), \"Not a valid address\");\n\t\trequire(address(_lendingPool) != (address(0)), \"Not a valid address\");\n\t\trequire(address(_weth) != (address(0)), \"Not a valid address\");\n\t\trequire(_treasury != address(0), \"Not a valid address\");\n\t\trequire(_xChainBorrowFeePercent <= uint256(1e4), \"Not a valid number\");\n\n\t\trouter = _router;\n\t\trouterETH = _routerETH;\n\t\tlendingPool = _lendingPool;\n\t\tdaoTreasury = _treasury;\n\t\txChainBorrowFeePercent = _xChainBorrowFeePercent;\n\t\tweth = _weth;\n\t\t__Ownable_init();\n\t}\n\n\treceive() external payable {}\n\n\t/**\n\t * @notice Set DAO Treasury.\n\t * @param _daoTreasury DAO Treasury address.\n\t */\n\tfunction setDAOTreasury(address _daoTreasury) external onlyOwner {\n\t\trequire(_daoTreasury != address(0), \"daoTreasury is 0 address\");\n\t\tdaoTreasury = _daoTreasury;\n\t\temit DAOTreasuryUpdated(_daoTreasury);\n\t}\n\n\t/**\n\t * @notice Set Cross Chain Borrow Fee Percent.\n\t * @param percent Fee ratio.\n\t */\n\tfunction setXChainBorrowFeePercent(uint256 percent) external onlyOwner {\n\t\trequire(percent <= 1e4, \"Invalid ratio\");\n\t\txChainBorrowFeePercent = percent;\n\t\temit XChainBorrowFeePercentUpdated(percent);\n\t}\n\n\t/**\n\t * @notice Set pool ids of assets.\n\t * @param assets array.\n\t * @param poolIDs array.\n\t */\n\tfunction setPoolIDs(address[] memory assets, uint256[] memory poolIDs) external onlyOwner {\n\t\trequire(assets.length == poolIDs.length, \"length mismatch\");\n\t\tfor (uint256 i = 0; i < assets.length; i += 1) {\n\t\t\tpoolIdPerChain[assets[i]] = poolIDs[i];\n\t\t}\n\t\temit PoolIDsUpdated(assets, poolIDs);\n\t}\n\n\t/**\n\t * @notice Get Cross Chain Borrow Fee amount.\n\t * @param amount Fee cost.\n\t */\n\tfunction getXChainBorrowFeeAmount(uint256 amount) public view returns (uint256) {\n\t\tuint256 feeAmount = amount.mul(xChainBorrowFeePercent).div(FEE_PERCENT_DIVISOR);\n\t\treturn feeAmount;\n\t}\n\n\t/**\n\t * @notice Quote LZ swap fee\n\t * @dev Call Router.sol method to get the value for swap()\n\t */\n\tfunction quoteLayerZeroSwapFee(\n\t\tuint16 _dstChainId,\n\t\tuint8 _functionType,\n\t\tbytes calldata _toAddress,\n\t\tbytes calldata _transferAndCallPayload,\n\t\tIStargateRouter.lzTxObj memory _lzTxParams\n\t) external view returns (uint256, uint256) {\n\t\treturn router.quoteLayerZeroFee(_dstChainId, _functionType, _toAddress, _transferAndCallPayload, _lzTxParams);\n\t}\n\n\t/**\n\t * @dev Loop the deposit and borrow of an asset\n\t * @param asset for loop\n\t * @param amount for the initial deposit\n\t * @param interestRateMode stable or variable borrow mode\n\t * @param dstChainId Destination chain id\n\t **/\n\tfunction borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 dstChainId) external payable {\n\t\tif (address(asset) == ETH_ADDRESS && address(routerETH) != address(0)) {\n\t\t\tborrowETH(amount, interestRateMode, dstChainId);\n\t\t} else {\n\t\t\tlendingPool.borrow(asset, amount, interestRateMode, 0, msg.sender);\n\t\t\tuint256 feeAmount = getXChainBorrowFeeAmount(amount);\n\t\t\tIERC20(asset).safeTransfer(daoTreasury, feeAmount);\n\t\t\tamount = amount.sub(feeAmount);\n\t\t\tIERC20(asset).safeApprove(address(router), 0);\n\t\t\tIERC20(asset).safeApprove(address(router), amount);\n\t\t\trouter.swap{value: msg.value}(\n\t\t\t\tdstChainId, // dest chain id\n\t\t\t\tpoolIdPerChain[asset], // src chain pool id\n\t\t\t\tpoolIdPerChain[asset], // dst chain pool id\n\t\t\t\tpayable(msg.sender), // receive address\n\t\t\t\tamount, // transfer amount\n\t\t\t\tamount.mul(99).div(100), // max slippage: 1%\n\t\t\t\tIStargateRouter.lzTxObj(0, 0, \"0x\"),\n\t\t\t\tabi.encodePacked(msg.sender),\n\t\t\t\tbytes(\"\")\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Borrow ETH\n\t * @param amount for the initial deposit\n\t * @param interestRateMode stable or variable borrow mode\n\t * @param dstChainId Destination chain id\n\t **/\n\tfunction borrowETH(uint256 amount, uint256 interestRateMode, uint16 dstChainId) internal {\n\t\tlendingPool.borrow(address(weth), amount, interestRateMode, 0, msg.sender);\n\t\tweth.withdraw(amount);\n\t\tuint256 feeAmount = getXChainBorrowFeeAmount(amount);\n\t\t_safeTransferETH(daoTreasury, feeAmount);\n\t\tamount = amount.sub(feeAmount);\n\n\t\trouterETH.swapETH{value: amount.add(msg.value)}(\n\t\t\tdstChainId, // dest chain id\n\t\t\tpayable(msg.sender), // receive address\n\t\t\tabi.encodePacked(msg.sender),\n\t\t\tamount, // transfer amount\n\t\t\tamount.mul(99).div(100) // max slippage: 1%\n\t\t);\n\t}\n\n\t/**\n\t * @dev transfer ETH to an address, revert if it fails.\n\t * @param to recipient of the transfer\n\t * @param value the amount to send\n\t */\n\tfunction _safeTransferETH(address to, uint256 value) internal {\n\t\t(bool success, ) = to.call{value: value}(new bytes(0));\n\t\trequire(success, \"ETH_TRANSFER_FAILED\");\n\t}\n}\n"
    },
    "contracts/radiant/eligibility/BountyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/ILockZap.sol\";\nimport \"../../interfaces/IChefIncentivesController.sol\";\nimport \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/IPriceProvider.sol\";\nimport \"../../interfaces/IEligibilityDataProvider.sol\";\nimport \"../../interfaces/ICompounder.sol\";\n\ncontract BountyManager is Initializable, OwnableUpgradeable, PausableUpgradeable {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\taddress public rdnt;\n\taddress public weth;\n\taddress public mfd;\n\taddress public chef;\n\taddress public priceProvider;\n\taddress public eligibilityDataProvider;\n\taddress public compounder;\n\tuint256 public hunterShare;\n\tuint256 public baseBountyUsdTarget; // decimals 18\n\tuint256 public maxBaseBounty;\n\tuint256 public bountyBooster;\n\tuint256 public bountyCount;\n\tuint256 public minStakeAmount;\n\tuint256 public slippageLimit;\n\n\t// Array of available Bounty functions to run. See getMfdBounty, getChefBounty, etc.\n\tmapping(uint256 => function(address, bool) returns (address, uint256, bool)) private bounties;\n\n\tmapping(address => bool) public whitelist;\n\tbool public whitelistActive;\n\n\tmodifier isWhitelisted() {\n\t\tif (whitelistActive) {\n\t\t\trequire(whitelist[msg.sender] || msg.sender == address(this), \"!whiteliested\");\n\t\t}\n\t\t_;\n\t}\n\n\tevent Disqualified(address user);\n\tevent ChefIncentivesControllerUpdated(IChefIncentivesController _chef);\n\tevent BaseBountyUsdTargetUpdated(uint256 _newVal);\n\tevent HunterShareUpdated(uint256 _newVal);\n\tevent MaxBaseBountyUpdated(uint256 _newVal);\n\tevent BountyBoosterUpdated(uint256 _newVal);\n\tevent SlippageLimitUpdated(uint256 _newVal);\n\tevent BountyReserveEmpty(uint256 _bal);\n\tevent WhitelistActiveChanged(bool isActive);\n\n\t/**\n\t * @notice Initialize\n\t * @param _rdnt RDNT address\n\t * @param _weth WETH address\n\t * @param _mfd MFD, to send bounties as vesting RDNT to Hunter (user calling bounty)\n\t * @param _chef CIC, to query bounties for ineligible emissions\n\t * @param _priceProvider PriceProvider service, to get RDNT price for bounty quotes\n\t * @param _hunterShare % of reclaimed rewards to send to Hunter\n\t * @param _baseBountyUsdTarget Base Bounty is paid in RDNT, will scale to match this USD target value\n\t * @param _maxBaseBounty cap the scaling above\n\t * @param _bountyBooster when bounties need boosting to clear queue, add this amount (in RDNT)\n\t */\n\tfunction initialize(\n\t\taddress _rdnt,\n\t\taddress _weth,\n\t\taddress _mfd,\n\t\taddress _chef,\n\t\taddress _priceProvider,\n\t\taddress _eligibilityDataProvider,\n\t\taddress _compounder,\n\t\tuint256 _hunterShare,\n\t\tuint256 _baseBountyUsdTarget,\n\t\tuint256 _maxBaseBounty,\n\t\tuint256 _bountyBooster\n\t) external initializer {\n\t\trequire(_rdnt != address(0), \"Not a valid address\");\n\t\trequire(_weth != address(0), \"Not a valid address\");\n\t\trequire(_mfd != address(0), \"Not a valid address\");\n\t\trequire(_chef != address(0), \"Not a valid address\");\n\t\trequire(_priceProvider != address(0), \"Not a valid address\");\n\t\trequire(_eligibilityDataProvider != address(0), \"Not a valid address\");\n\t\trequire(_compounder != address(0), \"Not a valid address\");\n\t\trequire(_hunterShare <= 10000, \"Not a valid number\");\n\t\trequire(_baseBountyUsdTarget != 0, \"Not a valid number\");\n\t\trequire(_maxBaseBounty != 0, \"Not a valid number\");\n\n\t\trdnt = _rdnt;\n\t\tweth = _weth;\n\t\tmfd = _mfd;\n\t\tchef = _chef;\n\t\tpriceProvider = _priceProvider;\n\t\teligibilityDataProvider = _eligibilityDataProvider;\n\t\tcompounder = _compounder;\n\n\t\thunterShare = _hunterShare;\n\t\tbaseBountyUsdTarget = _baseBountyUsdTarget;\n\t\tbountyBooster = _bountyBooster;\n\t\tmaxBaseBounty = _maxBaseBounty;\n\n\t\tbounties[1] = getMfdBounty;\n\t\tbounties[2] = getChefBounty;\n\t\tbounties[3] = getAutoCompoundBounty;\n\t\tbountyCount = 3;\n\n\t\t__Ownable_init();\n\t\t__Pausable_init();\n\t}\n\n\t/**\n\t * @notice Given a user, return their bounty amount. uses staticcall to run same bounty aglo, but without execution\n\t * @param _user address\n\t * @return bounty amount of RDNT Hunter will recieve.\n\t * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n\t * @return actionType which of the 3 bounty types (above) to run.\n\t * getBestBounty returns this based on priority (expired locks first, then inelig emissions, then autocompound)\n\t */\n\tfunction quote(address _user) public view whenNotPaused returns (uint256 bounty, uint256 actionType) {\n\t\t(bool success, bytes memory data) = address(this).staticcall(\n\t\t\tabi.encodeWithSignature(\"executeBounty(address,bool,uint256)\", _user, false, 0)\n\t\t);\n\t\trequire(success, \"quote fail\");\n\n\t\t(bounty, actionType) = abi.decode(data, (uint256, uint256));\n\t}\n\n\t/**\n\t * @notice Execute a bounty.\n\t * @param _user address\n\t * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n\t * @param _actionType which of the 3 bounty types (above) to run.\n\t * @return bounty in RDNT to be paid to Hunter (via vesting)\n\t * @return actionType which bounty ran\n\t */\n\tfunction claim(\n\t\taddress _user,\n\t\tuint256 _actionType\n\t) public whenNotPaused isWhitelisted returns (uint256 bounty, uint256 actionType) {\n\t\treturn executeBounty(_user, true, _actionType);\n\t}\n\n\t/**\n\t * @notice Execute the most appropriate bounty on a user, check returned amount for slippage, calc amount going to Hunter, send to vesting.\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * can be a fixed amt (Base Bounty) or dynamic amt based on rewards removed from target user during execution (ineligible revenue, autocompound fee)\n\t * @param _actionType which of the 3 bounty types (above) to run.\n\t * @return bounty in RDNT to be paid to Hunter (via vesting)\n\t * @return actionType which bounty ran\n\t */\n\tfunction executeBounty(\n\t\taddress _user,\n\t\tbool _execute,\n\t\tuint256 _actionType\n\t) public whenNotPaused isWhitelisted returns (uint256 bounty, uint256 actionType) {\n\t\tif (_execute && msg.sender != address(this)) {\n\t\t\trequire(_canBountyHunt(msg.sender), \"inelig for bounties\");\n\t\t}\n\n\t\tuint256 totalBounty;\n\t\tbool issueBaseBounty;\n\t\taddress incentivizer;\n\t\tuint256 bb = getBaseBounty();\n\n\t\t(incentivizer, totalBounty, issueBaseBounty, actionType) = getBestBounty(_user, _execute, _actionType);\n\n\t\tif (issueBaseBounty) {\n\t\t\tbounty = bb;\n\t\t} else {\n\t\t\tif (totalBounty != 0) {\n\t\t\t\tbounty = totalBounty.mul(hunterShare).div(10000);\n\t\t\t}\n\t\t}\n\n\t\tif (_execute && bounty != 0) {\n\t\t\tif (!issueBaseBounty) {\n\t\t\t\tIERC20(rdnt).safeTransferFrom(incentivizer, address(this), totalBounty);\n\t\t\t}\n\t\t\t_sendBounty(msg.sender, bounty);\n\t\t}\n\t}\n\n\tfunction _canBountyHunt(address _user) internal view returns (bool) {\n\t\t(, , uint256 lockedLP, , ) = IMFDPlus(mfd).lockedBalances(_user);\n\t\tbool isEmissionsEligible = IEligibilityDataProvider(eligibilityDataProvider).isEligibleForRewards(_user);\n\t\treturn lockedLP >= minDLPBalance() && isEmissionsEligible;\n\t}\n\n\t/**\n\t * @notice Given a user and actionType, execute that bounty on either CIC or MFD.\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * @param _actionTypeIndex, which of the 3 bounty types (above) to run.\n\t * @return incentivizer the contract that had a bounty operation performed for it.\n\t * Either CIC (to remove ineligible user from emission pool, or MFD to remove expired locks)\n\t * @return totalBounty raw amount of RDNT returned from Incentivizer. Hunter % will be deducted from this.\n\t * @return issueBaseBounty whether Incentivizer will pay bounty from its own RDNT reserve, or from this contracts RDNT reserve\n\t * @return actionType the action type index executed\n\t */\n\tfunction getBestBounty(\n\t\taddress _user,\n\t\tbool _execute,\n\t\tuint256 _actionTypeIndex\n\t) internal returns (address incentivizer, uint256 totalBounty, bool issueBaseBounty, uint256 actionType) {\n\t\tif (_actionTypeIndex != 0) {\n\t\t\t// execute bounty w/ given params\n\t\t\t(incentivizer, totalBounty, issueBaseBounty) = bounties[_actionTypeIndex](_user, _execute);\n\t\t\tactionType = _actionTypeIndex;\n\t\t} else {\n\t\t\tfor (uint256 i = 1; i <= bountyCount; i++) {\n\t\t\t\t(incentivizer, totalBounty, issueBaseBounty) = bounties[i](_user, _execute);\n\t\t\t\tif (totalBounty != 0 || issueBaseBounty) {\n\t\t\t\t\tactionType = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice call MFDPlus.claimBounty()\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * @return incentivizer in this case MFD\n\t * @return totalBounty RDNT to pay for this _user's bounty execution\n\t * false when !autorelock because they will have rewards removed from their ineligible time after locks expired\n\t */\n\tfunction getMfdBounty(\n\t\taddress _user,\n\t\tbool _execute\n\t) internal returns (address incentivizer, uint256 totalBounty, bool issueBaseBounty) {\n\t\tissueBaseBounty = IMFDPlus(mfd).claimBounty(_user, _execute);\n\t\tincentivizer = mfd;\n\t}\n\n\t/**\n\t * @notice call CIC.claimBounty()\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * @return incentivizer in this case CIC\n\t * @return totalBounty RDNT to pay for this _user's bounty execution\n\t * false when !autorelock because they will have rewards removed from their ineligible time after locks expired\n\t */\n\tfunction getChefBounty(\n\t\taddress _user,\n\t\tbool _execute\n\t) internal returns (address incentivizer, uint256 totalBounty, bool issueBaseBounty) {\n\t\tissueBaseBounty = IChefIncentivesController(chef).claimBounty(_user, _execute);\n\t\tincentivizer = chef;\n\t}\n\n\t/**\n\t * @notice call MFDPlus.claimCompound(). compound pending rewards for _user into locked LP\n\t * @param _user address\n\t * @param _execute whether to execute this txn, or just quote what its execution would return\n\t * @return incentivizer in this case MFDPlus\n\t * @return totalBounty RDNT to pay for this _user's bounty execution. paid from Autocompound fee\n\t */\n\tfunction getAutoCompoundBounty(\n\t\taddress _user,\n\t\tbool _execute\n\t) internal returns (address incentivizer, uint256 totalBounty, bool issueBaseBounty) {\n\t\t(totalBounty) = ICompounder(compounder).claimCompound(_user, _execute);\n\t\tissueBaseBounty = false;\n\t\tincentivizer = compounder;\n\t}\n\n\t/**\n\t * @notice Vest a bounty in MFD for successful bounty by Hunter\n\t * @param _to Hunter address\n\t * @param _amount of RDNT\n\t * @return amt added to vesting\n\t */\n\tfunction _sendBounty(address _to, uint256 _amount) internal returns (uint256) {\n\t\tif (_amount == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 bountyReserve = IERC20(rdnt).balanceOf(address(this));\n\t\tif (_amount > bountyReserve) {\n\t\t\tIERC20(rdnt).safeTransfer(address(mfd), bountyReserve);\n\t\t\tIMFDPlus(mfd).mint(_to, bountyReserve, true);\n\t\t\temit BountyReserveEmpty(bountyReserve);\n\t\t\t_pause();\n\t\t\treturn bountyReserve;\n\t\t} else {\n\t\t\tIERC20(rdnt).safeTransfer(address(mfd), _amount);\n\t\t\tIMFDPlus(mfd).mint(_to, _amount, true);\n\t\t\treturn _amount;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Return RDNT amount for Base Bounty.\n\t * Base Bounty used to incentivize operations that dont generate their own reward to pay to Hunter.\n\t * @return bounty in RDNT\n\t */\n\tfunction getBaseBounty() public view whenNotPaused returns (uint256 bounty) {\n\t\tuint256 rdntPrice = IPriceProvider(priceProvider).getTokenPriceUsd();\n\t\tbounty = baseBountyUsdTarget.mul(1e8).div(rdntPrice);\n\t\tif (bounty > maxBaseBounty) {\n\t\t\tbounty = maxBaseBounty;\n\t\t}\n\t}\n\n\tfunction minDLPBalance() public view returns (uint256 min) {\n\t\tuint256 lpTokenPrice = IPriceProvider(priceProvider).getLpTokenPriceUsd();\n\t\tmin = minStakeAmount.mul(1e8).div(lpTokenPrice);\n\t}\n\n\tfunction setMinStakeAmount(uint256 _minStakeAmount) external onlyOwner {\n\t\tminStakeAmount = _minStakeAmount;\n\t}\n\n\tfunction setBaseBountyUsdTarget(uint256 _newVal) external onlyOwner {\n\t\tbaseBountyUsdTarget = _newVal;\n\t\temit BaseBountyUsdTargetUpdated(_newVal);\n\t}\n\n\tfunction setHunterShare(uint256 _newVal) external onlyOwner {\n\t\trequire(_newVal <= 10000, \"override\");\n\t\thunterShare = _newVal;\n\t\temit HunterShareUpdated(_newVal);\n\t}\n\n\tfunction setMaxBaseBounty(uint256 _newVal) external onlyOwner {\n\t\tmaxBaseBounty = _newVal;\n\t\temit MaxBaseBountyUpdated(_newVal);\n\t}\n\n\tfunction setBountyBooster(uint256 _newVal) external onlyOwner {\n\t\tbountyBooster = _newVal;\n\t\temit BountyBoosterUpdated(_newVal);\n\t}\n\n\tfunction setSlippageLimit(uint256 _newVal) external onlyOwner {\n\t\trequire(_newVal <= 10000, \"Invalid slippage limit\");\n\t\tslippageLimit = _newVal;\n\t\temit SlippageLimitUpdated(_newVal);\n\t}\n\n\tfunction setBounties() external onlyOwner {\n\t\tbounties[1] = getMfdBounty;\n\t\tbounties[2] = getChefBounty;\n\t\tbounties[3] = getAutoCompoundBounty;\n\t}\n\n\tfunction recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\t\tIERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n\t}\n\n\tfunction addAddressToWL(address user, bool status) external onlyOwner {\n\t\twhitelist[user] = status;\n\t}\n\n\tfunction changeWL(bool status) external onlyOwner {\n\t\twhitelistActive = status;\n\t\temit WhitelistActiveChanged(status);\n\t}\n\n\tfunction pause() public onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction unpause() public onlyOwner {\n\t\t_unpause();\n\t}\n}\n"
    },
    "contracts/radiant/eligibility/EligibilityDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/IChefIncentivesController.sol\";\nimport \"../../interfaces/IPriceProvider.sol\";\nimport \"../../interfaces/IMiddleFeeDistribution.sol\";\nimport \"../../interfaces/LockedBalance.sol\";\nimport \"../../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport \"../../interfaces/uniswap/IUniswapV2Factory.sol\";\nimport \"../../interfaces/uniswap/IUniswapV2Pair.sol\";\nimport \"../../interfaces/IChainlinkAggregator.sol\";\n\n/// @title Eligible Deposit Provider\n/// @author Radiant Labs\n/// @dev All function calls are currently implemented without side effects\ncontract EligibilityDataProvider is OwnableUpgradeable {\n\tusing SafeMath for uint256;\n\n\t/********************** Common Info ***********************/\n\n\t/// @notice RATIO BASE equal to 100%\n\tuint256 public constant RATIO_DIVISOR = 10000;\n\n\t/// @notice Address of Lending Pool\n\tILendingPool public lendingPool;\n\n\t/// @notice Address of CIC\n\tIChefIncentivesController public chef;\n\n\t/// @notice Address of Middle fee distribution\n\tIMiddleFeeDistribution public middleFeeDistribution;\n\n\t/// @notice RDNT + LP price provider\n\tIPriceProvider public priceProvider;\n\n\t/// @notice Required ratio of TVL to get reward; in bips\n\tuint256 public requiredDepositRatio;\n\n\t/// @notice Ratio of the required price to still allow without disqualification; in bips\n\tuint256 public priceToleranceRatio;\n\n\t/// @notice RDNT-ETH LP token\n\taddress public lpToken;\n\n\t/********************** Eligible info ***********************/\n\n\t/// @notice Last eligible status of the user\n\tmapping(address => bool) public lastEligibleStatus;\n\n\t/// @notice Disqualified time of the user\n\tmapping(address => uint256) public disqualifiedTime;\n\n\t// Elgible deposits per rToken\n\tmapping(address => uint256) private eligibleDeposits;\n\n\t/// @notice User's deposits per rToken; rToken => user => amount\n\tmapping(address => mapping(address => uint256)) public userDeposits;\n\n\t/********************** Events ***********************/\n\n\t/// @notice Emitted when CIC is set\n\tevent ChefIncentivesControllerUpdated(IChefIncentivesController _chef);\n\n\t/// @notice Emitted when LP token is set\n\tevent LPTokenUpdated(address _lpToken);\n\n\t/// @notice Emitted when required TVL ratio is updated\n\tevent RequiredDepositRatioUpdated(uint256 requiredDepositRatio);\n\n\t/// @notice Emitted when price tolerance ratio is updated\n\tevent PriceToleranceRatioUpdated(uint256 priceToleranceRatio);\n\n\t/// @notice Emitted when DQ time is set\n\tevent DqTimeUpdated(address _user, uint256 _time);\n\n\t/// @notice Emitted when a new token is added\n\tevent AddToken(address indexed token);\n\n\t/**\n\t * @notice Constructor\n\t * @param _lendingPool Address of lending pool.\n\t * @param _middleFeeDistribution MiddleFeeDistribution address.\n\t * @param _priceProvider PriceProvider address.\n\t */\n\tfunction initialize(\n\t\tILendingPool _lendingPool,\n\t\tIMiddleFeeDistribution _middleFeeDistribution,\n\t\tIPriceProvider _priceProvider\n\t) public initializer {\n\t\trequire(address(_lendingPool) != address(0), \"Not a valid address\");\n\t\trequire(address(_middleFeeDistribution) != (address(0)), \"Not a valid address\");\n\t\trequire(address(_priceProvider) != (address(0)), \"Not a valid address\");\n\n\t\tlendingPool = _lendingPool;\n\t\tmiddleFeeDistribution = _middleFeeDistribution;\n\t\tpriceProvider = _priceProvider;\n\t\trequiredDepositRatio = 500;\n\t\tpriceToleranceRatio = 9000;\n\t\t__Ownable_init();\n\t}\n\n\t/********************** Setters ***********************/\n\n\t/**\n\t * @notice Set CIC\n\t * @param _chef address.\n\t */\n\tfunction setChefIncentivesController(IChefIncentivesController _chef) external onlyOwner {\n\t\trequire(address(_chef) != address(0), \"chef is 0 address\");\n\t\tchef = _chef;\n\t\temit ChefIncentivesControllerUpdated(_chef);\n\t}\n\n\t/**\n\t * @notice Set LP token\n\t */\n\tfunction setLPToken(address _lpToken) external onlyOwner {\n\t\trequire(lpToken == address(0), \"LP token already set\");\n\t\tlpToken = _lpToken;\n\n\t\temit LPTokenUpdated(_lpToken);\n\t}\n\n\t/**\n\t * @notice Sets required tvl ratio. Can only be called by the owner.\n\t * @param _requiredDepositRatio Ratio in bips.\n\t */\n\tfunction setRequiredDepositRatio(uint256 _requiredDepositRatio) external onlyOwner {\n\t\trequire(_requiredDepositRatio <= RATIO_DIVISOR, \"Invalid ratio\");\n\t\trequiredDepositRatio = _requiredDepositRatio;\n\n\t\temit RequiredDepositRatioUpdated(_requiredDepositRatio);\n\t}\n\n\t/**\n\t * @notice Sets price tolerance ratio. Can only be called by the owner.\n\t * @param _priceToleranceRatio Ratio in bips.\n\t */\n\tfunction setPriceToleranceRatio(uint256 _priceToleranceRatio) external onlyOwner {\n\t\trequire(_priceToleranceRatio >= 8000 && _priceToleranceRatio <= RATIO_DIVISOR, \"Invalid ratio\");\n\t\tpriceToleranceRatio = _priceToleranceRatio;\n\n\t\temit PriceToleranceRatioUpdated(_priceToleranceRatio);\n\t}\n\n\t/**\n\t * @notice Sets DQ time of the user\n\t * @dev Only callable by CIC\n\t * @param _user's address\n\t * @param _time for DQ\n\t */\n\tfunction setDqTime(address _user, uint256 _time) external {\n\t\trequire(msg.sender == address(chef), \"Only CIC\");\n\t\tdisqualifiedTime[_user] = _time;\n\n\t\temit DqTimeUpdated(_user, _time);\n\t}\n\n\t/********************** View functions ***********************/\n\n\t/**\n\t * @notice Returns locked RDNT and LP token value in eth\n\t * @param user's address\n\t */\n\tfunction lockedUsdValue(address user) public view returns (uint256) {\n\t\tIMultiFeeDistribution multiFeeDistribution = IMultiFeeDistribution(\n\t\t\tmiddleFeeDistribution.getMultiFeeDistributionAddress()\n\t\t);\n\t\t(, , uint256 lockedLP, , ) = multiFeeDistribution.lockedBalances(user);\n\t\treturn _lockedUsdValue(lockedLP);\n\t}\n\n\t/**\n\t * @notice Returns USD value required to be locked\n\t * @param user's address\n\t * @return required USD value.\n\t */\n\tfunction requiredUsdValue(address user) public view returns (uint256 required) {\n\t\t(uint256 totalCollateralUSD, , , , , ) = lendingPool.getUserAccountData(user);\n\t\trequired = totalCollateralUSD.mul(requiredDepositRatio).div(RATIO_DIVISOR);\n\t}\n\n\t/**\n\t * @notice Is user DQed due to lock expire or price update\n\t * @param _user's address\n\t */\n\tfunction isMarketDisqualified(address _user) public view returns (bool) {\n\t\treturn requiredUsdValue(_user) > 0 && !isEligibleForRewards(_user) && lastEligibleTime(_user) > block.timestamp;\n\t}\n\n\t/**\n\t * @notice Returns if the user is eligible to receive rewards\n\t * @param _user's address\n\t */\n\tfunction isEligibleForRewards(address _user) public view returns (bool isEligible) {\n\t\tuint256 lockedValue = lockedUsdValue(_user);\n\t\tuint256 requiredValue = requiredUsdValue(_user).mul(priceToleranceRatio).div(RATIO_DIVISOR);\n\t\treturn requiredValue != 0 && lockedValue >= requiredValue;\n\t}\n\n\t/**\n\t * @notice Returns DQ time of the user\n\t * @param _user's address\n\t */\n\tfunction getDqTime(address _user) public view returns (uint256) {\n\t\treturn disqualifiedTime[_user];\n\t}\n\n\t/**\n\t * @notice Returns last eligible time of the user\n\t * @dev If user is still eligible, it will return future time\n\t *  CAUTION: this function only works perfect when the array\n\t *  is ordered by lock time. This is assured when _stake happens.\n\t * @param user's address\n\t */\n\tfunction lastEligibleTime(address user) public view returns (uint256 lastEligibleTimestamp) {\n\t\tuint256 requiredValue = requiredUsdValue(user);\n\n\t\tIMultiFeeDistribution multiFeeDistribution = IMultiFeeDistribution(\n\t\t\tmiddleFeeDistribution.getMultiFeeDistributionAddress()\n\t\t);\n\t\tLockedBalance[] memory lpLockData = multiFeeDistribution.lockInfo(user);\n\n\t\tuint256 lockedLP;\n\t\tuint256 i = lpLockData.length;\n\t\twhile (i > 0) {\n\t\t\ti = i - 1;\n\t\t\tlastEligibleTimestamp = lpLockData[i].unlockTime;\n\t\t\tlockedLP = lockedLP + lpLockData[i].amount;\n\n\t\t\tif (_lockedUsdValue(lockedLP) >= requiredValue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/********************** Operate functions ***********************/\n\t/**\n\t * @notice Refresh token amount for eligibility\n\t * @param user's address\n\t */\n\tfunction refresh(address user) external {\n\t\trequire(msg.sender == address(chef), \"Can only be called by CIC\");\n\t\tassert(user != address(0));\n\n\t\tbool currentEligble = isEligibleForRewards(user);\n\t\tif (currentEligble && disqualifiedTime[user] != 0) {\n\t\t\tdisqualifiedTime[user] = 0;\n\t\t}\n\t\tlastEligibleStatus[user] = currentEligble;\n\t}\n\n\t/**\n\t * @notice Update token price\n\t */\n\tfunction updatePrice() public {\n\t\tpriceProvider.update();\n\t}\n\n\t/********************** Internal functions ***********************/\n\n\t/**\n\t * @notice Returns locked RDNT and LP token value in eth\n\t * @param lockedLP is locked lp amount\n\t */\n\tfunction _lockedUsdValue(uint256 lockedLP) internal view returns (uint256) {\n\t\tuint256 lpPrice = priceProvider.getLpTokenPriceUsd();\n\t\treturn lockedLP.mul(lpPrice).div(10 ** 18);\n\t}\n}\n"
    },
    "contracts/radiant/libraries/AddressPagination.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nlibrary AddressPagination {\n\tfunction paginate(\n\t\taddress[] memory array,\n\t\tuint256 page,\n\t\tuint256 limit\n\t) internal pure returns (address[] memory result) {\n\t\tresult = new address[](limit);\n\t\tfor (uint256 i = 0; i < limit; i++) {\n\t\t\tif (page * limit + i >= array.length) {\n\t\t\t\tresult[i] = address(0);\n\t\t\t} else {\n\t\t\t\tresult[i] = array[page * limit + i];\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/radiant/libraries/LockerList.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./AddressPagination.sol\";\n\n/// @title Locker List Contract\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract LockerList is Ownable {\n\tusing AddressPagination for address[];\n\n\t// Users list\n\taddress[] internal userlist;\n\tmapping(address => uint256) internal indexOf;\n\tmapping(address => bool) internal inserted;\n\n\t/********************** Events ***********************/\n\n\tevent LockerAdded(address indexed locker);\n\tevent LockerRemoved(address indexed locker);\n\n\t/**\n\t * @dev Constructor\n\t */\n\tconstructor() Ownable() {}\n\n\t/********************** Lockers list ***********************/\n\t/**\n\t * @notice Return the number of users.\n\t */\n\tfunction lockersCount() external view returns (uint256) {\n\t\treturn userlist.length;\n\t}\n\n\t/**\n\t * @notice Return the list of users.\n\t */\n\tfunction getUsers(uint256 page, uint256 limit) external view returns (address[] memory) {\n\t\treturn userlist.paginate(page, limit);\n\t}\n\n\tfunction addToList(address user) external onlyOwner {\n\t\tif (inserted[user] == false) {\n\t\t\tinserted[user] = true;\n\t\t\tindexOf[user] = userlist.length;\n\t\t\tuserlist.push(user);\n\t\t}\n\n\t\temit LockerAdded(user);\n\t}\n\n\tfunction removeFromList(address user) external onlyOwner {\n\t\tassert(inserted[user] == true);\n\n\t\tdelete inserted[user];\n\n\t\tuint256 index = indexOf[user];\n\t\tuint256 lastIndex = userlist.length - 1;\n\t\taddress lastUser = userlist[lastIndex];\n\n\t\tindexOf[lastUser] = index;\n\t\tdelete indexOf[user];\n\n\t\tuserlist[index] = lastUser;\n\t\tuserlist.pop();\n\n\t\temit LockerRemoved(user);\n\t}\n}\n"
    },
    "contracts/radiant/staking/ChefIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/IEligibilityDataProvider.sol\";\nimport \"../../interfaces/ILeverager.sol\";\nimport \"../../interfaces/IOnwardIncentivesController.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/IMiddleFeeDistribution.sol\";\n\n// based on the Sushi MasterChef\n// https://github.com/sushiswap/sushiswap/blob/master/contracts/MasterChef.sol\ncontract ChefIncentivesController is Initializable, PausableUpgradeable, OwnableUpgradeable {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t// Info of each user.\n\t// reward = user.`amount` * pool.`accRewardPerShare` - `rewardDebt`\n\tstruct UserInfo {\n\t\tuint256 amount;\n\t\tuint256 rewardDebt;\n\t\tuint256 lastClaimTime;\n\t}\n\n\t// Info of each pool.\n\tstruct PoolInfo {\n\t\tuint256 totalSupply;\n\t\tuint256 allocPoint; // How many allocation points assigned to this pool.\n\t\tuint256 lastRewardTime; // Last second that reward distribution occurs.\n\t\tuint256 accRewardPerShare; // Accumulated rewards per share, times ACC_REWARD_PRECISION. See below.\n\t\tIOnwardIncentivesController onwardIncentives;\n\t}\n\n\t// Info about token emissions for a given time period.\n\tstruct EmissionPoint {\n\t\tuint128 startTimeOffset;\n\t\tuint128 rewardsPerSecond;\n\t}\n\n\t// Emitted when rewardPerSecond is updated\n\tevent RewardsPerSecondUpdated(uint256 indexed rewardsPerSecond, bool persist);\n\n\tevent BalanceUpdated(address indexed token, address indexed user, uint256 balance, uint256 totalSupply);\n\n\tevent EmissionScheduleAppended(uint256[] startTimeOffsets, uint256[] rewardsPerSeconds);\n\n\tevent ChefReserveLow(uint256 _balance);\n\n\tevent ChefReserveEmpty(uint256 _balance);\n\n\tevent Disqualified(address indexed user);\n\n\t// multiplier for reward calc\n\tuint256 private constant ACC_REWARD_PRECISION = 1e12;\n\n\t// Data about the future reward rates. emissionSchedule stored in chronological order,\n\t// whenever the number of blocks since the start block exceeds the next block offset a new\n\t// reward rate is applied.\n\tEmissionPoint[] public emissionSchedule;\n\n\t// If true, keep this new reward rate indefinitely\n\t// If false, keep this reward rate until the next scheduled block offset, then return to the schedule.\n\tbool public persistRewardsPerSecond;\n\n\t/********************** Emission Info ***********************/\n\n\t// Array of tokens for reward\n\taddress[] public registeredTokens;\n\n\t// Current reward per second\n\tuint256 public rewardsPerSecond;\n\n\t// last RPS, used during refill after reserve empty\n\tuint256 public lastRPS;\n\n\t// Index in emission schedule which the last rewardsPerSeconds was used\n\t// only used for scheduled rewards\n\tuint256 public emissionScheduleIndex;\n\n\t// Info of each pool.\n\tmapping(address => PoolInfo) public poolInfo;\n\tmapping(address => bool) private validRTokens;\n\n\t// Total allocation poitns. Must be the sum of all allocation points in all pools.\n\tuint256 public totalAllocPoint;\n\n\t// token => user => Info of each user that stakes LP tokens.\n\tmapping(address => mapping(address => UserInfo)) public userInfo;\n\n\t// user => base claimable balance\n\tmapping(address => uint256) public userBaseClaimable;\n\n\t// MFD, bounties, AC, middlefee\n\tmapping(address => bool) public eligibilityExempt;\n\n\t// The block number when reward mining starts.\n\tuint256 public startTime;\n\n\tbool public eligibilityEnabled;\n\n\taddress public poolConfigurator;\n\tuint256 public depositedRewards;\n\tuint256 public accountedRewards;\n\tuint256 public lastAllPoolUpdate;\n\n\tIMiddleFeeDistribution public rewardMinter;\n\tIEligibilityDataProvider public eligibleDataProvider;\n\tILeverager public leverager;\n\taddress public bountyManager;\n\n\tstruct EndingTime {\n\t\tuint256 estimatedTime;\n\t\tuint256 lastUpdatedTime;\n\t\tuint256 updateCadence;\n\t}\n\n\tEndingTime public endingTime;\n\n\tfunction initialize(\n\t\taddress _poolConfigurator,\n\t\tIEligibilityDataProvider _eligibleDataProvider,\n\t\tIMiddleFeeDistribution _rewardMinter,\n\t\tuint256 _rewardsPerSecond\n\t) public initializer {\n\t\trequire(address(_poolConfigurator) != address(0), \"!invalid address\");\n\t\trequire(address(_eligibleDataProvider) != address(0), \"!invalid address\");\n\t\trequire(address(_rewardMinter) != address(0), \"!invalid address\");\n\n\t\t__Ownable_init();\n\t\t__Pausable_init();\n\n\t\tpoolConfigurator = _poolConfigurator;\n\t\teligibleDataProvider = _eligibleDataProvider;\n\t\trewardMinter = _rewardMinter;\n\t\trewardsPerSecond = _rewardsPerSecond;\n\t\tpersistRewardsPerSecond = true;\n\n\t\teligibilityEnabled = true;\n\t}\n\n\tfunction poolLength() public view returns (uint256) {\n\t\treturn registeredTokens.length;\n\t}\n\n\tfunction _getMfd() internal view returns (IMultiFeeDistribution mfd) {\n\t\taddress multiFeeDistribution = rewardMinter.getMultiFeeDistributionAddress();\n\t\tmfd = IMultiFeeDistribution(multiFeeDistribution);\n\t}\n\n\tfunction setOnwardIncentives(address _token, IOnwardIncentivesController _incentives) external onlyOwner {\n\t\trequire(poolInfo[_token].lastRewardTime != 0, \"pool doesn't exist\");\n\t\tpoolInfo[_token].onwardIncentives = _incentives;\n\t}\n\n\tfunction setBountyManager(address _bountyManager) external onlyOwner {\n\t\tbountyManager = _bountyManager;\n\t}\n\n\tfunction setEligibilityEnabled(bool _newVal) external onlyOwner {\n\t\teligibilityEnabled = _newVal;\n\t}\n\n\t/********************** Pool Setup + Admin ***********************/\n\n\tfunction start() public onlyOwner {\n\t\trequire(startTime == 0, \"already started\");\n\t\tstartTime = block.timestamp;\n\t}\n\n\t// Add a new lp to the pool. Can only be called by the poolConfigurator.\n\tfunction addPool(address _token, uint256 _allocPoint) external {\n\t\trequire(msg.sender == poolConfigurator, \"not allowed\");\n\t\trequire(poolInfo[_token].lastRewardTime == 0, \"pool already exists\");\n\t\t_updateEmissions();\n\t\ttotalAllocPoint = totalAllocPoint.add(_allocPoint);\n\t\tregisteredTokens.push(_token);\n\t\tpoolInfo[_token] = PoolInfo({\n\t\t\ttotalSupply: 0,\n\t\t\tallocPoint: _allocPoint,\n\t\t\tlastRewardTime: block.timestamp,\n\t\t\taccRewardPerShare: 0,\n\t\t\tonwardIncentives: IOnwardIncentivesController(address(0))\n\t\t});\n\t\tvalidRTokens[_token] = true;\n\t}\n\n\t// Update the given pool's allocation point. Can only be called by the owner.\n\tfunction batchUpdateAllocPoint(address[] calldata _tokens, uint256[] calldata _allocPoints) public onlyOwner {\n\t\trequire(_tokens.length == _allocPoints.length, \"params length mismatch\");\n\t\t_massUpdatePools();\n\t\tuint256 _totalAllocPoint = totalAllocPoint;\n\t\tfor (uint256 i = 0; i < _tokens.length; i++) {\n\t\t\tPoolInfo storage pool = poolInfo[_tokens[i]];\n\t\t\trequire(pool.lastRewardTime > 0, \"pool doesn't exist\");\n\t\t\t_totalAllocPoint = _totalAllocPoint.sub(pool.allocPoint).add(_allocPoints[i]);\n\t\t\tpool.allocPoint = _allocPoints[i];\n\t\t}\n\t\ttotalAllocPoint = _totalAllocPoint;\n\t}\n\n\t/**\n\t * @notice Sets the reward per second to be distributed. Can only be called by the owner.\n\t * @dev Its decimals count is ACC_REWARD_PRECISION\n\t * @param _rewardsPerSecond The amount of reward to be distributed per second.\n\t */\n\tfunction setRewardsPerSecond(uint256 _rewardsPerSecond, bool _persist) external onlyOwner {\n\t\t_massUpdatePools();\n\t\trewardsPerSecond = _rewardsPerSecond;\n\t\tpersistRewardsPerSecond = _persist;\n\t\temit RewardsPerSecondUpdated(_rewardsPerSecond, _persist);\n\t}\n\n\tfunction setScheduledRewardsPerSecond() internal {\n\t\tif (!persistRewardsPerSecond) {\n\t\t\tuint256 length = emissionSchedule.length;\n\t\t\tuint256 i = emissionScheduleIndex;\n\t\t\tuint128 offset = uint128(block.timestamp.sub(startTime));\n\t\t\tfor (; i < length && offset >= emissionSchedule[i].startTimeOffset; i++) {}\n\t\t\tif (i > emissionScheduleIndex) {\n\t\t\t\temissionScheduleIndex = i;\n\t\t\t\t_massUpdatePools();\n\t\t\t\trewardsPerSecond = uint256(emissionSchedule[i - 1].rewardsPerSecond);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setEmissionSchedule(\n\t\tuint256[] calldata _startTimeOffsets,\n\t\tuint256[] calldata _rewardsPerSecond\n\t) external onlyOwner {\n\t\tuint256 length = _startTimeOffsets.length;\n\t\trequire(length > 0 && length == _rewardsPerSecond.length, \"empty or mismatch params\");\n\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\trequire(_startTimeOffsets[i - 1] < _startTimeOffsets[i], \"should be ascending\");\n\t\t\t}\n\t\t\trequire(_startTimeOffsets[i] <= type(uint128).max, \"startTimeOffsets > max uint128\");\n\t\t\trequire(_rewardsPerSecond[i] <= type(uint128).max, \"rewardsPerSecond > max uint128\");\n\n\t\t\tif (startTime > 0) {\n\t\t\t\trequire(_startTimeOffsets[i] > block.timestamp.sub(startTime), \"invalid start time\");\n\t\t\t}\n\t\t\temissionSchedule.push(\n\t\t\t\tEmissionPoint({\n\t\t\t\t\tstartTimeOffset: uint128(_startTimeOffsets[i]),\n\t\t\t\t\trewardsPerSecond: uint128(_rewardsPerSecond[i])\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\temit EmissionScheduleAppended(_startTimeOffsets, _rewardsPerSecond);\n\t}\n\n\tfunction recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n\t\tIERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n\t}\n\n\t/********************** Pool State Changers ***********************/\n\n\tfunction _updateEmissions() internal {\n\t\tif (block.timestamp > endRewardTime()) {\n\t\t\t_massUpdatePools();\n\t\t\tlastRPS = rewardsPerSecond;\n\t\t\trewardsPerSecond = 0;\n\t\t\treturn;\n\t\t}\n\t\tsetScheduledRewardsPerSecond();\n\t}\n\n\t// Update reward variables for all pools\n\tfunction _massUpdatePools() internal {\n\t\tuint256 totalAP = totalAllocPoint;\n\t\tfor (uint256 i = 0; i < poolLength(); ++i) {\n\t\t\t_updatePool(poolInfo[registeredTokens[i]], totalAP);\n\t\t}\n\t\tlastAllPoolUpdate = block.timestamp;\n\t}\n\n\t// Update reward variables of the given pool to be up-to-date.\n\tfunction _updatePool(PoolInfo storage pool, uint256 _totalAllocPoint) internal {\n\t\tuint256 timestamp = block.timestamp;\n\t\tif (endRewardTime() <= block.timestamp) {\n\t\t\ttimestamp = endRewardTime();\n\t\t}\n\t\tif (timestamp <= pool.lastRewardTime) {\n\t\t\treturn;\n\t\t}\n\n\t\tuint256 lpSupply = pool.totalSupply;\n\t\tif (lpSupply == 0) {\n\t\t\tpool.lastRewardTime = timestamp;\n\t\t\treturn;\n\t\t}\n\n\t\tuint256 duration = timestamp.sub(pool.lastRewardTime);\n\t\tuint256 rawReward = duration.mul(rewardsPerSecond);\n\t\tif (availableRewards() < rawReward) {\n\t\t\trawReward = availableRewards();\n\t\t}\n\t\tuint256 reward = rawReward.mul(pool.allocPoint).div(_totalAllocPoint);\n\t\taccountedRewards = accountedRewards.add(reward);\n\t\tpool.accRewardPerShare = pool.accRewardPerShare.add(reward.mul(ACC_REWARD_PRECISION).div(lpSupply));\n\t\tpool.lastRewardTime = timestamp;\n\t}\n\n\t/********************** Emission Calc + Transfer ***********************/\n\n\tfunction pendingRewards(address _user, address[] memory _tokens) public view returns (uint256[] memory) {\n\t\tuint256[] memory claimable = new uint256[](_tokens.length);\n\t\tfor (uint256 i = 0; i < _tokens.length; i++) {\n\t\t\taddress token = _tokens[i];\n\t\t\tPoolInfo storage pool = poolInfo[token];\n\t\t\tUserInfo storage user = userInfo[token][_user];\n\t\t\tuint256 accRewardPerShare = pool.accRewardPerShare;\n\t\t\tuint256 lpSupply = pool.totalSupply;\n\t\t\tif (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n\t\t\t\tuint256 duration = block.timestamp.sub(pool.lastRewardTime);\n\t\t\t\tuint256 reward = duration.mul(rewardsPerSecond).mul(pool.allocPoint).div(totalAllocPoint);\n\t\t\t\taccRewardPerShare = accRewardPerShare.add(reward.mul(ACC_REWARD_PRECISION).div(lpSupply));\n\t\t\t}\n\t\t\tclaimable[i] = user.amount.mul(accRewardPerShare).div(ACC_REWARD_PRECISION).sub(user.rewardDebt);\n\t\t}\n\t\treturn claimable;\n\t}\n\n\t// Claim pending rewards for one or more pools.\n\t// Rewards are not received directly, they are minted by the rewardMinter.\n\tfunction claim(address _user, address[] memory _tokens) public whenNotPaused {\n\t\tif (eligibilityEnabled) {\n\t\t\tcheckAndProcessEligibility(_user, true, true);\n\t\t}\n\n\t\t_updateEmissions();\n\n\t\tuint256 pending = userBaseClaimable[_user];\n\t\tuserBaseClaimable[_user] = 0;\n\t\tuint256 _totalAllocPoint = totalAllocPoint;\n\t\tfor (uint256 i = 0; i < _tokens.length; i++) {\n\t\t\trequire(validRTokens[_tokens[i]], \"invalid rtoken\");\n\t\t\tPoolInfo storage pool = poolInfo[_tokens[i]];\n\t\t\trequire(pool.lastRewardTime > 0, \"pool doesn't exist\");\n\t\t\t_updatePool(pool, _totalAllocPoint);\n\t\t\tUserInfo storage user = userInfo[_tokens[i]][_user];\n\t\t\tuint256 rewardDebt = user.amount.mul(pool.accRewardPerShare).div(ACC_REWARD_PRECISION);\n\t\t\tpending = pending.add(rewardDebt.sub(user.rewardDebt));\n\t\t\tuser.rewardDebt = rewardDebt;\n\t\t\tuser.lastClaimTime = block.timestamp;\n\t\t}\n\n\t\t_mint(_user, pending);\n\n\t\teligibleDataProvider.updatePrice();\n\n\t\tif (endRewardTime() < block.timestamp + 5 days) {\n\t\t\t_emitReserveLow();\n\t\t}\n\t}\n\n\tfunction _emitReserveLow() internal {\n\t\taddress rdntToken = rewardMinter.getRdntTokenAddress();\n\t\temit ChefReserveLow(IERC20(rdntToken).balanceOf(address(this)));\n\t}\n\n\tfunction _mint(address _user, uint256 _amount) internal {\n\t\t_amount = _sendRadiant(address(_getMfd()), _amount);\n\t\t_getMfd().mint(_user, _amount, true);\n\t}\n\n\tfunction setEligibilityExempt(address _contract, bool _value) public {\n\t\trequire(msg.sender == owner() || msg.sender == address(leverager), \"!authorized\");\n\t\teligibilityExempt[_contract] = _value;\n\t}\n\n\tfunction setLeverager(ILeverager _leverager) external onlyOwner {\n\t\tleverager = _leverager;\n\t}\n\n\t/********************** Eligibility + Disqualification ***********************/\n\n\t/**\n\t * @notice `after` Hook for deposit and borrow update.\n\t * @dev important! eligible status can be updated here\n\t */\n\tfunction handleActionAfter(address _user, uint256 _balance, uint256 _totalSupply) external {\n\t\trequire(validRTokens[msg.sender] || msg.sender == address(_getMfd()), \"!rToken || mfd\");\n\n\t\tif (_user == address(rewardMinter) || _user == address(_getMfd()) || eligibilityExempt[_user]) {\n\t\t\treturn;\n\t\t}\n\t\tif (eligibilityEnabled) {\n\t\t\teligibleDataProvider.refresh(_user);\n\t\t\tif (eligibleDataProvider.lastEligibleStatus(_user)) {\n\t\t\t\t_handleActionAfterForToken(msg.sender, _user, _balance, _totalSupply);\n\t\t\t} else {\n\t\t\t\tcheckAndProcessEligibility(_user, true, false);\n\t\t\t}\n\t\t} else {\n\t\t\t_handleActionAfterForToken(msg.sender, _user, _balance, _totalSupply);\n\t\t}\n\t}\n\n\tfunction _handleActionAfterForToken(\n\t\taddress _token,\n\t\taddress _user,\n\t\tuint256 _balance,\n\t\tuint256 _totalSupply\n\t) internal {\n\t\tPoolInfo storage pool = poolInfo[_token];\n\t\trequire(pool.lastRewardTime > 0, \"pool doesn't exist\");\n\t\t// _updateEmissions();\n\t\t_updatePool(pool, totalAllocPoint);\n\t\tUserInfo storage user = userInfo[_token][_user];\n\t\tuint256 amount = user.amount;\n\t\tuint256 accRewardPerShare = pool.accRewardPerShare;\n\t\tif (amount != 0) {\n\t\t\tuint256 pending = amount.mul(accRewardPerShare).div(ACC_REWARD_PRECISION).sub(user.rewardDebt);\n\t\t\tif (pending != 0) {\n\t\t\t\tuserBaseClaimable[_user] = userBaseClaimable[_user].add(pending);\n\t\t\t}\n\t\t}\n\t\tpool.totalSupply = pool.totalSupply.sub(user.amount);\n\t\tuser.amount = _balance;\n\t\tuser.rewardDebt = _balance.mul(accRewardPerShare).div(ACC_REWARD_PRECISION);\n\t\tpool.totalSupply = pool.totalSupply.add(_balance);\n\t\tif (pool.onwardIncentives != IOnwardIncentivesController(address(0))) {\n\t\t\tpool.onwardIncentives.handleAction(_token, _user, _balance, _totalSupply);\n\t\t}\n\n\t\temit BalanceUpdated(_token, _user, _balance, _totalSupply);\n\t}\n\n\t/**\n\t * @notice `before` Hook for deposit and borrow update.\n\t */\n\tfunction handleActionBefore(address _user) external {}\n\n\t/**\n\t * @notice Hook for lock update.\n\t * @dev Called by the locking contracts before locking or unlocking happens\n\t */\n\tfunction beforeLockUpdate(address _user) external {}\n\n\t/**\n\t * @notice Hook for lock update.\n\t * @dev Called by the locking contracts after locking or unlocking happens\n\t */\n\tfunction afterLockUpdate(address _user) external {\n\t\trequire(msg.sender == address(_getMfd()), \"!MFD\");\n\t\tif (eligibilityEnabled) {\n\t\t\teligibleDataProvider.refresh(_user);\n\t\t\tif (eligibleDataProvider.lastEligibleStatus(_user)) {\n\t\t\t\tfor (uint256 i = 0; i < poolLength(); i++) {\n\t\t\t\t\tuint256 newBal = IERC20(registeredTokens[i]).balanceOf(_user);\n\t\t\t\t\tuint256 registeredBal = userInfo[registeredTokens[i]][_user].amount;\n\t\t\t\t\tif (newBal != 0 && newBal != registeredBal) {\n\t\t\t\t\t\t_handleActionAfterForToken(\n\t\t\t\t\t\t\tregisteredTokens[i],\n\t\t\t\t\t\t\t_user,\n\t\t\t\t\t\t\tnewBal,\n\t\t\t\t\t\t\tpoolInfo[registeredTokens[i]].totalSupply.add(newBal).sub(registeredBal)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcheckAndProcessEligibility(_user, true, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t/********************** Eligibility + Disqualification ***********************/\n\n\tfunction hasEligibleDeposits(address _user) internal view returns (bool hasDeposits) {\n\t\tfor (uint256 i = 0; i < poolLength(); i++) {\n\t\t\tUserInfo storage user = userInfo[registeredTokens[i]][_user];\n\t\t\tif (user.amount != 0) {\n\t\t\t\thasDeposits = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction checkAndProcessEligibility(\n\t\taddress _user,\n\t\tbool _execute,\n\t\tbool _refresh\n\t) internal returns (bool issueBaseBounty) {\n\t\tbool isEligible;\n\t\tif (_refresh && _execute) {\n\t\t\teligibleDataProvider.refresh(_user);\n\t\t\tisEligible = eligibleDataProvider.lastEligibleStatus(_user);\n\t\t} else {\n\t\t\tisEligible = eligibleDataProvider.isEligibleForRewards(_user); // FALSE HERE\n\t\t}\n\t\tbool hasEligDeposits = hasEligibleDeposits(_user); // false\n\t\tuint256 lastDqTime = eligibleDataProvider.getDqTime(_user);  // 0 \n\t\tbool alreadyDqd = lastDqTime != 0;  // false\n\n\t\tif (!isEligible && hasEligDeposits && !alreadyDqd) {\n\t\t\tissueBaseBounty = true;\n\t\t}\n\t\tif (_execute && issueBaseBounty) {\n\t\t\tstopEmissionsFor(_user);\n\t\t\temit Disqualified(_user);\n\t\t}\n\t}\n\n\tfunction claimBounty(address _user, bool _execute) public returns (bool issueBaseBounty) {\n\t\trequire(msg.sender == address(bountyManager), \"bounty only\");\n\t\tissueBaseBounty = checkAndProcessEligibility(_user, _execute, true);\n\t}\n\n\tfunction stopEmissionsFor(address _user) internal {\n\t\trequire(eligibilityEnabled, \"!EE\");\n\t\t// lastEligibleStatus will be fresh from refresh before this call\n\t\trequire(!eligibleDataProvider.lastEligibleStatus(_user), \"user is still eligible\");\n\t\tfor (uint256 i = 0; i < poolLength(); ++i) {\n\t\t\taddress token = registeredTokens[i];\n\t\t\tPoolInfo storage pool = poolInfo[token];\n\t\t\tUserInfo storage user = userInfo[token][_user];\n\n\t\t\tif (user.amount != 0) {\n\t\t\t\t_handleActionAfterForToken(token, _user, 0, pool.totalSupply.sub(user.amount));\n\t\t\t}\n\t\t}\n\t\teligibleDataProvider.setDqTime(_user, block.timestamp);\n\t}\n\n\tfunction _sendRadiant(address _user, uint256 _amount) internal returns (uint256) {\n\t\tif (_amount == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\taddress rdntToken = rewardMinter.getRdntTokenAddress();\n\t\tuint256 chefReserve = IERC20(rdntToken).balanceOf(address(this));\n\t\tif (_amount > chefReserve) {\n\t\t\temit ChefReserveEmpty(chefReserve);\n\t\t\t// RPS is set to zero\n\t\t\t// Set to persist to prevent update by _updateEmissions()\n\t\t\tpersistRewardsPerSecond = true;\n\t\t\trewardsPerSecond = 0;\n\t\t\t_pause();\n\t\t} else {\n\t\t\tIERC20(rdntToken).safeTransfer(_user, _amount);\n\t\t}\n\t\treturn _amount;\n\t}\n\n\t/********************** RDNT Reserve Management ***********************/\n\n\tfunction endRewardTime() public returns (uint256) {\n\t\tif (endingTime.lastUpdatedTime + endingTime.updateCadence >= block.timestamp) {\n\t\t\treturn endingTime.estimatedTime;\n\t\t}\n\n\t\tuint256 unclaimedRewards = depositedRewards.sub(accountedRewards);\n\t\tuint256 extra = 0;\n\t\tfor (uint256 i; i < poolLength(); i++) {\n\t\t\tif (poolInfo[registeredTokens[i]].lastRewardTime <= lastAllPoolUpdate) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\textra = extra.add(\n\t\t\t\t\tpoolInfo[registeredTokens[i]]\n\t\t\t\t\t\t.lastRewardTime\n\t\t\t\t\t\t.sub(lastAllPoolUpdate)\n\t\t\t\t\t\t.mul(poolInfo[registeredTokens[i]].allocPoint)\n\t\t\t\t\t\t.mul(rewardsPerSecond)\n\t\t\t\t\t\t.div(totalAllocPoint)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (rewardsPerSecond == 0) {\n\t\t\tendingTime.estimatedTime = type(uint256).max;\n\t\t} else {\n\t\t\tendingTime.estimatedTime = (unclaimedRewards + extra).div(rewardsPerSecond) + (lastAllPoolUpdate);\n\t\t}\n\t\tendingTime.lastUpdatedTime = block.timestamp;\n\t\treturn endingTime.estimatedTime;\n\t}\n\n\tfunction setEndingTimeUpdateCadence(uint256 _lapse) external onlyOwner {\n\t\trequire(_lapse <= 1 weeks, \"cadence too long\");\n\t\tendingTime.updateCadence = _lapse;\n\t}\n\n\tfunction registerRewardDeposit(uint256 _amount) external onlyOwner {\n\t\tdepositedRewards = depositedRewards.add(_amount);\n\t\t_massUpdatePools();\n\t\tif (rewardsPerSecond == 0 && lastRPS > 0) {\n\t\t\trewardsPerSecond = lastRPS;\n\t\t}\n\t}\n\n\tfunction availableRewards() internal view returns (uint256 amount) {\n\t\treturn depositedRewards.sub(accountedRewards);\n\t}\n\n\tfunction claimAll(address _user) external {\n\t\tclaim(_user, registeredTokens);\n\t}\n\n\tfunction allPendingRewards(address _user) public view returns (uint256 pending) {\n\t\tpending = userBaseClaimable[_user];\n\t\tuint256[] memory claimable = pendingRewards(_user, registeredTokens);\n\t\tfor (uint256 i = 0; i < claimable.length; i++) {\n\t\t\tpending += claimable[i];\n\t\t}\n\t}\n\n\tfunction pause() external onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction unpause() external onlyOwner {\n\t\t_unpause();\n\t}\n}\n"
    },
    "contracts/radiant/staking/MiddleFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\n\nimport \"../../interfaces/IMiddleFeeDistribution.sol\";\nimport \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/IMintableToken.sol\";\nimport \"../../interfaces/IAaveOracle.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/IChainlinkAggregator.sol\";\n\n/// @title Fee distributor inside\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract MiddleFeeDistribution is\n    IMiddleFeeDistribution,\n    Initializable,\n    OwnableUpgradeable\n{\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice RDNT token\n    IMintableToken public rdntToken;\n\n    /// @notice Fee distributor contract for earnings and RDNT lockings\n    IMultiFeeDistribution public multiFeeDistribution;\n\n    /// @notice Reward ratio for operation expenses\n    uint256 public override operationExpenseRatio;\n\n    uint256 public constant RATIO_DIVISOR = 10000;\n\n    uint8 public constant DECIMALS = 18;\n\n    mapping(address => bool) public override isRewardToken;\n\n    /// @notice Operation Expense account\n    address public override operationExpenses;\n\n    /// @notice Admin address\n    address public admin;\n\n    // AAVE Oracle address\n    address internal _aaveOracle;\n\n    /********************** Events ***********************/\n\n    /// @notice Emitted when ERC20 token is recovered\n    event Recovered(address token, uint256 amount);\n\n    /// @notice Emitted when reward token is forwarded\n    event ForwardReward(address token, uint256 amount);\n\n    /// @notice Emitted when OpEx info is updated\n    event SetOperationExpenses(address opEx, uint256 ratio);\n\n    /// @notice Emitted when operation expenses is set\n    event OperationExpensesUpdated(\n        address _operationExpenses,\n        uint256 _operationExpenseRatio\n    );\n\n    event NewTransferAdded(address indexed asset, uint256 lpUsdValue);\n\n    /**\n     * @dev Throws if called by any account other than the admin or owner.\n     */\n    modifier onlyAdminOrOwner() {\n        require(\n            admin == _msgSender() || owner() == _msgSender(),\n            \"caller is not the admin or owner\"\n        );\n        _;\n    }\n\n    function initialize(\n        address _rdntToken,\n        address aaveOracle,\n        IMultiFeeDistribution _multiFeeDistribution\n    ) public initializer {\n        require(_rdntToken != address(0), \"rdntToken is 0 address\");\n        require(aaveOracle != address(0), \"aaveOracle is 0 address\");\n        __Ownable_init();\n\n        rdntToken = IMintableToken(_rdntToken);\n        _aaveOracle = aaveOracle;\n        multiFeeDistribution = _multiFeeDistribution;\n\n        admin = msg.sender;\n    }\n\n    /**\n     * @notice Set operation expenses account\n     */\n    function setOperationExpenses(\n        address _operationExpenses,\n        uint256 _operationExpenseRatio\n    ) external onlyOwner {\n        require(_operationExpenseRatio <= RATIO_DIVISOR, \"Invalid ratio\");\n        require(\n            _operationExpenses != address(0),\n            \"operationExpenses is 0 address\"\n        );\n        operationExpenses = _operationExpenses;\n        operationExpenseRatio = _operationExpenseRatio;\n        emit OperationExpensesUpdated(\n            _operationExpenses,\n            _operationExpenseRatio\n        );\n    }\n\n    function setAdmin(address _configurator) external onlyOwner {\n        require(_configurator != address(0), \"configurator is 0 address\");\n        admin = _configurator;\n    }\n\n    /**\n     * @notice Add a new reward token to be distributed to stakers\n     */\n    function addReward(\n        address _rewardsToken\n    ) external override onlyAdminOrOwner {\n        multiFeeDistribution.addReward(_rewardsToken);\n        isRewardToken[_rewardsToken] = true;\n    }\n\n    /**\n     * @notice Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n     */\n    function forwardReward(address[] memory _rewardTokens) external override {\n        require(msg.sender == address(multiFeeDistribution), \"!mfd\");\n\n        for (uint256 i = 0; i < _rewardTokens.length; i += 1) {\n            uint256 total = IERC20(_rewardTokens[i]).balanceOf(address(this));\n\n            if (operationExpenses != address(0) && operationExpenseRatio != 0) {\n                uint256 opExAmount = total.mul(operationExpenseRatio).div(\n                    RATIO_DIVISOR\n                );\n                if (opExAmount != 0) {\n                    IERC20(_rewardTokens[i]).safeTransfer(\n                        operationExpenses,\n                        opExAmount\n                    );\n                }\n                total = total.sub(opExAmount);\n            }\n            total = IERC20(_rewardTokens[i]).balanceOf(address(this));\n            IERC20(_rewardTokens[i]).safeTransfer(\n                address(multiFeeDistribution),\n                total\n            );\n\n            emitNewTransferAdded(_rewardTokens[i], total);\n        }\n    }\n\n    function getRdntTokenAddress() external view override returns (address) {\n        return address(rdntToken);\n    }\n\n    function getMultiFeeDistributionAddress()\n        external\n        view\n        override\n        returns (address)\n    {\n        return address(multiFeeDistribution);\n    }\n\n    /**\n     * @notice Returns lock information of a user.\n     * @dev It currently returns just MFD infos.\n     */\n    function lockedBalances(\n        address user\n    )\n        external\n        view\n        override\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            uint256 lockedWithMultiplier,\n            LockedBalance[] memory lockData\n        )\n    {\n        return multiFeeDistribution.lockedBalances(user);\n    }\n\n    function emitNewTransferAdded(address asset, uint256 lpReward) internal {\n        if (asset != address(rdntToken)) {\n            address underlying = IAToken(asset).UNDERLYING_ASSET_ADDRESS();\n            uint256 assetPrice = IAaveOracle(_aaveOracle).getAssetPrice(\n                underlying\n            );\n            address sourceOfAsset = IAaveOracle(_aaveOracle).getSourceOfAsset(\n                underlying\n            );\n            uint8 priceDecimal = IChainlinkAggregator(sourceOfAsset).decimals();\n            uint8 assetDecimals = IERC20Metadata(asset).decimals();\n            uint256 lpUsdValue = assetPrice\n                .mul(lpReward)\n                .mul(10 ** DECIMALS)\n                .div(10 ** priceDecimal)\n                .div(10 ** assetDecimals);\n            emit NewTransferAdded(asset, lpUsdValue);\n        }\n    }\n\n    /**\n     * @notice Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n     */\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) external onlyOwner {\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n"
    },
    "contracts/radiant/staking/MultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"../../interfaces/IChefIncentivesController.sol\";\nimport \"../../interfaces/IMiddleFeeDistribution.sol\";\nimport \"../../interfaces/IBountyManager.sol\";\nimport {IMultiFeeDistribution} from \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/IMintableToken.sol\";\nimport \"../../interfaces/ILockerList.sol\";\nimport \"../../interfaces/LockedBalance.sol\";\nimport \"../../interfaces/IChainlinkAggregator.sol\";\nimport \"../../interfaces/IPriceProvider.sol\";\n\n/// @title Multi Fee Distribution Contract\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract MultiFeeDistribution is\n    IMultiFeeDistribution,\n    Initializable,\n    PausableUpgradeable,\n    OwnableUpgradeable\n{\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IMintableToken;\n\n    address private _priceProvider;\n\n    /********************** Constants ***********************/\n\n    uint256 public constant QUART = 25000; //  25%\n    uint256 public constant HALF = 65000; //  65%\n    uint256 public constant WHOLE = 100000; // 100%\n\n    /// @notice Proportion of burn amount\n    uint256 public burn;\n\n    /// @notice Duration that rewards are streamed over\n    uint256 public rewardsDuration;\n\n    /// @notice Duration that rewards loop back\n    uint256 public rewardsLookback;\n\n    /// @notice Multiplier for earnings, fixed to 1\n    // uint256 public constant DEFAULT_MUTLIPLIER = 1;\n\n    /// @notice Default lock index\n    uint256 public constant DEFAULT_LOCK_INDEX = 1;\n\n    /// @notice Duration of lock/earned penalty period, used for earnings\n    uint256 public defaultLockDuration;\n\n    /// @notice Duration of vesting RDNT\n    uint256 public vestDuration;\n\n    address public rewardConverter;\n\n    /********************** Contract Addresses ***********************/\n\n    /// @notice Address of Middle Fee Distribution Contract\n    IMiddleFeeDistribution public middleFeeDistribution;\n\n    /// @notice Address of CIC contract\n    IChefIncentivesController public incentivesController;\n\n    /// @notice Address of RDNT\n    IMintableToken public override rdntToken;\n\n    /// @notice Address of LP token\n    address public override stakingToken;\n\n    // Address of Lock Zapper\n    address internal lockZap;\n\n    /********************** Lock & Earn Info ***********************/\n\n    // Private mappings for balance data\n    mapping(address => Balances) private balances;\n    mapping(address => LockedBalance[]) internal userLocks;\n    mapping(address => LockedBalance[]) private userEarnings;\n    mapping(address => bool) public override autocompoundEnabled;\n    mapping(address => uint256) public lastAutocompound;\n\n    /// @notice Total locked value\n    uint256 public lockedSupply;\n\n    /// @notice Total locked value in multipliers\n    uint256 public lockedSupplyWithMultiplier;\n\n    // Time lengths\n    uint256[] internal lockPeriod;\n\n    // Multipliers\n    uint256[] internal rewardMultipliers;\n\n    /********************** Reward Info ***********************/\n\n    /// @notice Reward tokens being distributed\n    address[] public rewardTokens;\n\n    /// @notice Reward data per token\n    mapping(address => Reward) public rewardData;\n\n    /// @notice user -> reward token -> rpt; RPT for paid amount\n    mapping(address => mapping(address => uint256))\n        public userRewardPerTokenPaid;\n\n    /// @notice user -> reward token -> amount; used to store reward amount\n    mapping(address => mapping(address => uint256)) public rewards;\n\n    /********************** Other Info ***********************/\n\n    /// @notice DAO wallet\n    address public override daoTreasury;\n\n    /// @notice treasury wallet\n    address public startfleetTreasury;\n\n    /// @notice Addresses approved to call mint\n    mapping(address => bool) public minters;\n\n    // Addresses to relock\n    mapping(address => bool) public override autoRelockDisabled;\n\n    // Default lock index for relock\n    mapping(address => uint256) public override defaultLockIndex;\n\n    /// @notice Flag to prevent more minter addings\n    bool public mintersAreSet;\n\n    // Users list\n    ILockerList public userlist;\n\n    mapping(address => uint256) public lastClaimTime;\n\n    address public bountyManager;\n\n    // to prevent unbounded lock length iteration during withdraw/clean\n\n    /********************** Events ***********************/\n\n    //event RewardAdded(uint256 reward);\n    // event Staked(address indexed user, uint256 amount, bool locked);\n    event Locked(\n        address indexed user,\n        uint256 amount,\n        uint256 lockedBalance,\n        bool isLP\n    );\n    event Withdrawn(\n        address indexed user,\n        uint256 receivedAmount,\n        uint256 lockedBalance,\n        uint256 penalty,\n        uint256 burn,\n        bool isLP\n    );\n    event RewardPaid(\n        address indexed user,\n        address indexed rewardToken,\n        uint256 reward\n    );\n    event IneligibleRewardRemoved(\n        address indexed user,\n        address indexed rewardToken,\n        uint256 reward\n    );\n    event RewardsDurationUpdated(address token, uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n    event Relocked(address indexed user, uint256 amount, uint256 lockIndex);\n\n    /**\n     * @dev Constructor\n     *  First reward MUST be the RDNT token or things will break\n     *  related to the 50% penalty and distribution to locked balances.\n     * @param _rdntToken RDNT token address.\n     * @param _rewardsDuration set reward stream time.\n     * @param _rewardsLookback reward lookback\n     * @param _lockDuration lock duration\n     */\n    function initialize(\n        address _rdntToken, \n        address _lockZap,\n        address _dao,\n        address _userlist,\n        address priceProvider,\n        uint256 _rewardsDuration,\n        uint256 _rewardsLookback,\n        uint256 _lockDuration,\n        uint256 _burnRatio,\n        uint256 _vestDuration\n    ) public initializer {\n        require(_rdntToken != address(0), \"0x0\");\n        require(_lockZap != address(0), \"0x0\");\n        require(_dao != address(0), \"0x0\");\n        require(_userlist != address(0), \"0x0\");\n        require(priceProvider != address(0), \"0x0\");\n        require(_rewardsDuration != uint256(0), \"0x0\");\n        require(_rewardsLookback != uint256(0), \"0x0\");\n        require(_lockDuration != uint256(0), \"0x0\");\n        require(_vestDuration != uint256(0), \"0x0\");\n        require(_burnRatio <= WHOLE, \"invalid burn\");\n        require(_rewardsLookback <= _rewardsDuration, \"invalid lookback\");\n\n        __Pausable_init();\n        __Ownable_init();\n\n        rdntToken = IMintableToken(_rdntToken);\n        lockZap = _lockZap;\n        daoTreasury = _dao;\n        _priceProvider = priceProvider;\n        userlist = ILockerList(_userlist);\n        rewardTokens.push(_rdntToken);\n        rewardData[_rdntToken].lastUpdateTime = block.timestamp;\n\n        rewardsDuration = _rewardsDuration;\n        rewardsLookback = _rewardsLookback;\n        defaultLockDuration = _lockDuration;\n        burn = _burnRatio;\n        vestDuration = _vestDuration;\n    }\n\n    /********************** Setters ***********************/\n\n    /**\n     * @notice Set minters\n     * @dev Can be called only once\n     */\n    function setMinters(address[] memory _minters) external onlyOwner {\n        require(!mintersAreSet, \"minters set\");\n        for (uint256 i; i < _minters.length; i++) {\n            require(_minters[i] != address(0), \"minter is 0 address\");\n            minters[_minters[i]] = true;\n        }\n        mintersAreSet = true;\n    }\n\n    function setBountyManager(address _bounty) external onlyOwner {\n        require(_bounty != address(0), \"bounty is 0 address\");\n        bountyManager = _bounty;\n        minters[_bounty] = true;\n    }\n\n    function addRewardConverter(address _rewardConverter) external onlyOwner {\n        require(_rewardConverter != address(0), \"rewardConverter is 0 address\");\n        rewardConverter = _rewardConverter;\n    }\n\n    /**\n     * @notice Add a new reward token to be distributed to stakers.\n     */\n    function setLockTypeInfo(\n        uint256[] memory _lockPeriod,\n        uint256[] memory _rewardMultipliers\n    ) external onlyOwner {\n        require(\n            _lockPeriod.length == _rewardMultipliers.length,\n            \"invalid lock period\"\n        );\n        delete lockPeriod;\n        delete rewardMultipliers;\n        for (uint256 i = 0; i < _lockPeriod.length; i += 1) {\n            lockPeriod.push(_lockPeriod[i]);\n            rewardMultipliers.push(_rewardMultipliers[i]);\n        }\n    }\n\n    /**\n     * @notice Set CIC, MFD and Treasury.\n     */\n    function setAddresses(\n        IChefIncentivesController _controller,\n        IMiddleFeeDistribution _middleFeeDistribution,\n        address _treasury\n    ) external onlyOwner {\n        require(address(_controller) != address(0), \"controller is 0 address\");\n        require(\n            address(_middleFeeDistribution) != address(0),\n            \"mfd is 0 address\"\n        );\n        incentivesController = _controller;\n        middleFeeDistribution = _middleFeeDistribution;\n        startfleetTreasury = _treasury;\n    }\n\n    /**\n     * @notice Set LP token.\n     */\n    function setLPToken(address _stakingToken) external onlyOwner {\n        require(_stakingToken != address(0), \"_stakingToken is 0 address\");\n        require(stakingToken == address(0), \"already set\");\n        stakingToken = _stakingToken;\n    }\n\n    /**\n     * @notice Add a new reward token to be distributed to stakers.\n     */\n    function addReward(address _rewardToken) external override {\n        require(_rewardToken != address(0), \"rewardToken is 0 address\");\n        require(minters[msg.sender], \"!minter\");\n        require(rewardData[_rewardToken].lastUpdateTime == 0, \"already added\");\n        rewardTokens.push(_rewardToken);\n        rewardData[_rewardToken].lastUpdateTime = block.timestamp;\n        rewardData[_rewardToken].periodFinish = block.timestamp;\n    }\n\n    /********************** View functions ***********************/\n\n    /**\n     * @notice Set default lock type index for user relock.\n     */\n    function setDefaultRelockTypeIndex(uint256 _index) external override {\n        require(_index < lockPeriod.length, \"invalid type\");\n        defaultLockIndex[msg.sender] = _index;\n    }\n\n    function setAutocompound(bool _status) external {\n        autocompoundEnabled[msg.sender] = _status;\n    }\n\n    function getLockDurations() external view returns (uint256[] memory) {\n        return lockPeriod;\n    }\n\n    function getLockMultipliers() external view returns (uint256[] memory) {\n        return rewardMultipliers;\n    }\n\n    /**\n     * @notice Set relock status\n     */\n    function setRelock(bool _status) external virtual {\n        autoRelockDisabled[msg.sender] = !_status;\n    }\n\n    /**\n     * @notice Returns all locks of a user.\n     */\n    function lockInfo(\n        address user\n    ) external view override returns (LockedBalance[] memory) {\n        return userLocks[user];\n    }\n\n    /**\n     * @notice Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders.\n     */\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) external onlyOwner {\n        require(rewardData[tokenAddress].lastUpdateTime == 0, \"active reward\");\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Withdraw and restake assets.\n     */\n    function relock() external virtual {\n        uint256 amount = _withdrawExpiredLocksFor(\n            msg.sender,\n            true,\n            true,\n            userLocks[msg.sender].length\n        );\n        _stake(amount, msg.sender, defaultLockIndex[msg.sender], false);\n        emit Relocked(msg.sender, amount, defaultLockIndex[msg.sender]);\n    }\n\n    /**\n     * @notice Total balance of an account, including unlocked, locked and earned tokens.\n     */\n    function totalBalance(\n        address user\n    ) external view override returns (uint256 amount) {\n        if (stakingToken == address(rdntToken)) {\n            return balances[user].total;\n        }\n        return balances[user].locked;\n    }\n\n    /**\n     * @notice Information on a user's lockings\n     * @return total balance of locks\n     * @return unlockable balance\n     * @return locked balance\n     * @return lockedWithMultiplier\n     * @return lockData which is an array of locks\n     */\n    function lockedBalances(\n        address user\n    )\n        public\n        view\n        override\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            uint256 lockedWithMultiplier,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[user];\n        uint256 idx;\n        for (uint256 i = 0; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n                lockedWithMultiplier = lockedWithMultiplier.add(\n                    locks[i].amount.mul(locks[i].multiplier)\n                );\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (\n            balances[user].locked,\n            unlockable,\n            locked,\n            lockedWithMultiplier,\n            lockData\n        );\n    }\n\n    /**\n     * @notice Earnings which is locked yet\n     * @dev Earned balances may be withdrawn immediately for a 50% penalty.\n     * @return total earnings\n     * @return unlocked earnings\n     * @return earningsData which is an array of all infos\n     */\n    function earnedBalances(\n        address user\n    )\n        public\n        view\n        returns (\n            uint256 total,\n            uint256 unlocked,\n            EarnedBalance[] memory earningsData\n        )\n    {\n        unlocked = balances[user].unlocked;\n        LockedBalance[] storage earnings = userEarnings[user];\n        uint256 idx;\n        for (uint256 i = 0; i < earnings.length; i++) {\n            if (earnings[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    earningsData = new EarnedBalance[](earnings.length - i);\n                }\n                (, uint256 penaltyAmount, , ) = ieeWithdrawableBalances(\n                    user,\n                    earnings[i].unlockTime\n                );\n                earningsData[idx].amount = earnings[i].amount;\n                earningsData[idx].unlockTime = earnings[i].unlockTime;\n                earningsData[idx].penalty = penaltyAmount;\n                idx++;\n                total = total.add(earnings[i].amount);\n            } else {\n                unlocked = unlocked.add(earnings[i].amount);\n            }\n        }\n        return (total, unlocked, earningsData);\n    }\n\n    /**\n     * @notice Final balance received and penalty balance paid by user upon calling exit.\n     * @dev This is earnings, not locks.\n     */\n    function withdrawableBalance(\n        address user\n    )\n        public\n        view\n        returns (uint256 amount, uint256 penaltyAmount, uint256 burnAmount)\n    {\n        uint256 earned = balances[user].earned;\n        if (earned > 0) {\n            uint256 length = userEarnings[user].length;\n            for (uint256 i = 0; i < length; i++) {\n                uint256 earnedAmount = userEarnings[user][i].amount;\n                if (earnedAmount == 0) continue;\n                (\n                    ,\n                    ,\n                    uint256 newPenaltyAmount,\n                    uint256 newBurnAmount\n                ) = _penaltyInfo(userEarnings[user][i]);\n                penaltyAmount = penaltyAmount.add(newPenaltyAmount);\n                burnAmount = burnAmount.add(newBurnAmount);\n            }\n        }\n        amount = balances[user].unlocked.add(earned).sub(penaltyAmount);\n        return (amount, penaltyAmount, burnAmount);\n    }\n\n    function _penaltyInfo(\n        LockedBalance memory earning\n    )\n        internal\n        view\n        returns (\n            uint256 amount,\n            uint256 penaltyFactor,\n            uint256 penaltyAmount,\n            uint256 burnAmount\n        )\n    {\n        if (earning.unlockTime > block.timestamp) {\n            // 90% on day 1, decays to 25% on day 90\n            penaltyFactor = earning\n                .unlockTime\n                .sub(block.timestamp)\n                .mul(HALF)\n                .div(vestDuration)\n                .add(QUART); // 25% + timeLeft/vestDuration * 65%\n        }\n        penaltyAmount = earning.amount.mul(penaltyFactor).div(WHOLE);\n        burnAmount = penaltyAmount.mul(burn).div(WHOLE);\n        amount = earning.amount.sub(penaltyAmount);\n    }\n\n    /********************** Reward functions ***********************/\n\n    /**\n     * @notice Reward amount of the duration.\n     * @param _rewardToken for the reward\n     */\n    function getRewardForDuration(\n        address _rewardToken\n    ) external view returns (uint256) {\n        return\n            rewardData[_rewardToken].rewardPerSecond.mul(rewardsDuration).div(\n                1e12\n            );\n    }\n\n    /**\n     * @notice Returns reward applicable timestamp.\n     */\n    function lastTimeRewardApplicable(\n        address _rewardToken\n    ) public view returns (uint256) {\n        uint256 periodFinish = rewardData[_rewardToken].periodFinish;\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    /**\n     * @notice Reward amount per token\n     * @dev Reward is distributed only for locks.\n     * @param _rewardToken for reward\n     */\n    function rewardPerToken(\n        address _rewardToken\n    ) public view returns (uint256 rptStored) {\n        rptStored = rewardData[_rewardToken].rewardPerTokenStored;\n        if (lockedSupplyWithMultiplier > 0) {\n            uint256 newReward = lastTimeRewardApplicable(_rewardToken)\n                .sub(rewardData[_rewardToken].lastUpdateTime)\n                .mul(rewardData[_rewardToken].rewardPerSecond);\n            rptStored = rptStored.add(\n                newReward.mul(1e18).div(lockedSupplyWithMultiplier)\n            );\n        }\n    }\n\n    /**\n     * @notice Address and claimable amount of all reward tokens for the given account.\n     * @param account for rewards\n     */\n    function claimableRewards(\n        address account\n    )\n        public\n        view\n        override\n        returns (IFeeDistribution.RewardData[] memory rewardsData)\n    {\n        rewardsData = new IFeeDistribution.RewardData[](rewardTokens.length);\n        for (uint256 i = 0; i < rewardsData.length; i++) {\n            rewardsData[i].token = rewardTokens[i];\n            rewardsData[i].amount = _earned(\n                account,\n                rewardsData[i].token,\n                balances[account].lockedWithMultiplier,\n                rewardPerToken(rewardsData[i].token)\n            ).div(1e12);\n        }\n        return rewardsData;\n    }\n\n    function claimFromConverter(\n        address onBehalf\n    ) external override whenNotPaused {\n        require(msg.sender == rewardConverter, \"!converter\");\n        _updateReward(onBehalf);\n        middleFeeDistribution.forwardReward(rewardTokens);\n        uint256 length = rewardTokens.length;\n        for (uint256 i; i < length; i++) {\n            address token = rewardTokens[i];\n            _notifyUnseenReward(token);\n            uint256 reward = rewards[onBehalf][token].div(1e12);\n            if (reward > 0) {\n                rewards[onBehalf][token] = 0;\n                rewardData[token].balance = rewardData[token].balance.sub(\n                    reward\n                );\n\n                IERC20(token).safeTransfer(rewardConverter, reward);\n                emit RewardPaid(onBehalf, token, reward);\n            }\n        }\n        IPriceProvider(_priceProvider).update();\n        lastClaimTime[onBehalf] = block.timestamp;\n    }\n\n    /********************** Operate functions ***********************/\n\n    /**\n     * @notice Stake tokens to receive rewards.\n     * @dev Locked tokens cannot be withdrawn for defaultLockDuration and are eligible to receive rewards.\n     */\n    function stake(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 typeIndex\n    ) external override {\n        _stake(amount, onBehalfOf, typeIndex, false);\n    }\n\n    function _stake(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 typeIndex,\n        bool isRelock\n    ) internal whenNotPaused {\n        if (amount == 0) return;\n        if (bountyManager != address(0)) {\n            require(\n                amount >= IBountyManager(bountyManager).minDLPBalance(),\n                \"min stake amt not met\"\n            );\n        }\n        require(typeIndex < lockPeriod.length, \"invalid index\");\n\n        _updateReward(onBehalfOf);\n\n        uint256 transferAmount = amount;\n        if (userLocks[onBehalfOf].length != 0) {\n            //if user has any locks\n            if (userLocks[onBehalfOf][0].unlockTime <= block.timestamp) {\n                //if users soonest unlock has already elapsed\n                if (onBehalfOf == msg.sender || msg.sender == lockZap) {\n                    //if the user is msg.sender or the lockzap contract\n                    uint256 withdrawnAmt;\n                    if (!autoRelockDisabled[onBehalfOf]) {\n                        withdrawnAmt = _withdrawExpiredLocksFor(\n                            onBehalfOf,\n                            true,\n                            false,\n                            userLocks[onBehalfOf].length\n                        );\n                        amount = amount.add(withdrawnAmt);\n                    } else {\n                        _withdrawExpiredLocksFor(\n                            onBehalfOf,\n                            true,\n                            true,\n                            userLocks[onBehalfOf].length\n                        );\n                    }\n                }\n            }\n        }\n        Balances storage bal = balances[onBehalfOf];\n        bal.total = bal.total.add(amount);\n\n        bal.locked = bal.locked.add(amount);\n        lockedSupply = lockedSupply.add(amount);\n\n        bal.lockedWithMultiplier = bal.lockedWithMultiplier.add(\n            amount.mul(rewardMultipliers[typeIndex])\n        );\n        lockedSupplyWithMultiplier = lockedSupplyWithMultiplier.add(\n            amount.mul(rewardMultipliers[typeIndex])\n        );\n\n        _insertLock(\n            onBehalfOf,\n            LockedBalance({\n                amount: amount,\n                unlockTime: block.timestamp.add(lockPeriod[typeIndex]),\n                multiplier: rewardMultipliers[typeIndex],\n                duration: lockPeriod[typeIndex]\n            })\n        );\n\n        userlist.addToList(onBehalfOf);\n\n        if (!isRelock) {\n            IERC20(stakingToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                transferAmount\n            );\n        }\n\n        incentivesController.afterLockUpdate(onBehalfOf);\n        emit Locked(\n            onBehalfOf,\n            amount,\n            balances[onBehalfOf].locked,\n            stakingToken != address(rdntToken)\n        );\n    }\n\n    function _insertLock(address _user, LockedBalance memory newLock) internal {\n        LockedBalance[] storage locks = userLocks[_user];\n        uint256 length = locks.length;\n        uint256 i;\n        while (i < length && locks[i].unlockTime < newLock.unlockTime) {\n            i = i + 1;\n        }\n        locks.push(newLock);\n        for (uint256 j = length; j > i; j -= 1) {\n            locks[j] = locks[j - 1];\n        }\n        locks[i] = newLock;\n    }\n\n    /**\n     * @notice Add to earnings\n     * @dev Minted tokens receive rewards normally but incur a 50% penalty when\n     *  withdrawn before vestDuration has passed.\n     */\n    function mint(\n        address user,\n        uint256 amount,\n        bool withPenalty\n    ) external override whenNotPaused {\n        require(minters[msg.sender], \"!minter\");\n        if (amount == 0) return;\n\n        if (user == address(this)) {\n            // minting to this contract adds the new tokens as incentives for lockers\n            _notifyReward(address(rdntToken), amount);\n            return;\n        }\n\n        Balances storage bal = balances[user];\n        bal.total = bal.total.add(amount);\n        if (withPenalty) {\n            bal.earned = bal.earned.add(amount);\n            LockedBalance[] storage earnings = userEarnings[user];\n            uint256 unlockTime = block.timestamp.add(vestDuration);\n            earnings.push(\n                LockedBalance({\n                    amount: amount,\n                    unlockTime: unlockTime,\n                    multiplier: 1,\n                    duration: vestDuration\n                })\n            );\n        } else {\n            bal.unlocked = bal.unlocked.add(amount);\n        }\n        //emit Staked(user, amount, false);\n    }\n\n    /**\n     * @notice Withdraw tokens from earnings and unlocked.\n     * @dev First withdraws unlocked tokens, then earned tokens. Withdrawing earned tokens\n     *  incurs a 50% penalty which is distributed based on locked balances.\n     */\n    function withdraw(uint256 amount) external {\n        address _address = msg.sender;\n        require(amount != 0, \"amt cannot be 0\");\n\n        uint256 penaltyAmount;\n        uint256 burnAmount;\n        Balances storage bal = balances[_address];\n\n        if (amount <= bal.unlocked) {\n            bal.unlocked = bal.unlocked.sub(amount);\n        } else {\n            uint256 remaining = amount.sub(bal.unlocked);\n            require(bal.earned >= remaining, \"invalid earned\");\n            bal.unlocked = 0;\n            uint256 sumEarned = bal.earned;\n            uint256 i;\n            for (i = 0; ; i++) {\n                uint256 earnedAmount = userEarnings[_address][i].amount;\n                if (earnedAmount == 0) continue;\n                (, uint256 penaltyFactor, , ) = _penaltyInfo(\n                    userEarnings[_address][i]\n                );\n\n                // Amount required from this lock, taking into account the penalty\n                uint256 requiredAmount = remaining.mul(WHOLE).div(\n                    WHOLE.sub(penaltyFactor)\n                );\n                if (requiredAmount >= earnedAmount) {\n                    requiredAmount = earnedAmount;\n                    remaining = remaining.sub(\n                        earnedAmount.mul(WHOLE.sub(penaltyFactor)).div(WHOLE)\n                    ); // remaining -= earned * (1 - pentaltyFactor)\n                    if (remaining == 0) i++;\n                } else {\n                    userEarnings[_address][i].amount = earnedAmount.sub(\n                        requiredAmount\n                    );\n                    remaining = 0;\n                }\n                sumEarned = sumEarned.sub(requiredAmount);\n\n                penaltyAmount = penaltyAmount.add(\n                    requiredAmount.mul(penaltyFactor).div(WHOLE)\n                ); // penalty += amount * penaltyFactor\n                burnAmount = burnAmount.add(penaltyAmount.mul(burn).div(WHOLE)); // burn += penalty * burnFactor\n\n                if (remaining == 0) {\n                    break;\n                } else {\n                    require(sumEarned != 0, \"0 earned\");\n                }\n            }\n            if (i > 0) {\n                for (uint256 j = i; j < userEarnings[_address].length; j++) {\n                    userEarnings[_address][j - i] = userEarnings[_address][j];\n                }\n                for (uint256 j = 0; j < i; j++) {\n                    userEarnings[_address].pop();\n                }\n            }\n            bal.earned = sumEarned;\n        }\n\n        // Update values\n        bal.total = bal.total.sub(amount).sub(penaltyAmount);\n\n        _withdrawTokens(_address, amount, penaltyAmount, burnAmount, false);\n    }\n\n    function ieeWithdrawableBalances(\n        address user,\n        uint256 unlockTime\n    )\n        internal\n        view\n        returns (\n            uint256 amount,\n            uint256 penaltyAmount,\n            uint256 burnAmount,\n            uint256 index\n        )\n    {\n        for (uint256 i = 0; i < userEarnings[user].length; i++) {\n            if (userEarnings[user][i].unlockTime == unlockTime) {\n                (amount, , penaltyAmount, burnAmount) = _penaltyInfo(\n                    userEarnings[user][i]\n                );\n                index = i;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw individual unlocked balance and earnings, optionally claim pending rewards.\n     */\n    function individualEarlyExit(\n        bool claimRewards,\n        uint256 unlockTime\n    ) external {\n        address onBehalfOf = msg.sender;\n        require(unlockTime > block.timestamp, \"!unlockTime\");\n        (\n            uint256 amount,\n            uint256 penaltyAmount,\n            uint256 burnAmount,\n            uint256 index\n        ) = ieeWithdrawableBalances(onBehalfOf, unlockTime);\n\n        if (index >= userEarnings[onBehalfOf].length) {\n            return;\n        }\n\n        for (uint256 i = index + 1; i < userEarnings[onBehalfOf].length; i++) {\n            userEarnings[onBehalfOf][i - 1] = userEarnings[onBehalfOf][i];\n        }\n        userEarnings[onBehalfOf].pop();\n\n        Balances storage bal = balances[onBehalfOf];\n        bal.total = bal.total.sub(amount).sub(penaltyAmount);\n        bal.earned = bal.earned.sub(amount).sub(penaltyAmount);\n\n        _withdrawTokens(\n            onBehalfOf,\n            amount,\n            penaltyAmount,\n            burnAmount,\n            claimRewards\n        );\n    }\n\n    /**\n     * @notice Withdraw full unlocked balance and earnings, optionally claim pending rewards.\n     */\n    function exit(bool claimRewards) external override {\n        address onBehalfOf = msg.sender;\n        (\n            uint256 amount,\n            uint256 penaltyAmount,\n            uint256 burnAmount\n        ) = withdrawableBalance(onBehalfOf);\n\n        delete userEarnings[onBehalfOf];\n\n        Balances storage bal = balances[onBehalfOf];\n        bal.total = bal.total.sub(bal.unlocked).sub(bal.earned);\n        bal.unlocked = 0;\n        bal.earned = 0;\n\n        _withdrawTokens(\n            onBehalfOf,\n            amount,\n            penaltyAmount,\n            burnAmount,\n            claimRewards\n        );\n    }\n\n    /**\n     * @notice Claim all pending staking rewards.\n     */\n    function getReward(address[] memory _rewardTokens) public {\n        _updateReward(msg.sender);\n        _getReward(msg.sender, _rewardTokens);\n        IPriceProvider(_priceProvider).update();\n    }\n\n    /**\n     * @notice Claim all pending staking rewards.\n     */\n    function getAllRewards() external {\n        return getReward(rewardTokens);\n    }\n\n    /**\n     * @notice Calculate earnings.\n     */\n    function _earned(\n        address _user,\n        address _rewardToken,\n        uint256 _balance,\n        uint256 _currentRewardPerToken\n    ) internal view returns (uint256 earnings) {\n        earnings = rewards[_user][_rewardToken];\n        uint256 realRPT = _currentRewardPerToken.sub(\n            userRewardPerTokenPaid[_user][_rewardToken]\n        );\n        earnings = earnings.add(_balance.mul(realRPT).div(1e18));\n    }\n\n    /**\n     * @notice Update user reward info.\n     */\n    function _updateReward(address account) internal {\n        uint256 balance = balances[account].lockedWithMultiplier;\n        uint256 length = rewardTokens.length;\n        for (uint256 i = 0; i < length; i++) {\n            address token = rewardTokens[i];\n            uint256 rpt = rewardPerToken(token);\n\n            Reward storage r = rewardData[token];\n            r.rewardPerTokenStored = rpt;\n            r.lastUpdateTime = lastTimeRewardApplicable(token);\n\n            if (account != address(this)) {\n                rewards[account][token] = _earned(account, token, balance, rpt);\n                userRewardPerTokenPaid[account][token] = rpt;\n            }\n        }\n    }\n\n    /**\n     * @notice Add new reward.\n     * @dev If prev reward period is not done, then it resets `rewardPerSecond` and restarts period\n     */\n    function _notifyReward(address _rewardToken, uint256 reward) internal {\n        Reward storage r = rewardData[_rewardToken];\n        if (block.timestamp >= r.periodFinish) {\n            r.rewardPerSecond = reward.mul(1e12).div(rewardsDuration);\n        } else {\n            uint256 remaining = r.periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(r.rewardPerSecond).div(1e12);\n            r.rewardPerSecond = reward.add(leftover).mul(1e12).div(\n                rewardsDuration\n            );\n        }\n\n        r.lastUpdateTime = block.timestamp;\n        r.periodFinish = block.timestamp.add(rewardsDuration);\n        r.balance = r.balance.add(reward);\n    }\n\n    /**\n     * @notice Notify unseen rewards.\n     * @dev for rewards other than stakingToken, every 24 hours we check if new\n     *  rewards were sent to the contract or accrued via aToken interest.\n     */\n    function _notifyUnseenReward(address token) internal {\n        require(token != address(0), \"Invalid Token\");\n        if (token == address(rdntToken)) {\n            return;\n        }\n        Reward storage r = rewardData[token];\n        uint256 periodFinish = r.periodFinish;\n        require(periodFinish != 0, \"invalid period finish\");\n        if (\n            periodFinish <\n            block.timestamp.add(rewardsDuration - rewardsLookback)\n        ) {\n            uint256 unseen = IERC20(token).balanceOf(address(this)).sub(\n                r.balance\n            );\n            if (unseen > 0) {\n                _notifyReward(token, unseen);\n            }\n        }\n    }\n\n    function onUpgrade() public {}\n\n    function setLookback(uint256 _lookback) public onlyOwner {\n        rewardsLookback = _lookback;\n    }\n\n    /**\n     * @notice User gets reward\n     */\n    function _getReward(\n        address _user,\n        address[] memory _rewardTokens\n    ) internal whenNotPaused {\n        middleFeeDistribution.forwardReward(_rewardTokens);\n        uint256 length = _rewardTokens.length;\n        for (uint256 i; i < length; i++) {\n            address token = _rewardTokens[i];\n            _notifyUnseenReward(token);\n            uint256 reward = rewards[_user][token].div(1e12);\n            if (reward > 0) {\n                rewards[_user][token] = 0;\n                rewardData[token].balance = rewardData[token].balance.sub(\n                    reward\n                );\n\n                IERC20(token).safeTransfer(_user, reward);\n                emit RewardPaid(_user, token, reward);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw tokens from MFD\n     */\n    function _withdrawTokens(\n        address onBehalfOf,\n        uint256 amount,\n        uint256 penaltyAmount,\n        uint256 burnAmount,\n        bool claimRewards\n    ) internal {\n        require(onBehalfOf == msg.sender, \"onBehalfOf != sender\");\n        _updateReward(onBehalfOf);\n\n        rdntToken.safeTransfer(onBehalfOf, amount);\n        if (penaltyAmount > 0) {\n            if (burnAmount > 0) {\n                rdntToken.safeTransfer(startfleetTreasury, burnAmount);\n            }\n            rdntToken.safeTransfer(daoTreasury, penaltyAmount.sub(burnAmount));\n        }\n\n        if (claimRewards) {\n            _getReward(onBehalfOf, rewardTokens);\n            lastClaimTime[onBehalfOf] = block.timestamp;\n        }\n\n        IPriceProvider(_priceProvider).update();\n\n        emit Withdrawn(\n            onBehalfOf,\n            amount,\n            balances[onBehalfOf].locked,\n            penaltyAmount,\n            burnAmount,\n            stakingToken != address(rdntToken)\n        );\n    }\n\n    /********************** Eligibility + Disqualification ***********************/\n\n    /**\n     * @notice Withdraw all lockings tokens where the unlock time has passed\n     */\n    function _cleanWithdrawableLocks(\n        address user,\n        uint256 totalLock,\n        uint256 totalLockWithMultiplier,\n        uint256 limit\n    ) internal returns (uint256 lockAmount, uint256 lockAmountWithMultiplier) {\n        LockedBalance[] storage locks = userLocks[user];\n\n        if (locks.length != 0) {\n            uint256 length = locks.length <= limit ? locks.length : limit;\n            for (uint256 i = 0; i < length; ) {\n                if (locks[i].unlockTime <= block.timestamp) {\n                    lockAmount = lockAmount.add(locks[i].amount);\n                    lockAmountWithMultiplier = lockAmountWithMultiplier.add(\n                        locks[i].amount.mul(locks[i].multiplier)\n                    );\n                    locks[i] = locks[locks.length - 1];\n                    locks.pop();\n                    length = length.sub(1);\n                } else {\n                    i = i + 1;\n                }\n            }\n            if (locks.length == 0) {\n                lockAmount = totalLock;\n                lockAmountWithMultiplier = totalLockWithMultiplier;\n                delete userLocks[user];\n\n                userlist.removeFromList(user);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw all currently locked tokens where the unlock time has passed.\n     * @param _address of the user.\n     */\n    function _withdrawExpiredLocksFor(\n        address _address,\n        bool isRelockAction,\n        bool doTransfer,\n        uint256 limit\n    ) internal whenNotPaused returns (uint256 amount) {\n        _updateReward(_address);\n\n        uint256 amountWithMultiplier;\n        Balances storage bal = balances[_address];\n        (amount, amountWithMultiplier) = _cleanWithdrawableLocks(\n            _address,\n            bal.locked,\n            bal.lockedWithMultiplier,\n            limit\n        );\n        bal.locked = bal.locked.sub(amount);\n        bal.lockedWithMultiplier = bal.lockedWithMultiplier.sub(\n            amountWithMultiplier\n        );\n        bal.total = bal.total.sub(amount);\n        lockedSupply = lockedSupply.sub(amount);\n        lockedSupplyWithMultiplier = lockedSupplyWithMultiplier.sub(\n            amountWithMultiplier\n        );\n\n        if (!isRelockAction && !autoRelockDisabled[_address]) {\n            _stake(amount, _address, defaultLockIndex[_address], true);\n        } else {\n            if (doTransfer) {\n                IERC20(stakingToken).safeTransfer(_address, amount);\n                incentivesController.afterLockUpdate(_address);\n                emit Withdrawn(\n                    _address,\n                    amount,\n                    balances[_address].locked,\n                    0,\n                    0,\n                    stakingToken != address(rdntToken)\n                );\n            }\n        }\n        return amount;\n    }\n\n    /**\n     * @notice Withdraw all currently locked tokens where the unlock time has passed.\n     */\n    function withdrawExpiredLocksFor(\n        address _address\n    ) external override returns (uint256) {\n        return\n            _withdrawExpiredLocksFor(\n                _address,\n                false,\n                true,\n                userLocks[_address].length\n            );\n    }\n\n    function withdrawExpiredLocksForWithOptions(\n        address _address,\n        uint256 _limit,\n        bool _ignoreRelock\n    ) external returns (uint256) {\n        if (_limit == 0) _limit = userLocks[_address].length;\n\n        return _withdrawExpiredLocksFor(_address, _ignoreRelock, true, _limit);\n    }\n\n    function zapVestingToLp(\n        address _user\n    ) external override returns (uint256 zapped) {\n        require(msg.sender == lockZap, \"!lockZap\");\n\n        _updateReward(_user);\n\n        LockedBalance[] storage earnings = userEarnings[_user];\n        for (uint256 i = earnings.length; i > 0; i -= 1) {\n            if (earnings[i - 1].unlockTime > block.timestamp) {\n                zapped = zapped.add(earnings[i - 1].amount);\n                earnings.pop();\n            } else {\n                break;\n            }\n        }\n\n        rdntToken.safeTransfer(lockZap, zapped);\n\n        Balances storage bal = balances[_user];\n        bal.earned = bal.earned.sub(zapped);\n        bal.total = bal.total.sub(zapped);\n\n        IPriceProvider(_priceProvider).update();\n\n        return zapped;\n    }\n\n    function getPriceProvider() external view override returns (address) {\n        return _priceProvider;\n    }\n\n    /**\n     * @notice Claims bounty.\n     * @dev Remove expired locks\n     * @param _user address.\n     */\n    function claimBounty(\n        address _user,\n        bool _execute\n    ) public whenNotPaused returns (bool issueBaseBounty) {\n        require(msg.sender == address(bountyManager), \"!bountyManager\");\n\n        (, uint256 unlockable, , , ) = lockedBalances(_user);\n        if (unlockable == 0) {\n            return (false);\n        } else {\n            issueBaseBounty = true;\n        }\n\n        if (!_execute) {\n            return (issueBaseBounty);\n        }\n        // Withdraw the user's expried locks\n        _withdrawExpiredLocksFor(_user, false, true, userLocks[_user].length);\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/radiant/token/Migration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/// @title Migration contract from V1 to V2\n/// @author Radiant team\n/// @dev All function calls are currently implemented without side effects\ncontract Migration is Ownable, Pausable {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for ERC20;\n\n\t/// @notice V1 of RDNT\n\tERC20 public tokenV1;\n\n\t/// @notice V2 of RDNT\n\tERC20 public tokenV2;\n\n\t/// @notice emitted when migrate v1 token into v2\n\tevent Migrate(address indexed user, uint256 amount);\n\n\t/**\n\t * @notice constructor\n\t * @param _tokenV1 RDNT V1 token address\n\t * @param _tokenV2 RDNT V2 token address\n\t */\n\tconstructor(ERC20 _tokenV1, ERC20 _tokenV2) Ownable() {\n\t\ttokenV1 = _tokenV1;\n\t\ttokenV2 = _tokenV2;\n\t\t_pause();\n\t}\n\n\tfunction pause() public onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction unpause() public onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @notice Withdraw ERC20 token\n\t * @param _token address for withdraw\n\t * @param _amount to withdraw\n\t */\n\tfunction withdrawToken(ERC20 _token, uint256 _amount) external onlyOwner {\n\t\t_token.safeTransfer(owner(), _amount);\n\t}\n\n\t/**\n\t * @notice Migrate from V1 to V2\n\t * @param _amount of V1 token\n\t */\n\tfunction exchange(uint256 _amount) external whenNotPaused {\n\t\ttokenV1.safeTransferFrom(_msgSender(), address(this), _amount);\n\t\ttokenV2.safeTransfer(_msgSender(), _amount);\n\n\t\temit Migrate(_msgSender(), _amount);\n\t}\n}\n"
    },
    "contracts/radiant/token/RadiantOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTV2.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/IPriceProvider.sol\";\n\ncontract RadiantOFT is OFTV2, Pausable {\n\tusing SafeMath for uint256;\n\n\t/// @notice bridge fee reciever\n\taddress private treasury;\n\n\t/// @notice Fee ratio for bridging, in bips\n\tuint256 public feeRatio;\n\n\t/// @notice Divisor for fee ratio, 100%\n\tuint256 public constant FEE_DIVISOR = 10000;\n\n\t/// @notice PriceProvider, for RDNT price in native fee calc\n\tIPriceProvider public priceProvider;\n\n\t/// @notice Emitted when fee ratio is updated\n\tevent FeeUpdated(uint256 fee);\n\n\t/// @notice Emitted when PriceProvider is updated\n\tevent PriceProviderUpdated(IPriceProvider indexed priceProvider);\n\n\t/// @notice Emitted when Treasury is updated\n\tevent TreasuryUpdated(address indexed treasury);\n\n\t/**\n\t * @notice Create AlphaOFT\n\t * @param _tokenName token name\n\t * @param _symbol token symbol\n\t * @param _endpoint LZ endpoint for network\n\t * @param _dao DAO address, for initial mint\n\t * @param _treasury Treasury address, for fee recieve\n\t * @param _mintAmt Mint amount\n\t */\n\tconstructor(\n\t\tstring memory _tokenName,\n\t\tstring memory _symbol,\n\t\taddress _endpoint,\n\t\taddress _dao,\n\t\taddress _treasury,\n\t\tuint256 _mintAmt\n\t) OFTV2(_tokenName, _symbol, 8, _endpoint) {\n\t\trequire(_endpoint != address(0), \"invalid LZ Endpoint\");\n\t\trequire(_dao != address(0), \"invalid DAO\");\n\t\trequire(_treasury != address(0), \"invalid treasury\");\n\n\t\ttreasury = _treasury;\n\n\t\tif (_mintAmt != 0) {\n\t\t\t_mint(_dao, _mintAmt);\n\t\t}\n\t}\n\n\tfunction burn(uint256 _amount) public {\n\t\t_burn(_msgSender(), _amount);\n\t}\n\n\tfunction pause() public onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction unpause() public onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/**\n\t * @notice Returns LZ fee + Bridge fee\n\t * @dev overrides default OFT estimate fee function to add native fee\n\t * @param _dstChainId dest LZ chain id\n\t * @param _toAddress to addr on dst chain\n\t * @param _amount amount to bridge\n\t * @param _useZro use ZRO token, someday ;)\n\t * @param _adapterParams LZ adapter params\n\t */\n\tfunction estimateSendFee(\n\t\tuint16 _dstChainId,\n\t\tbytes32 _toAddress,\n\t\tuint _amount,\n\t\tbool _useZro,\n\t\tbytes calldata _adapterParams\n\t) public view override returns (uint nativeFee, uint zroFee) {\n\t\t(nativeFee, zroFee) = super.estimateSendFee(_dstChainId, _toAddress, _amount, _useZro, _adapterParams);\n\t\tnativeFee = nativeFee.add(getBridgeFee(_amount));\n\t}\n\n\t/**\n\t * @notice Returns LZ fee + Bridge fee\n\t * @dev overrides default OFT _send function to add native fee\n\t * @param _from from addr\n\t * @param _dstChainId dest LZ chain id\n\t * @param _toAddress to addr on dst chain\n\t * @param _amount amount to bridge\n\t * @param _refundAddress refund addr\n\t * @param _zroPaymentAddress use ZRO token, someday ;)\n\t * @param _adapterParams LZ adapter params\n\t */\n\tfunction _send(\n\t\taddress _from,\n\t\tuint16 _dstChainId,\n\t\tbytes32 _toAddress,\n\t\tuint _amount,\n\t\taddress payable _refundAddress,\n\t\taddress _zroPaymentAddress,\n\t\tbytes memory _adapterParams\n\t) internal override returns (uint amount) {\n\t\tuint256 fee = getBridgeFee(_amount);\n\t\trequire(msg.value >= fee, \"ETH sent is not enough for fee\");\n\t\tpayable(treasury).transfer(fee);\n\n\t\t//_checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n\t\t(amount, ) = _removeDust(_amount);\n\t\tamount = _debitFrom(_from, _dstChainId, _toAddress, amount); // amount returned should not have dust\n\t\trequire(amount > 0, \"OFTCore: amount too small\");\n\n\t\tbytes memory lzPayload = _encodeSendPayload(_toAddress, _ld2sd(amount));\n\t\t_lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value.sub(fee));\n\n\t\temit SendToChain(_dstChainId, _from, _toAddress, amount);\n\t}\n\n\t/**\n\t * @notice overrides default OFT _debitFrom function to make pauseable\n\t * @param _from from addr\n\t * @param _dstChainId dest LZ chain id\n\t * @param _toAddress to addr on dst chain\n\t * @param _amount amount to bridge\n\t */\n\tfunction _debitFrom(\n\t\taddress _from,\n\t\tuint16 _dstChainId,\n\t\tbytes32 _toAddress,\n\t\tuint _amount\n\t) internal override whenNotPaused returns (uint) {\n\t\treturn super._debitFrom(_from, _dstChainId, _toAddress, _amount);\n\t}\n\n\t/**\n\t * @notice Bridge fee amount\n\t * @param _rdntAmount amount for bridge\n\t */\n\tfunction getBridgeFee(uint256 _rdntAmount) public view returns (uint256) {\n\t\tif (address(priceProvider) == address(0)) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 priceInEth = priceProvider.getTokenPrice();\n\t\tuint256 priceDecimals = priceProvider.decimals();\n\t\tuint256 rdntInEth = _rdntAmount.mul(priceInEth).div(10 ** priceDecimals).mul(10 ** 18).div(10 ** decimals());\n\t\treturn rdntInEth.mul(feeRatio).div(FEE_DIVISOR);\n\t}\n\n\t/**\n\t * @notice Set fee info\n\t * @param _fee ratio\n\t */\n\tfunction setFee(uint256 _fee) external onlyOwner {\n\t\trequire(_fee <= 1e4, \"Invalid ratio\");\n\t\tfeeRatio = _fee;\n\t\temit FeeUpdated(_fee);\n\t}\n\n\t/**\n\t * @notice Set price provider\n\t * @param _priceProvider address\n\t */\n\tfunction setPriceProvider(IPriceProvider _priceProvider) external onlyOwner {\n\t\trequire(address(_priceProvider) != address(0), \"invalid PriceProvider\");\n\t\tpriceProvider = _priceProvider;\n\t\temit PriceProviderUpdated(_priceProvider);\n\t}\n\n\t/**\n\t * @notice Set Treasury\n\t * @param _treasury address\n\t */\n\tfunction setTreasury(address _treasury) external onlyOwner {\n\t\trequire(_treasury != address(0), \"invalid Treasury address\");\n\t\ttreasury = _treasury;\n\t\temit TreasuryUpdated(_treasury);\n\t}\n}\n"
    },
    "contracts/radiant/zap/helpers/BalancerPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"./DustRefunder.sol\";\nimport \"../../../dependencies/math/BNum.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../../../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../../../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\n\nimport \"../../../interfaces/ILiquidityZap.sol\";\nimport \"../../../interfaces/IPoolHelper.sol\";\nimport \"../../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../../interfaces/IWETH.sol\";\nimport \"../../../interfaces/ILendingPool.sol\";\nimport \"../../../interfaces/balancer/IWeightedPoolFactory.sol\";\n\n/// @title Balance Pool Helper Contract\n/// @author Radiant\ncontract BalancerPoolHelper is IBalancerPoolHelper, Initializable, OwnableUpgradeable, BNum, DustRefunder {\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\taddress public inTokenAddr;\n\taddress public outTokenAddr;\n\taddress public wethAddr;\n\taddress public override lpTokenAddr;\n\taddress public vaultAddr;\n\tbytes32 public poolId;\n\taddress public lockZap;\n\tIWeightedPoolFactory public poolFactory;\n\n\tfunction initialize(\n\t\taddress _inTokenAddr,\n\t\taddress _outTokenAddr,\n\t\taddress _wethAddr,\n\t\taddress _vault,\n\t\tIWeightedPoolFactory _poolFactory\n\t) external initializer {\n\t\trequire(_inTokenAddr != address(0), \"inTokenAddr is 0 address\");\n\t\trequire(_outTokenAddr != address(0), \"outTokenAddr is 0 address\");\n\t\trequire(_wethAddr != address(0), \"wethAddr is 0 address\");\n\t\trequire(_vault != address(0), \"vault is 0 address\");\n\t\t__Ownable_init();\n\t\tinTokenAddr = _inTokenAddr;\n\t\toutTokenAddr = _outTokenAddr;\n\t\twethAddr = _wethAddr;\n\t\tvaultAddr = _vault;\n\t\tpoolFactory = _poolFactory;\n\t}\n\n\tfunction initializePool(string calldata _tokenName, string calldata _tokenSymbol) public {\n\t\trequire(lpTokenAddr == address(0), \"Already initialized\");\n\n\t\t(address token0, address token1) = sortTokens(inTokenAddr, outTokenAddr);\n\n\t\tIERC20[] memory tokens = new IERC20[](2);\n\t\ttokens[0] = IERC20(token0);\n\t\ttokens[1] = IERC20(token1);\n\n\t\taddress[] memory rateProviders = new address[](2);\n\t\trateProviders[0] = 0x0000000000000000000000000000000000000000;\n\t\trateProviders[1] = 0x0000000000000000000000000000000000000000;\n\n\t\tuint256 swapFeePercentage = 1000000000000000;\n\n\t\tuint256[] memory weights = new uint256[](2);\n\n\t\tif (token0 == outTokenAddr) {\n\t\t\tweights[0] = 800000000000000000;\n\t\t\tweights[1] = 200000000000000000;\n\t\t} else {\n\t\t\tweights[0] = 200000000000000000;\n\t\t\tweights[1] = 800000000000000000;\n\t\t}\n\n\t\tlpTokenAddr = poolFactory.create(\n\t\t\t_tokenName,\n\t\t\t_tokenSymbol,\n\t\t\ttokens,\n\t\t\tweights,\n\t\t\trateProviders,\n\t\t\tswapFeePercentage,\n\t\t\taddress(this)\n\t\t);\n\n\t\tpoolId = IWeightedPool(lpTokenAddr).getPoolId();\n\n\t\tIERC20 outToken = IERC20(outTokenAddr);\n\t\tIERC20 inToken = IERC20(inTokenAddr);\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tIERC20 weth = IERC20(wethAddr);\n\n\t\toutToken.safeApprove(vaultAddr, type(uint256).max);\n\t\tinToken.safeApprove(vaultAddr, type(uint256).max);\n\t\tweth.approve(vaultAddr, type(uint256).max);\n\n\t\tIAsset[] memory assets = new IAsset[](2);\n\t\tassets[0] = IAsset(token0);\n\t\tassets[1] = IAsset(token1);\n\n\t\tuint256 inTokenAmt = inToken.balanceOf(address(this));\n\t\tuint256 outTokenAmt = outToken.balanceOf(address(this));\n\n\t\tuint256[] memory maxAmountsIn = new uint256[](2);\n\t\tif (token0 == inTokenAddr) {\n\t\t\tmaxAmountsIn[0] = inTokenAmt;\n\t\t\tmaxAmountsIn[1] = outTokenAmt;\n\t\t} else {\n\t\t\tmaxAmountsIn[0] = outTokenAmt;\n\t\t\tmaxAmountsIn[1] = inTokenAmt;\n\t\t}\n\n\t\tIVault.JoinPoolRequest memory inRequest = IVault.JoinPoolRequest(\n\t\t\tassets,\n\t\t\tmaxAmountsIn,\n\t\t\tabi.encode(0, maxAmountsIn),\n\t\t\tfalse\n\t\t);\n\t\tIVault(vaultAddr).joinPool(poolId, address(this), address(this), inRequest);\n\t\tuint256 liquidity = lp.balanceOf(address(this));\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\t}\n\n\t/// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.\n\t/// @param resA Reserve of the first asset\n\t/// @param resB Reserve of the second asset\n\t/// @param wA Weight of the first asset\n\t/// @param wB Weight of the second asset\n\t/// @param pxA Fair price of the first asset\n\t/// @param pxB Fair price of the second asset\n\tfunction computeFairReserves(\n\t\tuint256 resA,\n\t\tuint256 resB,\n\t\tuint256 wA,\n\t\tuint256 wB,\n\t\tuint256 pxA,\n\t\tuint256 pxB\n\t) internal pure returns (uint256 fairResA, uint256 fairResB) {\n\t\t// NOTE: wA + wB = 1 (normalize weights)\n\t\t// constant product = resA^wA * resB^wB\n\t\t// constraints:\n\t\t// - fairResA^wA * fairResB^wB = constant product\n\t\t// - fairResA * pxA / wA = fairResB * pxB / wB\n\t\t// Solving equations:\n\t\t// --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n\t\t// --> fairResA / r1^wB = constant product\n\t\t// --> fairResA = resA^wA * resB^wB * r1^wB\n\t\t// --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n\t\tuint256 r0 = bdiv(resA, resB);\n\t\tuint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n\t\t// fairResA = resA * (r1 / r0) ^ wB\n\t\t// fairResB = resB * (r0 / r1) ^ wA\n\t\tif (r0 > r1) {\n\t\t\tuint256 ratio = bdiv(r1, r0);\n\t\t\tfairResA = bmul(resA, bpow(ratio, wB));\n\t\t\tfairResB = bdiv(resB, bpow(ratio, wA));\n\t\t} else {\n\t\t\tuint256 ratio = bdiv(r0, r1);\n\t\t\tfairResA = bdiv(resA, bpow(ratio, wB));\n\t\t\tfairResB = bmul(resB, bpow(ratio, wA));\n\t\t}\n\t}\n\n\tfunction getLpPrice(uint256 rdntPriceInEth) public view override returns (uint256 priceInEth) {\n\t\tIWeightedPool pool = IWeightedPool(lpTokenAddr);\n\t\t(address token0, ) = sortTokens(inTokenAddr, outTokenAddr);\n\t\t(uint256 rdntBalance, uint256 wethBalance, ) = getReserves();\n\t\tuint256[] memory weights = pool.getNormalizedWeights();\n\n\t\tuint256 rdntWeight;\n\t\tuint256 wethWeight;\n\n\t\tif (token0 == outTokenAddr) {\n\t\t\trdntWeight = weights[0];\n\t\t\twethWeight = weights[1];\n\t\t} else {\n\t\t\trdntWeight = weights[1];\n\t\t\twethWeight = weights[0];\n\t\t}\n\n\t\t// RDNT in eth, 8 decis\n\t\tuint256 pxA = rdntPriceInEth;\n\t\t// ETH in eth, 8 decis\n\t\tuint256 pxB = 100000000;\n\n\t\t(uint256 fairResA, uint256 fairResB) = computeFairReserves(\n\t\t\trdntBalance,\n\t\t\twethBalance,\n\t\t\trdntWeight,\n\t\t\twethWeight,\n\t\t\tpxA,\n\t\t\tpxB\n\t\t);\n\t\t// use fairReserveA and fairReserveB to compute LP token price\n\t\t// LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n\t\tpriceInEth = fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply());\n\t}\n\n\tfunction getPrice() public view returns (uint256 priceInEth) {\n\t\t(IERC20[] memory tokens, uint256[] memory balances, ) = IVault(vaultAddr).getPoolTokens(poolId);\n\t\tuint256 rdntBalance = address(tokens[0]) == outTokenAddr ? balances[0] : balances[1];\n\t\tuint256 wethBalance = address(tokens[0]) == outTokenAddr ? balances[1] : balances[0];\n\n\t\tuint256 poolWeight = 4;\n\n\t\treturn wethBalance.mul(1e8).div(rdntBalance.div(poolWeight));\n\t}\n\n\tfunction getReserves() public view override returns (uint256 rdnt, uint256 weth, uint256 lpTokenSupply) {\n\t\tIERC20 lpToken = IERC20(lpTokenAddr);\n\n\t\t(IERC20[] memory tokens, uint256[] memory balances, ) = IVault(vaultAddr).getPoolTokens(poolId);\n\n\t\trdnt = address(tokens[0]) == outTokenAddr ? balances[0] : balances[1];\n\t\tweth = address(tokens[0]) == outTokenAddr ? balances[1] : balances[0];\n\n\t\tlpTokenSupply = lpToken.totalSupply().div(1e18);\n\t}\n\n\tfunction joinPool(uint256 _wethAmt, uint256 _rdntAmt) internal returns (uint256 liquidity) {\n\t\t(address token0, address token1) = sortTokens(outTokenAddr, inTokenAddr);\n\t\tIAsset[] memory assets = new IAsset[](2);\n\t\tassets[0] = IAsset(token0);\n\t\tassets[1] = IAsset(token1);\n\n\t\tuint256[] memory maxAmountsIn = new uint256[](2);\n\t\tif (token0 == inTokenAddr) {\n\t\t\tmaxAmountsIn[0] = _wethAmt;\n\t\t\tmaxAmountsIn[1] = _rdntAmt;\n\t\t} else {\n\t\t\tmaxAmountsIn[0] = _rdntAmt;\n\t\t\tmaxAmountsIn[1] = _wethAmt;\n\t\t}\n\n\t\tbytes memory userDataEncoded = abi.encode(IWeightedPool.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, 0);\n\t\tIVault.JoinPoolRequest memory inRequest = IVault.JoinPoolRequest(assets, maxAmountsIn, userDataEncoded, false);\n\t\tIVault(vaultAddr).joinPool(poolId, address(this), address(this), inRequest);\n\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tliquidity = lp.balanceOf(address(this));\n\t}\n\n\tfunction zapWETH(uint256 amount) public override returns (uint256 liquidity) {\n\t\trequire(msg.sender == lockZap, \"!lockZap\");\n\t\tIWETH(wethAddr).transferFrom(msg.sender, address(this), amount);\n\t\tliquidity = joinPool(amount, 0);\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\t\trefundDust(outTokenAddr, wethAddr, msg.sender);\n\t}\n\n\tfunction zapTokens(uint256 _wethAmt, uint256 _rdntAmt) public override returns (uint256 liquidity) {\n\t\trequire(msg.sender == lockZap, \"!lockZap\");\n\t\tIWETH(wethAddr).transferFrom(msg.sender, address(this), _wethAmt);\n\t\tIERC20(outTokenAddr).safeTransferFrom(msg.sender, address(this), _rdntAmt);\n\n\t\tliquidity = joinPool(_wethAmt, _rdntAmt);\n\t\tIERC20 lp = IERC20(lpTokenAddr);\n\t\tlp.safeTransfer(msg.sender, liquidity);\n\n\t\trefundDust(outTokenAddr, wethAddr, msg.sender);\n\t}\n\n\tfunction sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n\t\trequire(tokenA != tokenB, \"BalancerZap: IDENTICAL_ADDRESSES\");\n\t\t(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n\t\trequire(token0 != address(0), \"BalancerZap: ZERO_ADDRESS\");\n\t}\n\n\tfunction quoteFromToken(uint256 tokenAmount) public view override returns (uint256 optimalWETHAmount) {\n\t\tuint256 rdntPriceInEth = getPrice();\n\t\tuint256 p1 = rdntPriceInEth.mul(1e10);\n\t\tuint256 ethRequiredBeforeWeight = tokenAmount.mul(p1).div(1e18);\n\t\toptimalWETHAmount = ethRequiredBeforeWeight.div(4);\n\t}\n\n\tfunction swap(\n\t\tuint256 _amount,\n\t\taddress _tokenInAddress,\n\t\taddress _tokenOutAddress,\n\t\taddress _lpAddr\n\t) internal returns (uint256 amountOut) {\n\t\tIAsset tokenInAddress = IAsset(_tokenInAddress);\n\t\tIAsset tokenOutAddress = IAsset(_tokenOutAddress);\n\n\t\tbytes32 _poolId = IWeightedPool(_lpAddr).getPoolId();\n\n\t\tbytes memory userDataEncoded = abi.encode(); //https://dev.balancer.fi/helpers/encoding\n\t\tIVault.SingleSwap memory singleSwapRequest = IVault.SingleSwap(\n\t\t\t_poolId,\n\t\t\tIVault.SwapKind.GIVEN_IN,\n\t\t\ttokenInAddress,\n\t\t\ttokenOutAddress,\n\t\t\t_amount,\n\t\t\tuserDataEncoded\n\t\t);\n\t\tIVault.FundManagement memory fundManagementRequest = IVault.FundManagement(\n\t\t\taddress(this),\n\t\t\tfalse,\n\t\t\tpayable(address(this)),\n\t\t\tfalse\n\t\t);\n\n\t\tuint256 limit = 0;\n\n\t\tamountOut = IVault(vaultAddr).swap(\n\t\t\tsingleSwapRequest,\n\t\t\tfundManagementRequest,\n\t\t\tlimit,\n\t\t\t(block.timestamp + 3 minutes)\n\t\t);\n\t}\n\n\tfunction setLockZap(address _lockZap) external onlyOwner {\n\t\trequire(_lockZap != address(0), \"lockZap is 0 address\");\n\t\tlockZap = _lockZap;\n\t}\n\n\tfunction getSwapFeePercentage() public onlyOwner returns (uint256 fee) {\n\t\tIWeightedPool pool = IWeightedPool(lpTokenAddr);\n\t\tfee = pool.getSwapFeePercentage();\n\t}\n\n\tfunction setSwapFeePercentage(uint256 _fee) public onlyOwner {\n\t\tIWeightedPool pool = IWeightedPool(lpTokenAddr);\n\t\tpool.setSwapFeePercentage(_fee);\n\t}\n}\n"
    },
    "contracts/radiant/zap/helpers/DustRefunder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../interfaces/IWETH.sol\";\n\ncontract DustRefunder {\n\tusing SafeERC20 for IERC20;\n\n\tfunction refundDust(address _rdnt, address _weth, address _refundAddress) internal {\n\t\tIERC20 rdnt = IERC20(_rdnt);\n\t\tIWETH weth = IWETH(_weth);\n\n\t\tuint256 dustWETH = weth.balanceOf(address(this));\n\t\tif (dustWETH > 0) {\n\t\t\tweth.transfer(_refundAddress, dustWETH);\n\t\t}\n\t\tuint256 dustRdnt = rdnt.balanceOf(address(this));\n\t\tif (dustRdnt > 0) {\n\t\t\trdnt.safeTransfer(_refundAddress, dustRdnt);\n\t\t}\n\t}\n}\n"
    },
    "contracts/radiant/zap/LockZap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\npragma abicoder v2;\n\nimport \"./helpers/DustRefunder.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/Initializable.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/OwnableUpgradeable.sol\";\nimport \"../../dependencies/openzeppelin/upgradeability/PausableUpgradeable.sol\";\n\nimport \"../../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport \"../../interfaces/ILiquidityZap.sol\";\nimport \"../../interfaces/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/IPoolHelper.sol\";\nimport \"../../interfaces/IPriceProvider.sol\";\nimport \"../../interfaces/IChainlinkAggregator.sol\";\nimport \"../../interfaces/IWETH.sol\";\n\n/// @title Borrow gate via stargate\n/// @author Radiant\n/// @dev All function calls are currently implemented without side effects\ncontract LockZap is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    DustRefunder\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /// @notice RAITO Divisor\n    uint256 public constant RATIO_DIVISOR = 10000;\n\n    /// @notice Acceptable ratio\n    uint256 public ACCEPTABLE_RATIO;\n\n    /// @notice Wrapped ETH\n    IWETH public weth;\n\n    /// @notice RDNT token address\n    address public rdntAddr;\n\n    /// @notice Multi Fee distribution contract\n    IMultiFeeDistribution public mfd;\n\n    /// @notice Lending Pool contract\n    ILendingPool public lendingPool;\n\n    /// @notice Pool helper contract\n    IPoolHelper public poolHelper;\n\n    /// @notice Price provider contract\n    IPriceProvider public priceProvider;\n\n    /// @notice ETH oracle contract\n    IChainlinkAggregator public ethOracle;\n\n    /// @notice Emitted when zap is done\n    event Zapped(\n        bool _borrow,\n        uint256 _ethAmt,\n        uint256 _rdntAmt,\n        address indexed _from,\n        address indexed _onBehalf,\n        uint256 _lockTypeIndex\n    );\n\n    event SlippageRatioChanged(uint256 newRatio);\n\n    uint256 public ethLPRatio; // paramter to set the ratio of ETH in the LP token, can be 2000 for an 80/20 bal lp\n\n    /**\n     * @notice Initializer\n     * @param _poolHelper Pool helper address\n     * @param _lendingPool Lending pool\n     * @param _weth weth address\n     * @param _rdntAddr RDNT token address\n     */\n    function initialize(\n        IPoolHelper _poolHelper,\n        ILendingPool _lendingPool,\n        IWETH _weth,\n        address _rdntAddr,\n        uint256 _ethLPRatio,\n        uint256 _ACCEPTABLE_RATIO\n    ) external initializer {\n        require(\n            address(_poolHelper) != address(0),\n            \"PoolHelper can't be 0 address\"\n        );\n        require(\n            address(_lendingPool) != address(0),\n            \"LendingPool can't be 0 address\"\n        );\n        require(address(_weth) != address(0), \"WETH can't be 0 address\");\n        require(_rdntAddr != address(0), \"RDNT can't be 0 address\");\n        require(_ethLPRatio > 0 && _ethLPRatio < 10_000, \"Invalid ethLPRatio\");\n        __Ownable_init();\n        __Pausable_init();\n\n        lendingPool = _lendingPool;\n        poolHelper = _poolHelper;\n        weth = _weth;\n        rdntAddr = _rdntAddr;\n        ethLPRatio = _ethLPRatio;\n        ACCEPTABLE_RATIO = _ACCEPTABLE_RATIO;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Set Price Provider.\n     * @param _provider Price provider contract address.\n     */\n    function setPriceProvider(address _provider) external onlyOwner {\n        require(\n            address(_provider) != address(0),\n            \"PriceProvider can't be 0 address\"\n        );\n        priceProvider = IPriceProvider(_provider);\n        ethOracle = IChainlinkAggregator(\n            priceProvider.baseTokenPriceInUsdProxyAggregator()\n        );\n    }\n\n    /**\n     * @notice Set Multi fee distribution contract.\n     * @param _mfdAddr New contract address.\n     */\n    function setMfd(address _mfdAddr) external onlyOwner {\n        require(address(_mfdAddr) != address(0), \"MFD can't be 0 address\");\n        mfd = IMultiFeeDistribution(_mfdAddr);\n    }\n\n    /**\n     * @notice Set Pool Helper contract\n     * @param _poolHelper New PoolHelper contract address.\n     */\n    function setPoolHelper(address _poolHelper) external onlyOwner {\n        require(\n            address(_poolHelper) != address(0),\n            \"PoolHelper can't be 0 address\"\n        );\n        poolHelper = IPoolHelper(_poolHelper);\n    }\n\n    /**\n     * @notice Returns pool helper address\n     */\n    function getPoolHelper() public view returns (address) {\n        return address(poolHelper);\n    }\n\n    /**\n     * @notice Get Variable debt token address\n     * @param _asset underlying.\n     */\n    function getVDebtToken(address _asset) public view returns (address) {\n        DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n            _asset\n        );\n        return reserveData.variableDebtTokenAddress;\n    }\n\n    /**\n     * @notice Get quote from the pool\n     * @param _tokenAmount amount of tokens.\n     */\n    function quoteFromToken(\n        uint256 _tokenAmount\n    ) public view returns (uint256 optimalWETHAmount) {\n        optimalWETHAmount = poolHelper\n            .quoteFromToken(_tokenAmount)\n            .mul(100)\n            .div(97);\n    }\n\n    /**\n     * @notice Zap tokens to stake LP\n     * @param _borrow option to borrow ETH\n     * @param _wethAmt amount of weth.\n     * @param _rdntAmt amount of RDNT.\n     * @param _lockTypeIndex lock length index.\n     */\n    function zap(\n        bool _borrow,\n        uint256 _wethAmt,\n        uint256 _rdntAmt,\n        uint256 _lockTypeIndex\n    ) public payable whenNotPaused returns (uint256 liquidity) {\n        return\n            _zap(\n                _borrow,\n                _wethAmt,\n                _rdntAmt,\n                msg.sender,\n                msg.sender,\n                _lockTypeIndex,\n                msg.sender\n            );\n    }\n\n    /**\n     * @notice Zap tokens to stake LP\n     * @dev It will use default lock index\n     * @param _borrow option to borrow ETH\n     * @param _wethAmt amount of weth.\n     * @param _rdntAmt amount of RDNT.\n     * @param _onBehalf user address to be zapped.\n     */\n    function zapOnBehalf(\n        bool _borrow,\n        uint256 _wethAmt,\n        uint256 _rdntAmt,\n        address _onBehalf\n    ) public payable whenNotPaused returns (uint256 liquidity) {\n        uint256 duration = mfd.defaultLockIndex(_onBehalf);\n        return\n            _zap(\n                _borrow,\n                _wethAmt,\n                _rdntAmt,\n                msg.sender,\n                _onBehalf,\n                duration,\n                _onBehalf\n            );\n    }\n\n    /**\n     * @notice Zap tokens from vesting\n     * @param _borrow option to borrow ETH\n     * @param _lockTypeIndex lock length index.\n     */\n    function zapFromVesting(\n        bool _borrow,\n        uint256 _lockTypeIndex\n    ) public payable whenNotPaused returns (uint256 liquidity) {\n        uint256 rdntAmt = mfd.zapVestingToLp(msg.sender);\n        uint256 wethAmt = quoteFromToken(rdntAmt);\n        return\n            _zap(\n                _borrow,\n                wethAmt,\n                rdntAmt,\n                address(this),\n                msg.sender,\n                _lockTypeIndex,\n                msg.sender\n            );\n    }\n\n    /**\n     * @notice Borrow ETH\n     * @param _amount of ETH\n     */\n    function _executeBorrow(uint256 _amount) internal {\n        (, , uint256 availableBorrowsETH, , , ) = lendingPool\n            .getUserAccountData(msg.sender);\n        uint256 amountInETH = _amount.mul(10 ** 8).div(\n            10 ** ERC20(address(weth)).decimals()\n        );\n        require(\n            availableBorrowsETH > amountInETH,\n            \"Not enough availableBorrowsETH\"\n        );\n\n        uint16 referralCode = 0;\n        lendingPool.borrow(address(weth), _amount, 2, referralCode, msg.sender);\n    }\n\n    /**\n     * @notice Calculates slippage ratio from weth to LP\n     * @param _ethAmt ETH amount\n     * @param _liquidity LP token amount\n     */\n    function _calcSlippage(\n        uint256 _ethAmt,\n        uint256 _liquidity\n    ) internal returns (uint256 ratio) {\n        priceProvider.update();\n        uint256 ethAmtUsd = _ethAmt.mul(uint256(ethOracle.latestAnswer())).div(\n            1E18\n        );\n        uint256 lpAmtUsd = _liquidity * priceProvider.getLpTokenPriceUsd();\n        ratio = lpAmtUsd.mul(RATIO_DIVISOR).div(ethAmtUsd);\n        ratio = ratio.div(1E18);\n    }\n\n    /**\n     * @notice Zap into LP\n     * @param _borrow option to borrow ETH\n     * @param _wethAmt amount of weth.\n     * @param _rdntAmt amount of RDNT.\n     * @param _from src address of RDNT\n     * @param _onBehalf of the user.\n     * @param _lockTypeIndex lock length index.\n     * @param _refundAddress dust is refunded to this address.\n     */\n    function _zap(\n        bool _borrow,\n        uint256 _wethAmt,\n        uint256 _rdntAmt,\n        address _from,\n        address _onBehalf,\n        uint256 _lockTypeIndex,\n        address _refundAddress\n    ) internal returns (uint256 liquidity) {\n        require(_wethAmt != 0 || msg.value != 0, \"ETH required\");\n        if (msg.value != 0) {\n            require(!_borrow, \"invalid zap ETH source\");\n            _wethAmt = msg.value;\n            weth.deposit{value: _wethAmt}();\n        } else {\n            if (_borrow) {\n                _executeBorrow(_wethAmt);\n            } else {\n                weth.transferFrom(msg.sender, address(this), _wethAmt);\n            }\n        }\n\n        uint256 totalWethValueIn;\n        weth.approve(address(poolHelper), _wethAmt);\n        //case where rdnt is matched with borrowed ETH\n        if (_rdntAmt != 0) {\n            require(\n                _wethAmt >= poolHelper.quoteFromToken(_rdntAmt),\n                \"ETH sent is not enough\"\n            );\n\n            // _from == this when zapping from vesting\n            if (_from != address(this)) {\n                IERC20(rdntAddr).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    _rdntAmt\n                );\n            }\n\n            IERC20(rdntAddr).safeApprove(address(poolHelper), _rdntAmt);\n            liquidity = poolHelper.zapTokens(_wethAmt, _rdntAmt);\n            totalWethValueIn = _wethAmt.mul(RATIO_DIVISOR).div(ethLPRatio);\n        } else {\n            liquidity = poolHelper.zapWETH(_wethAmt);\n            totalWethValueIn = _wethAmt;\n        }\n\n        if (address(priceProvider) != address(0)) {\n            uint256 slippage = _calcSlippage(totalWethValueIn, liquidity);\n            require(slippage >= ACCEPTABLE_RATIO, \"too much slippage\");\n        }\n\n        IERC20(poolHelper.lpTokenAddr()).safeApprove(address(mfd), liquidity);\n        mfd.stake(liquidity, _onBehalf, _lockTypeIndex);\n        emit Zapped(\n            _borrow,\n            _wethAmt,\n            _rdntAmt,\n            _from,\n            _onBehalf,\n            _lockTypeIndex\n        );\n\n        refundDust(rdntAddr, address(weth), _refundAddress);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setAcceptableRatio(uint256 _newRatio) external onlyOwner {\n        require(_newRatio <= RATIO_DIVISOR, \"ratio too high\");\n        ACCEPTABLE_RATIO = _newRatio;\n        emit SlippageRatioChanged(ACCEPTABLE_RATIO);\n    }\n}\n"
    },
    "contracts/test/oracle/LendingRateOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.12;\r\n\r\nimport {ILendingRateOracle} from \"../../interfaces/ILendingRateOracle.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract LendingRateOracle is ILendingRateOracle, Ownable {\r\n\tmapping(address => uint256) borrowRates;\r\n\tmapping(address => uint256) liquidityRates;\r\n\r\n\tfunction getMarketBorrowRate(address _asset) external view override returns (uint256) {\r\n\t\treturn borrowRates[_asset];\r\n\t}\r\n\r\n\tfunction setMarketBorrowRate(address _asset, uint256 _rate) external override onlyOwner {\r\n\t\tborrowRates[_asset] = _rate;\r\n\t}\r\n\r\n\tfunction getMarketLiquidityRate(address _asset) external view returns (uint256) {\r\n\t\treturn liquidityRates[_asset];\r\n\t}\r\n\r\n\tfunction setMarketLiquidityRate(address _asset, uint256 _rate) external onlyOwner {\r\n\t\tliquidityRates[_asset] = _rate;\r\n\t}\r\n}"
    },
    "contracts/test/testnet-helpers/Faucet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {TestnetERC20} from './TestnetERC20.sol';\nimport {IFaucet} from './IFaucet.sol';\n\n/**\n * @title Faucet\n * @dev Ownable Faucet Contract\n */\ncontract Faucet is IFaucet, Ownable {\n  /// @inheritdoc IFaucet\n  uint256 public constant MAX_MINT_AMOUNT = 10000;\n\n  // Mapping to control mint of assets (allowed by default)\n  mapping(address => bool) internal _nonMintable;\n\n  // If _permissioned is enabled, then only owner can mint Testnet ERC20 tokens\n  // If disabled, anyone can call mint at the faucet, for PoC environments\n  bool internal _permissioned;\n\n  constructor(address owner, bool permissioned) {\n    require(owner != address(0));\n    transferOwnership(owner);\n    _permissioned = permissioned;\n  }\n\n  /**\n   * @dev Function modifier, if _permissioned is enabled then msg.sender is required to be the owner\n   */\n  modifier onlyOwnerIfPermissioned() {\n    if (_permissioned == true) {\n      require(owner() == _msgSender(), 'Ownable: caller is not the owner');\n    }\n    _;\n  }\n\n  /// @inheritdoc IFaucet\n  function mint(\n    address token,\n    address to,\n    uint256 amount\n  ) external override onlyOwnerIfPermissioned returns (uint256) {\n    require(!_nonMintable[token], 'Error: not mintable');\n    require(\n      amount <= MAX_MINT_AMOUNT * (10 ** TestnetERC20(token).decimals()),\n      'Error: Mint limit transaction exceeded'\n    );\n\n    TestnetERC20(token).mint(to, amount);\n    return amount;\n  }\n\n  /// @inheritdoc IFaucet\n  function setPermissioned(bool permissioned) external override onlyOwner {\n    _permissioned = permissioned;\n  }\n\n  /// @inheritdoc IFaucet\n  function isPermissioned() external view override returns (bool) {\n    return _permissioned;\n  }\n\n  /// @inheritdoc IFaucet\n  function setMintable(address asset, bool active) external override onlyOwner {\n    _nonMintable[asset] = !active;\n  }\n\n  /// @inheritdoc IFaucet\n  function isMintable(address asset) external view override returns (bool) {\n    return !_nonMintable[asset];\n  }\n\n  /// @inheritdoc IFaucet\n  function transferOwnershipOfChild(\n    address[] calldata childContracts,\n    address newOwner\n  ) external override onlyOwner {\n    for (uint256 i = 0; i < childContracts.length; i++) {\n      Ownable(childContracts[i]).transferOwnership(newOwner);\n    }\n  }\n}\n"
    },
    "contracts/test/testnet-helpers/IFaucet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IFaucet {\n  /**\n   * @notice Returns the maximum amount of tokens per mint allowed\n   * @return The maximum amount of tokens per mint allowed\n   */\n  function MAX_MINT_AMOUNT() external pure returns (uint256);\n\n  /**\n   * @notice Function to mint Testnet tokens to the destination address\n   * @param token The address of the token to perform the mint\n   * @param to The address to send the minted tokens\n   * @param amount The amount of tokens to mint\n   * @return The amount minted\n   **/\n  function mint(address token, address to, uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Enable or disable the need of authentication to call `mint` function\n   * @param value If true, ask for authentication at `mint` function, if false, disable the authentication\n   */\n  function setPermissioned(bool value) external;\n\n  /**\n   * @notice Getter to determine if permissioned mode is enabled or disabled\n   * @return Returns a boolean, if true the mode is enabled, if false is disabled\n   */\n  function isPermissioned() external view returns (bool);\n\n  /**\n   * @notice Enable or disable the minting of the faucet asset\n   * @param asset The address of the asset\n   * @param active True to enable, false to disable\n   */\n  function setMintable(address asset, bool active) external;\n\n  /**\n   * @notice Returns whether the asset is mintable\n   * @param asset The address of the asset\n   * @return True if the asset is mintable, false otherwise\n   */\n  function isMintable(address asset) external view returns (bool);\n\n  /**\n   * @notice Transfer the ownership of child contracts\n   * @param childContracts A list of child contract addresses\n   * @param newOwner The address of the new owner\n   */\n  function transferOwnershipOfChild(address[] calldata childContracts, address newOwner) external;\n}\n"
    },
    "contracts/test/testnet-helpers/MockAggregator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.10;\n\ncontract MockAggregator {\n  int256 private _latestAnswer;\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  constructor(int256 initialAnswer) {\n    _latestAnswer = initialAnswer;\n    emit AnswerUpdated(initialAnswer, 0, block.timestamp);\n  }\n\n  function latestAnswer() external view returns (int256) {\n    return _latestAnswer;\n  }\n\n  function getTokenType() external pure returns (uint256) {\n    return 1;\n  }\n\n  function decimals() external pure returns (uint8) {\n    return 8;\n  }\n}\n"
    },
    "contracts/test/testnet-helpers/TestnetERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20Permit} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol';\n/**\n * @title TestnetERC20\n * @dev ERC20 minting logic\n */ \ncontract TestnetERC20 is IERC20Permit, ERC20, Ownable {\n  bytes public constant EIP712_REVISION = bytes('1');\n  bytes32 internal constant EIP712_DOMAIN =\n    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  // Map of address nonces (address => nonce)\n  mapping(address => uint256) internal _nonces;\n\n  bytes32 public DOMAIN_SEPARATOR;\n\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint8 decimals,\n    address owner\n  ) ERC20(name, symbol) {\n    uint256 chainId = block.chainid;\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        EIP712_DOMAIN,\n        keccak256(bytes(name)),\n        keccak256(EIP712_REVISION),\n        chainId,\n        address(this)\n      )\n    );\n    _setupDecimals(decimals);\n    require(owner != address(0));\n    transferOwnership(owner);\n  }\n\n  /// @inheritdoc IERC20Permit\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    require(owner != address(0), 'INVALID_OWNER');\n    //solium-disable-next-line\n    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\n    uint256 currentValidNonce = _nonces[owner];\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        '\\x19\\x01',\n        DOMAIN_SEPARATOR,\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\n      )\n    );\n    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\n    _nonces[owner] = currentValidNonce + 1;\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param value The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(uint256 value) public virtual onlyOwner returns (bool) {\n    _mint(_msgSender(), value);\n    return true;\n  }\n\n  /**\n   * @dev Function to mint tokens to address\n   * @param account The account to mint tokens.\n   * @param value The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(address account, uint256 value) public virtual onlyOwner returns (bool) {\n    _mint(account, value);\n    return true;\n  }\n\n  function nonces(address owner) public view returns (uint256) {\n    return _nonces[owner];\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}